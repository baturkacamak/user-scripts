// ==UserScript==
// @name        Meta AI Media Enhancer
// @description Automate prompt sending to Meta AI Media with multiple prompts and configurable delays
// @namespace   https://github.com/baturkacamak/userscripts
// @version     1.2.0
// @author      Batur Kacamak
// @license     MIT
// @homepage    https://github.com/baturkacamak/userscripts/tree/master/userscripts/meta-ai-media-enhancer#readme
// @homepageURL https://github.com/baturkacamak/userscripts/tree/master/userscripts/meta-ai-media-enhancer#readme
// @supportURL  https://github.com/baturkacamak/userscripts/issues
// @downloadURL https://github.com/baturkacamak/userscripts/raw/master/userscripts/meta-ai-media-enhancer/meta-ai-media-enhancer.user.js
// @updateURL   https://github.com/baturkacamak/userscripts/raw/master/userscripts/meta-ai-media-enhancer/meta-ai-media-enhancer.user.js
// @match       https://www.meta.ai/media*
// @icon        https://www.meta.ai/favicon.ico
// @run-at      document-idle
// @grant       GM_setClipboard
// @grant       GM_getValue
// @grant       GM_setValue
// ==/UserScript==

// !!!!! ATTENTION !!!!!
// DO NOT EDIT THIS FILE DIRECTLY!
// This file is automatically generated from the source script.
// Any direct modifications will be overwritten during the next build.
// Please make your changes in the original source file.
//

(function () {
    'use strict';

    /**
     * Enhanced Logger - A feature-rich logging utility
     * Supports log levels, styling, grouping, caller info, filtering, persistence, exporting, and more
     */
    class Logger {
        static DEBUG = true;
        static PREFIX = "Userscript";
        static _customFormat = null;
        static _logHistory = [];
        static _filters = new Set();
        static _lastTimestamp = null;
        static _persist = false;
        static _mock = false;
        static _theme = {
            debug: "color: #3498db; font-weight: bold;",
            info: "color: #1abc9c; font-weight: bold;",
            warn: "color: #f39c12; font-weight: bold;",
            error: "color: #e74c3c; font-weight: bold;",
            success: "color: #2ecc71; font-weight: bold;",
            trace: "color: #8e44ad; font-weight: bold;",
            htmlTitle: "color: #9b59b6; font-weight: bold;",
            htmlContent: "color: #2c3e50;",
            toggle: "color: #f39c12; font-weight: bold;"
        };
        static _emojis = {
            debug: "\uD83D\uDC1B",
            info: "\u2139\uFE0F",
            warn: "\u26A0\uFE0F",
            error: "\u274C",
            success: "\u2705",
            trace: "\uD83D\uDCCC",
            html: "\uD83E\uDDE9",
            toggle: "\uD83C\uDF9B\uFE0F"
        };

        static setTimeFormat(locale = "en-US", use12Hour = false) {
            this._customFormat = {locale, hour12: use12Hour};
        }

        static _detectTimeFormat() {
            try {
                const testDate = new Date(Date.UTC(2020, 0, 1, 13, 0, 0));
                const locale = navigator.language || "tr-TR";
                const timeString = testDate.toLocaleTimeString(locale);
                const is12Hour = timeString.toLowerCase().includes("pm") || timeString.toLowerCase().includes("am");
                return {locale, hour12: is12Hour};
            } catch (e) {
                return {locale: "tr-TR", hour12: false};
            }
        }

        static _timestamp() {
            const now = new Date();

            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
            const year = now.getFullYear();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const milliseconds = String(now.getMilliseconds()).padStart(3, '0');

            const time = `${day}/${month}/${year}, ${hours}:${minutes}:${seconds}.${milliseconds}`;

            let diff = "";
            if (this._lastTimestamp) {
                const ms = now - this._lastTimestamp;
                diff = ` [+${(ms / 1000).toFixed(3)}s]`; // Keep 3 decimal places for ms in diff
            }
            this._lastTimestamp = now;
            return `${time}${diff}`;
        }

        static _getCaller() {
            const err = new Error();
            const stack = err.stack?.split("\n")[3];
            return stack ? stack.trim() : "(unknown)";
        }

        static _log(level, ...args) {
            if (!this.DEBUG && level === "debug") return;
            if (this._filters.size && !args.some(arg => this._filters.has(arg))) return;
            const emoji = this._emojis[level] || '';
            const style = this._theme[level] || '';
            const timestamp = this._timestamp();
            const caller = this._getCaller();

            const message = [
                `%c${timestamp} %c${emoji} [${this.PREFIX} ${level.toUpperCase()}]%c:`,
                "color: gray; font-style: italic;",
                style,
                "color: inherit;",
                ...args,
                `\nCaller: ${caller}`
            ];

            this._logHistory.push({timestamp, level, args});

            if (this._persist) localStorage.setItem("LoggerHistory", JSON.stringify(this._logHistory));
            if (!this._mock) console.log(...message);
        }

        static debug(...args) {
            this._log("debug", ...args);
        }

        static info(...args) {
            this._log("info", ...args);
        }

        static warn(...args) {
            this._log("warn", ...args);
        }

        static error(...args) {
            this._log("error", ...args);
        }

        static success(...args) {
            this._log("success", ...args);
        }

        static trace(...args) {
            this._log("trace", ...args);
            console.trace();
        }

        static logHtml(title, htmlContent) {
            const shortContent = htmlContent.substring(0, 1500) + "...";
            this._log("html", `[${title}]`, shortContent);
            if (!this._mock) {
                console.groupCollapsed(`%c\uD83E\uDDE9 HTML Details (${title})`, this._theme.htmlTitle);
                console.log("%cComplete HTML:", this._theme.htmlTitle);
                console.log(`%c${htmlContent}`, this._theme.htmlContent);
                console.groupEnd();
            }
        }

        static setPrefix(prefix) {
            this.PREFIX = prefix;
        }

        static setTheme(theme) {
            Object.assign(this._theme, theme);
        }

        static newPrefix(prefix) {
            const prefixedLogger = {};
            const levels = ['debug', 'info', 'warn', 'error', 'success', 'trace', 'logHtml', 'step', 'hello'];

            levels.forEach(level => {
                prefixedLogger[level] = (...args) => {
                    const originalPrefix = this.PREFIX;
                    try {
                        this.setPrefix(prefix);
                        if (typeof Logger[level] === 'function') {
                            Logger[level](...args);
                        }
                    } finally {
                        this.setPrefix(originalPrefix);
                    }
                };
            });
            return prefixedLogger;
        }

        static addFilter(tag) {
            this._filters.add(tag);
        }

        static clearFilters() {
            this._filters.clear();
        }

        static persistLogs(enable = true) {
            this._persist = enable;
        }

        static mock(enable = true) {
            this._mock = enable;
        }

        static group(label) {
            if (!this._mock) console.group(label);
        }

        static groupEnd() {
            if (!this._mock) console.groupEnd();
        }

        static step(msg) {
            this.info(`\u2705 ${msg}`);
        }

        static hello() {
            this.info("Hello, dev! \uD83D\uDC4B Ready to debug?");
        }

        static downloadLogs(filename = "logs.json") {
            const blob = new Blob([JSON.stringify(this._logHistory, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        static autoClear(intervalMs) {
            setInterval(() => {
                this._logHistory = [];
                if (this._persist) localStorage.removeItem("LoggerHistory");
            }, intervalMs);
        }
    }

    /**
     * PubSub - A simple publish/subscribe pattern implementation
     * Enables components to communicate without direct references
     */
    class PubSub {
        static #events = {};

        /**
         * Subscribe to an event
         * @param {string} event - Event name
         * @param {Function} callback - Callback function
         * @return {string} Subscription ID
         */
        static subscribe(event, callback) {
            if (!this.#events[event]) {
                this.#events[event] = [];
            }

            const subscriptionId = `${event}_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
            this.#events[event].push({callback, subscriptionId});
            return subscriptionId;
        }

        /**
         * Unsubscribe from an event
         * @param {string} subscriptionId - Subscription ID
         * @return {boolean} Success state
         */
        static unsubscribe(subscriptionId) {
            for (const event in this.#events) {
                const index = this.#events[event].findIndex(sub => sub.subscriptionId === subscriptionId);
                if (index !== -1) {
                    this.#events[event].splice(index, 1);
                    return true;
                }
            }
            return false;
        }

        /**
         * Publish an event
         * @param {string} event - Event name
         * @param {any} data - Data to pass to subscribers
         */
        static publish(event, data) {
            if (!this.#events[event]) {
                return;
            }

            this.#events[event].forEach(sub => {
                sub.callback(data);
            });
        }

        /**
         * Clear all subscriptions
         * @param {string} [event] - Optional event name to clear only specific event
         */
        static clear(event) {
            if (event) {
                delete this.#events[event];
            } else {
                this.#events = {};
            }
        }
    }

    class UrlChangeWatcher {
      constructor(strategies = [], fireImmediately = true) {
        this.strategies = strategies;
        this.fireImmediately = fireImmediately;
        this.lastUrl = location.href;
        this.active = false;
      }

      start() {
        if (this.active) return;
        this.active = true;
        Logger.debug('UrlChangeWatcher (Strategy) started');

        this.strategies.forEach((strategy) =>
          strategy.start?.(this._handleChange.bind(this)),
        );

        if (this.fireImmediately) {
          this._handleChange(location.href, null, true);
        }
      }

      stop() {
        this.active = false;
        this.strategies.forEach((strategy) => strategy.stop?.());
        Logger.debug('UrlChangeWatcher (Strategy) stopped');
      }

      _handleChange(newUrl, oldUrl = this.lastUrl, force = false) {
        if (!force && newUrl === this.lastUrl) return;
        Logger.debug(`URL changed: ${oldUrl} â†’ ${newUrl}`);

        this.lastUrl = newUrl;

        if (PubSub?.publish) {
          PubSub.publish('urlchange', {newUrl, oldUrl});
        }
      }
    }

    /**
     * DOMObserver - Observes DOM changes and URL changes
     * Uses UrlChangeWatcher for URL change detection with configurable strategies
     */
    class DOMObserver {
      /**
         * Wait for elements matching a selector or any of multiple selectors
         * @param {string|string[]} selectorOrSelectors - CSS selector or array of selectors to wait for
         * @param {number} timeout - Timeout in milliseconds
         * @return {Promise<NodeList>} - Promise resolving to found elements
         */
      static waitForElements(selectorOrSelectors, timeout = 10000) {
        return new Promise((resolve, reject) => {
          const startTime = Date.now();
          const selectors = Array.isArray(selectorOrSelectors) ? selectorOrSelectors : [selectorOrSelectors];

          function checkElements() {
            for (const selector of selectors) {
            const elements = document.querySelectorAll(selector);
              if (elements.length > 0) {
              resolve(elements);
              return;
              }
            }

            if (Date.now() - startTime > timeout) {
              reject(new Error(`Timeout waiting for elements: ${selectors.join(', ')}`));
              return;
            }

            requestAnimationFrame(checkElements);
          }

          checkElements();
        });
      }
      /**
         * Create a new DOMObserver
         * @param {Function} onMutation - Callback for handling mutations
         * @param {Array} urlChangeStrategies - Array of URL change detection strategies to use
         */
      constructor(onMutation, urlChangeStrategies = []) {
        this.observer = new MutationObserver(this.handleMutations.bind(this));
        this.lastUrl = location.href;
        this.onMutation = onMutation;

        // Initialize URL change watcher with provided strategies
        this.urlChangeWatcher = new UrlChangeWatcher(urlChangeStrategies, false); // false = don't fire immediately
      }


      /**
         * Start observing DOM changes and URL changes
         * @param {HTMLElement} target - Element to observe (defaults to document.body)
         * @param {Object} config - MutationObserver configuration (defaults to sensible values)
         */
      observe(target = document.body, config = {childList: true, subtree: true}) {
        this.observer.observe(target, config);

        // Start URL change watcher
        this.urlChangeWatcher.start();
      }

      /**
         * Stop observing DOM changes and URL changes
         */
      disconnect() {
        this.observer.disconnect();

        // Stop URL change watcher
        this.urlChangeWatcher.stop();
      }

      /**
         * Handle mutations
         * @param {MutationRecord[]} mutations - Array of mutation records
         * @private
         */
      handleMutations(mutations) {
        if (this.onMutation) {
          this.onMutation(mutations);
        }
      }
    }

    /**
     * HTMLUtils - Utilities for HTML manipulation
     * Provides functions for escaping HTML, encoding/decoding entities, etc.
     */

    class HTMLUtils {
        static #policy;

        /**
         * Escape special HTML characters to prevent XSS
         * @param {string} str - The string to escape
         * @return {string} - The escaped string
         */
        static escapeHTML(str) {
            const escapeMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '\'': '&#39;',
                '"': '&quot;',
            };
            return str.replace(/[&<>'"]/g, (tag) => escapeMap[tag] || tag);
        }

        /**
         * Escape XML special characters
         * @param {string} str - The string to escape
         * @return {string} - The escaped string
         */
        static escapeXML(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        /**
         * Convert a plain text string to sanitized HTML
         * @param {string} text - The text to convert
         * @return {string} - HTML with line breaks and links
         */
        static textToHtml(text) {
            if (!text) return '';

            // First escape HTML
            let html = this.escapeHTML(text);

            // Convert line breaks to <br>
            html = html.replace(/\n/g, '<br>');

            // Convert URLs to links
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            html = html.replace(urlRegex, (url) => `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`);

            return html;
        }

        /**
         * * Wait for a specific element to appear in the DOM.
         *  * Continues checking using requestAnimationFrame until it appears,
         *  * a timeout is reached, or the maximum number of attempts is exceeded.
         *  *
         *  * @param {string} selector - CSS selector of the target element.
         *  * @param {number} [timeout=10000] - Maximum time in milliseconds to wait.
         *  * @param {Document|Element} [root=document] - DOM root to query from.
         *  * @param {number} [maxRetries=60] - Maximum number of requestAnimationFrame attempts.
         *  * @returns {Promise<Element>} Resolves with the found element or rejects on timeout.
         */
        static waitForElement(selector, timeout = 10000, root = document, maxRetries = 60) {
            return new Promise((resolve, reject) => {
                const startTime = Date.now();
                let attempts = 0;

                function checkElement() {
                    const element = root.querySelector(selector);
                    if (element) {
                        resolve(element);
                        return;
                    }

                    if ((Date.now() - startTime > timeout) || (attempts >= maxRetries)) {
                        reject(new Error(`Timeout waiting for element: ${selector}`));
                        return;
                    }

                    attempts++;
                    requestAnimationFrame(checkElement);
                }

                checkElement();
            });
        }

        static decodeHtmlEntities(encodedString) {
            if (!encodedString || typeof encodedString !== 'string') return encodedString;
            const textarea = document.createElement('textarea');
            textarea.innerHTML = encodedString;
            return textarea.value;
        }

        static extractMetaTags(html) {
            if (!html) return {};

            const metaTags = {};
            const regex = /<meta\s+(?:property|name)=["']([^"']+)["']\s+content=["']([^"']+)["']/gi;

            let match;
            while (match = regex.exec(html)) {
                if (match[1] && match[2]) {
                    metaTags[match[1]] = this.decodeHtmlEntities(match[2]);
                }
            }

            return metaTags;
        }

        /**
         * Safely set HTML content with CSP fallback
         * @param {HTMLElement} element - The element to set content on
         * @param {String} html - HTML content to set
         * @param {String} fallbackText - Text to use if HTML fails (optional)
         * @return {boolean} True if HTML was set successfully, false if fallback was used
         */
        static setHTMLSafely(element, html, fallbackText = null) {
            if (!element) return false;

            if (window.trustedTypes && window.trustedTypes.createPolicy) {
                if (!HTMLUtils.#policy) {
                    try {
                        HTMLUtils.#policy = window.trustedTypes.createPolicy('baturkacamak-userscripts-policy', {
                            createHTML: (input) => input,
                        });
                    } catch (e) {
                        // Policy likely already exists.
                        // We will fallback to innerHTML which will probably fail and be caught.
                        HTMLUtils.#policy = null;
                    }
                }
            }

            try {
                if (HTMLUtils.#policy) {
                    element.innerHTML = HTMLUtils.#policy.createHTML(html);
                } else {
                    element.innerHTML = html;
                }
                return true;
            } catch (error) {
                // Fallback to textContent if innerHTML fails due to CSP
                const fallback = fallbackText || html;
                element.textContent = fallback;
                return false;
            }
        }

        /**
         * Create an element with HTML content safely
         * @param {String} tagName - HTML tag name
         * @param {String} html - HTML content
         * @param {Object} attributes - Element attributes
         * @return {HTMLElement} The created element
         */
        static createElementWithHTML(tagName, html, attributes = {}) {
            const element = document.createElement(tagName);
            
            // Set attributes
            Object.keys(attributes).forEach(key => {
                element.setAttribute(key, attributes[key]);
            });
            
            // Set content safely
            this.setHTMLSafely(element, html);
            
            return element;
        }

        /**
         * Waits for an element to disappear from the DOM.
         * @param {string} selector - The CSS selector of the element.
         * @param {number} timeout - The maximum time to wait in milliseconds.
         * @param {number} interval - The interval between checks in milliseconds.
         * @returns {Promise<void>} A promise that resolves when the element is no longer found.
         */
        static waitForElementToDisappear(selector, timeout = 10000, interval = 1000) {
            return new Promise((resolve, reject) => {
                const startTime = Date.now();

                const check = () => {
                    if (!document.querySelector(selector)) {
                        clearInterval(intervalId);
                        resolve();
                    } else if (Date.now() - startTime > timeout) {
                        clearInterval(intervalId);
                        reject(new Error(`Element "${selector}" did not disappear within ${timeout}ms`));
                    }
                };

                const intervalId = setInterval(check, interval);
                check(); // Initial check
            });
        }

        /**
         * Find first visible element from array of selectors
         * Extends waitForElement() with visibility check
         * @param {string[]} selectors - Array of CSS selectors to try
         * @param {number} timeout - Timeout in milliseconds
         * @returns {Promise<Element|null>} First visible element found or null
         */
        static async findFirstVisibleElement(selectors, timeout = 5000) {
            try {
                const elements = await DOMObserver.waitForElements(selectors, timeout);
                for (const element of Array.from(elements)) {
                    if (element && element.offsetParent !== null) {
                        return element;
                    }
                }
            } catch (error) {
                // Fallback to direct querySelector
                for (const selector of selectors) {
                    const el = document.querySelector(selector);
                    if (el && el.offsetParent !== null) {
                        return el;
                    }
                }
            }
            return null;
        }

    }

    /**
     * MouseEventUtils - Utility for creating mouse events with fallbacks
     * Usage:
     *   const evt = MouseEventUtils.createClickEvent({bubbles: true, cancelable: true, programmatic: true});
     *   element.dispatchEvent(evt);
     */
    class MouseEventUtils {
        /**
         * Create a click MouseEvent with fallbacks for older browsers
         * @param {Object} options - MouseEventInit options + {programmatic: boolean}
         * @returns {MouseEvent}
         */
        static createClickEvent(options = {}) {
            const { programmatic, ...eventOptions } = options;
            let event;
            try {
                event = new MouseEvent('click', eventOptions);
            } catch (e) {
                // Fallback for older browsers
                event = document.createEvent('MouseEvents');
                event.initMouseEvent(
                    'click',
                    eventOptions.bubbles || false,
                    eventOptions.cancelable || false,
                    window,
                    eventOptions.detail || 1,
                    eventOptions.screenX || 0,
                    eventOptions.screenY || 0,
                    eventOptions.clientX || 0,
                    eventOptions.clientY || 0,
                    eventOptions.ctrlKey || false,
                    eventOptions.altKey || false,
                    eventOptions.shiftKey || false,
                    eventOptions.metaKey || false,
                    eventOptions.button || 0,
                    eventOptions.relatedTarget || null
                );
            }
            if (programmatic) {
                event._programmatic = true;
            }
            return event;
        }

        /**
         * Create a mouseenter MouseEvent with fallbacks for older browsers
         * @param {Object} options - MouseEventInit options + {programmatic: boolean}
         * @returns {MouseEvent}
         */
        static createMouseEnterEvent(options = {}) {
            const { programmatic, ...eventOptions } = options;
            // Remove 'view' property if present, as it can cause issues
            const { view, ...safeOptions } = eventOptions;
            let event;
            try {
                // Use document.defaultView instead of window for better compatibility
                event = new MouseEvent('mouseenter', {
                    ...safeOptions,
                    view: document.defaultView || window,
                    bubbles: safeOptions.bubbles !== undefined ? safeOptions.bubbles : true,
                    cancelable: safeOptions.cancelable !== undefined ? safeOptions.cancelable : true
                });
            } catch (e) {
                // Fallback for older browsers
                event = document.createEvent('MouseEvents');
                const view = document.defaultView || window;
                event.initMouseEvent(
                    'mouseenter',
                    safeOptions.bubbles !== undefined ? safeOptions.bubbles : true,
                    safeOptions.cancelable !== undefined ? safeOptions.cancelable : true,
                    view,
                    safeOptions.detail || 0,
                    safeOptions.screenX || 0,
                    safeOptions.screenY || 0,
                    safeOptions.clientX || 0,
                    safeOptions.clientY || 0,
                    safeOptions.ctrlKey || false,
                    safeOptions.altKey || false,
                    safeOptions.shiftKey || false,
                    safeOptions.metaKey || false,
                    safeOptions.button || 0,
                    safeOptions.relatedTarget || null
                );
            }
            if (programmatic) {
                event._programmatic = true;
            }
            return event;
        }
    }

    // Attach MouseEventUtils to HTMLUtils for easier access
    HTMLUtils.MouseEventUtils = MouseEventUtils;

    /**
     * StyleManager - Utility for CSS style management
     * Handles adding and removing styles, theme variables, etc.
     */
    class StyleManager {
        static styleElements = new Map();

        /**
         * Add CSS styles to the document
         * @param {string} css - CSS string to add
         * @param {string} id - Optional ID for the style element
         * @returns {HTMLStyleElement} - The created style element
         */
        static addStyles(css, id = null) {
            const style = document.createElement('style');
            style.textContent = css;

            if (id) {
                style.id = id;
                // Remove any existing style with the same ID
                if (this.styleElements.has(id)) {
                    this.removeStyles(id);
                }
                this.styleElements.set(id, style);
            }

            document.head.appendChild(style);
            return style;
        }

        /**
         * Remove styles by ID
         * @param {string} id - ID of the style element to remove
         * @returns {boolean} - True if styles were removed, false otherwise
         */
        static removeStyles(id) {
            if (!this.styleElements.has(id)) return false;

            const styleElement = this.styleElements.get(id);
            if (styleElement && styleElement.parentNode) {
                styleElement.parentNode.removeChild(styleElement);
            }

            this.styleElements.delete(id);
            return true;
        }

        /**
         * Check if styles with a given ID have already been added
         * @param {string} id - ID of the style element to check
         * @returns {boolean} - True if styles exist, false otherwise
         */
        static hasStyles(id) {
            return this.styleElements.has(id) || document.getElementById(id) !== null;
        }

        /**
         * Apply CSS variables for theming
         * @param {Object} variables - Object with variable names and values
         * @param {string} selector - CSS selector to apply variables to (default: :root)
         */
        static applyThemeVariables(variables, selector = ':root') {
            let css = `${selector} {\n`;

            Object.entries(variables).forEach(([name, value]) => {
                // Ensure variable names start with --
                const varName = name.startsWith('--') ? name : `--${name}`;
                css += `  ${varName}: ${value};\n`;
            });

            css += `}\n`;

            this.addStyles(css, 'theme-variables');
        }

        /**
         * Add styles to handle animations
         * @param {Object} animations - Key-value pairs of animation name and keyframes
         */
        static addAnimations(animations) {
            let css = '';

            Object.entries(animations).forEach(([name, keyframes]) => {
                css += `@keyframes ${name} {\n${keyframes}\n}\n\n`;
            });

            this.addStyles(css, 'animations');
        }
    }

    /**
     * Debouncer - A utility class for creating debounced and throttled functions
     *
     * Provides sophisticated debouncing and throttling with options for immediate/delayed
     * execution, cancellation, and flushing of pending operations.
     */
    class Debouncer {
      /**
         * Creates a debounced version of a function that delays invocation until after
         * a specified wait time has elapsed since the last time the debounced function was called.
         *
         * @param {Function} func - The function to debounce.
         * @param {number} wait - The number of milliseconds to delay.
         * @param {Object} [options] - The options object.
         * @param {boolean} [options.leading=false] - Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] - Specify invoking on the trailing edge of the timeout.
         * @return {Function} Returns the new debounced function.
         */
      static debounce(func, wait, options = {}) {
        const {leading = false, trailing = true} = options;
        let timeout;
        let lastArgs;
        let lastThis;
        let lastCallTime;
        let result;

        function invokeFunc() {
          const args = lastArgs;
          const thisArg = lastThis;

          lastArgs = lastThis = undefined;
          result = func.apply(thisArg, args);
          return result;
        }

        function startTimer(pendingFunc, wait) {
          return setTimeout(pendingFunc, wait);
        }

        function cancelTimer(id) {
          clearTimeout(id);
        }

        function trailingEdge() {
          timeout = undefined;

          // Only invoke if we have `lastArgs` which means `func` has been debounced at least once
          if (trailing && lastArgs) {
            return invokeFunc();
          }

          lastArgs = lastThis = undefined;
          return result;
        }

        function leadingEdge() {
          // Reset any `maxWait` timer
          timeout = startTimer(trailingEdge, wait);

          // Invoke the leading edge
          return leading ? invokeFunc() : result;
        }

        function cancel() {
          if (timeout !== undefined) {
            cancelTimer(timeout);
          }
          lastArgs = lastThis = lastCallTime = undefined;
          timeout = undefined;
        }

        function flush() {
          return timeout === undefined ? result : trailingEdge();
        }

        function debounced(...args) {
          const time = Date.now();
          const isInvoking = shouldInvoke(time);

          lastArgs = args;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timeout === undefined) {
              return leadingEdge();
            }
            if (isInvoking) {
              // Handle invocations in a tight loop
              timeout = startTimer(trailingEdge, wait);
              return invokeFunc();
            }
          }
          if (timeout === undefined) {
            timeout = startTimer(trailingEdge, wait);
          }
          return result;
        }

        function shouldInvoke(time) {
          const timeSinceLastCall = time - (lastCallTime || 0);

          // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit
          return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
                    (0 > timeSinceLastCall));
        }

        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      /**
         * Creates a throttled function that only invokes func at most once per
         * every wait milliseconds.
         *
         * @param {Function} func - The function to throttle.
         * @param {number} wait - The number of milliseconds to throttle invocations to.
         * @param {Object} [options] - The options object.
         * @param {boolean} [options.leading=true] - Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] - Specify invoking on the trailing edge of the timeout.
         * @return {Function} Returns the new throttled function.
         */
      static throttle(func, wait, options = {}) {
        return this.debounce(func, wait, {
          leading: false !== options.leading,
          trailing: false !== options.trailing,
        });
      }
    }

    /**
     * UserInteractionDetector - A utility class for detecting genuine user interactions
     *
     * Provides robust detection of user-initiated events vs programmatic ones
     * with multiple fallback mechanisms and integration with other utility classes.
     */

    class UserInteractionDetector {
      /**
         * Get a singleton instance - this allows sharing the detector across modules
         * @param {Object} [options] - Configuration options (only used for first initialization)
         * @return {UserInteractionDetector} Singleton instance
         * @static
         */
      static getInstance(options = {}) {
        if (!window.UserInteractionDetector) {
          window.UserInteractionDetector = {};
        }

        if (!window.UserInteractionDetector._instance) {
          window.UserInteractionDetector._instance = new UserInteractionDetector(options);
        }

        return window.UserInteractionDetector._instance;
      }
      /**
         * Create a new UserInteractionDetector
         * @param {Object} options - Configuration options
         * @param {number} [options.interactionWindow=150] - Time window in ms to consider events related to user interaction
         * @param {number} [options.interactionThrottle=50] - Minimum ms between interaction broadcasts
         * @param {boolean} [options.debug=false] - Enable debug logging
         * @param {string} [options.namespace='userscripts'] - Namespace for events
         * @param {boolean} [options.trackGlobalInteractions=true] - Whether to track interactions on document/window level
         * @param {boolean} [options.trackProgrammaticEvents=true] - Whether to track programmatic events like dispatchEvent
         */
      constructor(options = {}) {
        // Configuration
        this.interactionWindow = options.interactionWindow || 150; // Time window in ms
        this.interactionThrottle = options.interactionThrottle || 50; // Throttle in ms
        this.debug = options.debug || false;
        this.namespace = options.namespace || 'userscripts';
        this.trackGlobalInteractions = (false !== options.trackGlobalInteractions); // Default true
        this.trackProgrammaticEvents = (false !== options.trackProgrammaticEvents); // Default true

        // State tracking
        this._isInteracting = false;
        this._lastInteractionTime = 0;
        this._interactionTypes = new Set();
        this._lastEventTarget = null;
        this._lastEventType = null;
        this._interactionTimer = null;
        this._throttleTimer = null;
        this._overrideTimestamp = null;
        this._userInteractionCounter = 0;
        this._programmaticEventCounter = 0;
        this._patched = new Set();

        // Event tracking arrays
        this._recentEvents = [];
        this._trackedElements = new Map(); // element -> {events: [], handlers: []}

        // Initialize
        this._initTracking();

        // Log initialization
        if (this.debug) {
          Logger.debug('UserInteractionDetector initialized with options:', {
            interactionWindow: this.interactionWindow,
            interactionThrottle: this.interactionThrottle,
            namespace: this.namespace,
            trackGlobalInteractions: this.trackGlobalInteractions,
            trackProgrammaticEvents: this.trackProgrammaticEvents,
          });
        }
      }


      /**
         * Track a specific element for interaction events
         * You can use this for elements you want to specifically monitor
         * @param {HTMLElement} element - The element to track
         * @param {Array<string>} eventTypes - Event types to track
         * @param {Function} callback - Callback to invoke with interaction info
         * @return {Function} Unsubscribe function
         */
      trackElement(element, eventTypes = ['click', 'touchstart', 'keydown'], callback) {
        if (!element || !element.addEventListener) {
          this._logError('Invalid element provided to trackElement');
          return () => {
          }; // No-op unsubscribe
        }

        // Initialize tracking data for this element if needed
        if (!this._trackedElements.has(element)) {
          this._trackedElements.set(element, {
            events: [],
            handlers: [],
          });
        }

        const elementData = this._trackedElements.get(element);
        const handlers = [];

        // Create handler for each event type
        eventTypes.forEach((eventType) => {
          const handler = (e) => {
            const isUserInitiated = this.isUserEvent(e);
            const interactionData = {
              event: e,
              timestamp: Date.now(),
              isUserInitiated,
              globalInteracting: this._isInteracting,
              timeSinceLastInteraction: Date.now() - this._lastInteractionTime,
            };

            // Track this event
            elementData.events.unshift(interactionData);
            if (5 < elementData.events.length) {
              elementData.events.pop();
            }

            // Call the callback
            callback(interactionData);
          };

          // Attach the handler
          element.addEventListener(eventType, handler);
          handlers.push({eventType, handler});
          elementData.handlers.push({eventType, handler});
        });

        this._log(`Now tracking ${eventTypes.join(', ')} events on element:`, element);

        // Return unsubscribe function
        return () => {
          handlers.forEach(({eventType, handler}) => {
            element.removeEventListener(eventType, handler);

            // Remove from tracked handlers
            if (this._trackedElements.has(element)) {
              const data = this._trackedElements.get(element);
              data.handlers = data.handlers.filter((h) => h.handler !== handler);

              // Clean up if no more handlers
              if (0 === data.handlers.length) {
                this._trackedElements.delete(element);
              }
            }
          });

          this._log('Unsubscribed from element events');
        };
      }

      /**
         * Check if an event was initiated by a real user interaction
         * @param {Event} event - The event to check
         * @return {boolean} True if the event was likely initiated by a user
         */
      isUserEvent(event) {
        if (!event) return false;

        // Primary check: isTrusted property (most reliable)
        if (event.isTrusted) {
          return true;
        }

        // Secondary check: event occurred during known interaction window
        if (this._isInteracting) {
          const timeSinceInteraction = Date.now() - this._lastInteractionTime;
          if (timeSinceInteraction < this.interactionWindow) {
            this._log(`Event occurred ${timeSinceInteraction}ms after user interaction`);
            return true;
          }
        }

        // Tertiary check: was the event part of a trusted cascade?
        // (sometimes events trigger other events programmatically, but they're still part of user input)
        const cascadeWindow = 50; // ms to consider event cascades
        const recentTrustedEvents = this._recentEvents.filter((e) =>
          e.trusted && Date.now() - e.timestamp < cascadeWindow,
        );

        if (0 < recentTrustedEvents.length) {
          this._log(`Event may be part of trusted cascade (${recentTrustedEvents.length} recent trusted events)`);
          return true;
        }

        // Special check for specific event types that are always user-initiated
        const alwaysUserEvents = ['beforeinput', 'mousedown', 'touchstart', 'keydown'];
        if (alwaysUserEvents.includes(event.type) && !event._detectedByUserInteractionDetector) {
          this._log(`Event type ${event.type} is typically user-initiated`);
          return true;
        }

        return false;
      }

      /**
         * Check if an element's event was likely initiated by a real user
         * @param {HTMLElement} element - The element to check
         * @param {string} eventType - The type of event
         * @param {number} [timeWindow=500] - Time window to look back in ms
         * @return {boolean} True if there's evidence the user interacted with this element
         */
      didUserInteractWith(element, eventType, timeWindow = 500) {
        if (!element) return false;

        // First check if we're tracking this element
        if (this._trackedElements.has(element)) {
          const data = this._trackedElements.get(element);
          const recentEvents = data.events.filter((entry) =>
            entry.event.type === eventType &&
                    Date.now() - entry.timestamp < timeWindow &&
                    entry.isUserInitiated,
          );

          if (0 < recentEvents.length) {
            return true;
          }
        }

        // Fallback: check if this element was the last interaction target
        if (this._lastEventTarget === element &&
                this._lastEventType === eventType &&
                Date.now() - this._lastInteractionTime < timeWindow) {
          return true;
        }

        // Final fallback: check if element contains last interaction target
        if (this._lastEventTarget &&
                element.contains(this._lastEventTarget) &&
                Date.now() - this._lastInteractionTime < timeWindow) {
          return true;
        }

        return false;
      }

      /**
         * Check if the user is currently interacting with the page
         * @return {boolean} True if user interaction was detected within the interaction window
         */
      isInteracting() {
        return this._isInteracting;
      }

      /**
         * Get time (ms) since last user interaction
         * @return {number} Milliseconds since last interaction, or Infinity if no interaction yet
         */
      getTimeSinceLastInteraction() {
        if (0 === this._lastInteractionTime) return Infinity;
        return Date.now() - this._lastInteractionTime;
      }

      /**
         * Check if an interaction happened recently within the given time window
         * @param {number} withinMs - Time window in milliseconds
         * @return {boolean} True if interaction happened within the specified window
         */
      interactedWithin(withinMs) {
        return this.getTimeSinceLastInteraction() < withinMs;
      }
      /**
         * Get statistics about detected interactions
         * @return {Object} Interaction statistics
         */
      getStats() {
        return {
          isInteracting: this._isInteracting,
          lastInteractionTime: this._lastInteractionTime,
          timeSinceLastInteraction: this.getTimeSinceLastInteraction(),
          interactionTypes: Array.from(this._interactionTypes),
          userInteractionCount: this._userInteractionCounter,
          programmaticEventCount: this._programmaticEventCounter,
          trackedElements: this._trackedElements.size,
          recentEvents: this._recentEvents.length,
        };
      }
      /**
         * Reset all tracking state
         */
      reset() {
        this._resetInteractionState();
        this._lastInteractionTime = 0;
        this._userInteractionCounter = 0;
        this._programmaticEventCounter = 0;
        this._recentEvents = [];

        // Clear tracked elements
        this._trackedElements.forEach((data, element) => {
          data.handlers.forEach(({eventType, handler}) => {
            try {
              element.removeEventListener(eventType, handler);
            } catch (e) {
              // Element might be gone from DOM
            }
          });
        });
        this._trackedElements.clear();

        this._log('All tracking state reset');
      }
      /**
         * Clean up resources when detector is no longer needed
         */
      destroy() {
        this.reset();

        // Could unpatch event methods here, but it's generally safer
        // to leave them patched to avoid breaking other code

        this._log('Detector destroyed');
      }
      /**
         * Initialize event tracking
         * @private
         */
      _initTracking() {
        if (this.trackGlobalInteractions) {
          // Track global user interactions (capture phase to get them early)
          this._setupGlobalEventListeners();
        }

        if (this.trackProgrammaticEvents) {
          // Track programmatic events by patching EventTarget.prototype
          this._patchEventMethods();
        }
      }


      /**
         * Set up global event listeners to detect user interaction
         * @private
         */
      _setupGlobalEventListeners() {
        // Primary interaction events with capture to catch events early
        const interactionEvents = [
          'mousedown', 'mouseup', 'click', 'touchstart', 'touchend',
          'keydown', 'keyup', 'keypress', 'input', 'change', 'focus',
        ];

        const handleInteraction = this._handleGlobalInteraction.bind(this);

        interactionEvents.forEach((eventType) => {
          document.addEventListener(eventType, handleInteraction, {
            capture: true,
            passive: true, // For better performance
          });
        });

        // Special handling for scroll events (throttled)
        let scrollTimeout = null;
        const handleScroll = (e) => {
          if (!scrollTimeout) {
            scrollTimeout = setTimeout(() => {
              handleInteraction(e);
              scrollTimeout = null;
            }, 100); // Throttle scroll events
          }
        };

        window.addEventListener('scroll', handleScroll, {
          capture: true,
          passive: true,
        });

        // Track window focus/blur for tab switching context
        window.addEventListener('focus', () => {
          this._log('Window focused');
          this._overrideTimestamp = Date.now();
        });

        window.addEventListener('blur', () => {
          this._log('Window blurred - resetting interaction state');
          this._resetInteractionState();
        });

        this._log('Global event listeners registered');
      }


      /**
         * Handle a global interaction event
         * @param {Event} e - The event object
         * @private
         */
      _handleGlobalInteraction(e) {
        // Only process trusted events from the user
        if (!e.isTrusted) {
          this._log(`Ignoring untrusted event: ${e.type}`);
          return;
        }

        // Track this event in the recent events list
        this._trackEvent(e);

        // Update interaction state
        this._setInteracting(e);
      }


      /**
         * Reset interaction state
         * @private
         */
      _resetInteractionState() {
        this._isInteracting = false;
        this._interactionTypes.clear();
        this._lastEventTarget = null;
        this._lastEventType = null;
        clearTimeout(this._interactionTimer);
        this._interactionTimer = null;

        // Emit an event about interaction end
        PubSub.publish(`${this.namespace}:interaction:end`, {
          timestamp: Date.now(),
          duration: Date.now() - this._lastInteractionTime,
        });

        this._log('Interaction state reset');
      }


      /**
         * Set interaction state and schedule timeout
         * @param {Event} e - The triggering event
         * @private
         */
      _setInteracting(e) {
        const now = Date.now();
        const wasInteracting = this._isInteracting;

        // Update state
        this._isInteracting = true;
        this._lastInteractionTime = now;
        this._interactionTypes.add(e.type);
        this._lastEventTarget = e.target;
        this._lastEventType = e.type;
        this._userInteractionCounter++;

        // Clear any existing timeout and set a new one
        clearTimeout(this._interactionTimer);
        this._interactionTimer = setTimeout(() => {
          this._log(`Interaction window timeout after ${this.interactionWindow}ms`);
          this._resetInteractionState();
        }, this.interactionWindow);

        // Emit event (throttled)
        if (!wasInteracting || !this._throttleTimer) {
          if (this._throttleTimer) {
            clearTimeout(this._throttleTimer);
          }

          // Immediate first notification
          this._emitInteractionEvent(e);

          // Throttle subsequent notifications
          this._throttleTimer = setTimeout(() => {
            this._throttleTimer = null;
          }, this.interactionThrottle);
        }
      }


      /**
         * Emit interaction event via PubSub
         * @param {Event} e - The triggering event
         * @private
         */
      _emitInteractionEvent(e) {
        PubSub.publish(`${this.namespace}:interaction`, {
          timestamp: Date.now(),
          event: {
            type: e.type,
            target: e.target,
          },
          interactionTypes: Array.from(this._interactionTypes),
          interactionCount: this._userInteractionCounter,
        });

        this._log(`Emitted interaction event for ${e.type}`);
      }


      /**
         * Track an event in the recent events list
         * @param {Event} e - The event object
         * @private
         */
      _trackEvent(e) {
        const eventData = {
          type: e.type,
          timestamp: Date.now(),
          target: e.target,
          trusted: e.isTrusted,
        };

        // Add to recent events, keeping last 10
        this._recentEvents.unshift(eventData);
        if (10 < this._recentEvents.length) {
          this._recentEvents.pop();
        }
      }


      /**
         * Patch event methods to detect programmatic events
         * @private
         */
      _patchEventMethods() {
        // Don't patch twice
        if (this._patched.has('events')) return;

        // Save original methods
        const originalDispatchEvent = EventTarget.prototype.dispatchEvent;

        // Patch dispatchEvent
        EventTarget.prototype.dispatchEvent = function(event) {
          // Mark the event as detected by our utility
          event._detectedByUserInteractionDetector = true;

          // Track programmatic event
          if (window.UserInteractionDetector && window.UserInteractionDetector._instance) {
            window.UserInteractionDetector._instance._programmaticEventCounter++;

            window.UserInteractionDetector._instance._log(
                `Programmatic event detected: ${event.type} on ${this.tagName || 'EventTarget'}`,
            );
          }

          // Call original method
          return originalDispatchEvent.apply(this, arguments);
        };

        this._patched.add('events');
        this._log('Event methods patched to detect programmatic events');
      }


      /**
         * Private logging helper
         * @param {...any} args - Arguments to log
         * @private
         */
      _log(...args) {
        if (this.debug) {
          Logger.debug('[UserInteractionDetector]', ...args);
        }
      }

      /**
         * Private error logging helper
         * @param {...any} args - Arguments to log
         * @private
         */
      _logError(...args) {
        Logger.error('[UserInteractionDetector]', ...args);
      }
    }

    class BaseStrategy {
      constructor(callback) {
        this.callback = callback;
      }

      start() {
      }

      stop() {
      }
    }

    class PollingStrategy extends BaseStrategy {
      constructor(callback, interval = 500) {
        super(callback);
        this.interval = interval;
        this.lastUrl = location.href;
      }

      start() {
        Logger.debug('PollingStrategy started');
        this.timer = setInterval(() => {
          const current = location.href;
          if (current !== this.lastUrl) {
            Logger.debug(`Polling detected change: ${this.lastUrl} â†’ ${current}`);
            this.callback(current, this.lastUrl);
            this.lastUrl = current;
          }
        }, this.interval);
      }

      stop() {
        clearInterval(this.timer);
        Logger.debug('PollingStrategy stopped');
      }
    }

    /**
     * Notification - A reusable UI component for toast notifications.
     * Creates customizable, temporary notifications that appear and disappear automatically.
     */

    /**
     * A reusable UI component for creating toast notifications that provide non-intrusive
     * feedback to users.
     */
    class Notification {
        /**
         * Storage for the notification container elements by position
         * @private
         */
        static _containers = {};
        /**
         * Storage for all active notifications
         * @private
         */
        static _activeNotifications = [];
        /**
         * Counter for generating unique notification IDs
         * @private
         */
        static _idCounter = 0;
        /**
         * Maximum number of notifications to show per container
         * @private
         */
        static _maxNotificationsPerContainer = 5;
        /**
         * Queue for notifications waiting to be shown
         * @private
         */
        static _queue = [];

        /**
         * Returns the unique base CSS class for the Notification component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for notifications.
         */
        static get BASE_NOTIFICATION_CLASS() {
            return 'userscripts-notification';
        }

        /**
         * Returns the CSS variable prefix used for theming the Notification component.
         * This prefix scopes all custom CSS variables related to the notification.
         *
         * @return {string} The CSS variable prefix.
         */
        static get CSS_VAR_PREFIX() {
            return '--userscripts-notification-';
        }

        /**
         * Initialize styles for all notifications.
         * These styles reference the CSS variables with our defined prefix.
         */
        static initStyles() {
            if (Notification.stylesInitialized) return;

            StyleManager.addStyles(`
      /* Container for all notifications */
      .${Notification.BASE_NOTIFICATION_CLASS}-container {
        position: fixed;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 9999;
        pointer-events: none; /* Allow clicking through the container */
        
        /* Default positioning at bottom center */
        bottom: var(${Notification.CSS_VAR_PREFIX}container-bottom, 16px);
        left: 50%;
        transform: translateX(-50%);
        
        /* Container width */
        width: var(${Notification.CSS_VAR_PREFIX}container-width, auto);
        max-width: var(${Notification.CSS_VAR_PREFIX}container-max-width, 350px);
      }
      
      /* Position variants */
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-center {
        top: var(${Notification.CSS_VAR_PREFIX}container-top, 16px);
        bottom: auto;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-left {
        top: var(${Notification.CSS_VAR_PREFIX}container-top, 16px);
        left: var(${Notification.CSS_VAR_PREFIX}container-left, 16px);
        bottom: auto;
        transform: none;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-right {
        top: var(${Notification.CSS_VAR_PREFIX}container-top, 16px);
        right: var(${Notification.CSS_VAR_PREFIX}container-right, 16px);
        left: auto;
        bottom: auto;
        transform: none;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-left {
        bottom: var(${Notification.CSS_VAR_PREFIX}container-bottom, 16px);
        left: var(${Notification.CSS_VAR_PREFIX}container-left, 16px);
        transform: none;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-right {
        bottom: var(${Notification.CSS_VAR_PREFIX}container-bottom, 16px);
        right: var(${Notification.CSS_VAR_PREFIX}container-right, 16px);
        left: auto;
        transform: none;
      }
      
      /* Individual notification toast */
      .${Notification.BASE_NOTIFICATION_CLASS} {
        position: relative;
        display: flex;
        align-items: center;
        padding: var(${Notification.CSS_VAR_PREFIX}padding, 12px 16px);
        border-radius: var(${Notification.CSS_VAR_PREFIX}border-radius, 6px);
        box-shadow: var(${Notification.CSS_VAR_PREFIX}shadow, 0 4px 12px rgba(0, 0, 0, 0.15));
        color: var(${Notification.CSS_VAR_PREFIX}color, #fff);
        font-family: var(${Notification.CSS_VAR_PREFIX}font-family, inherit);
        font-size: var(${Notification.CSS_VAR_PREFIX}font-size, 14px);
        line-height: var(${Notification.CSS_VAR_PREFIX}line-height, 1.5);
        opacity: 0;
        transform: translateY(100%);
        transition: transform 0.3s ease, opacity 0.3s ease;
        pointer-events: auto; /* Make the notification clickable */
        max-width: 100%;
        box-sizing: border-box;
        width: 100%;
        overflow: hidden;
        
        /* Progress bar at the bottom */
        &::after {
          content: '';
          position: absolute;
          bottom: 0;
          left: 0;
          height: var(${Notification.CSS_VAR_PREFIX}progress-height, 3px);
          background-color: var(${Notification.CSS_VAR_PREFIX}progress-color, rgba(255, 255, 255, 0.5));
          width: 100%;
          transform-origin: left;
          transform: scaleX(0);
        }
      }
      
      /* Visible notification */
      .${Notification.BASE_NOTIFICATION_CLASS}--visible {
        opacity: 1;
        transform: translateY(0);
      }
      
      /* Animation for progress bar */
      .${Notification.BASE_NOTIFICATION_CLASS}--with-progress::after {
        animation-name: ${Notification.BASE_NOTIFICATION_CLASS}-progress;
        animation-timing-function: linear;
        animation-fill-mode: forwards;
      }
      
      @keyframes ${Notification.BASE_NOTIFICATION_CLASS}-progress {
        from { transform: scaleX(1); }
        to { transform: scaleX(0); }
      }
      
      /* Close button */
      .${Notification.BASE_NOTIFICATION_CLASS}-close {
        background: none;
        border: none;
        color: inherit;
        opacity: 0.7;
        font-size: 18px;
        cursor: pointer;
        padding: 4px;
        margin-left: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s ease;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-close:hover {
        opacity: 1;
      }
      
      /* Icon area */
      .${Notification.BASE_NOTIFICATION_CLASS}-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 12px;
      }
      
      /* Content area */
      .${Notification.BASE_NOTIFICATION_CLASS}-content {
        flex-grow: 1;
        word-break: break-word;
      }
      
      /* Types styling */
      .${Notification.BASE_NOTIFICATION_CLASS}--info {
        background-color: var(${Notification.CSS_VAR_PREFIX}info-bg, #3498db);
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}--success {
        background-color: var(${Notification.CSS_VAR_PREFIX}success-bg, #2ecc71);
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}--warning {
        background-color: var(${Notification.CSS_VAR_PREFIX}warning-bg, #f39c12);
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}--error {
        background-color: var(${Notification.CSS_VAR_PREFIX}error-bg, #e74c3c);
      }
      
      /* Customizable style */
      .${Notification.BASE_NOTIFICATION_CLASS}--custom {
        background-color: var(${Notification.CSS_VAR_PREFIX}custom-bg, #7f8c8d);
      }
      
      /* Animation for top position variants */
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-center .${Notification.BASE_NOTIFICATION_CLASS},
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-left .${Notification.BASE_NOTIFICATION_CLASS},
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-right .${Notification.BASE_NOTIFICATION_CLASS} {
        transform: translateY(-100%);
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-center .${Notification.BASE_NOTIFICATION_CLASS}--visible,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-left .${Notification.BASE_NOTIFICATION_CLASS}--visible,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-right .${Notification.BASE_NOTIFICATION_CLASS}--visible {
        transform: translateY(0);
      }
      
      /* Give slightly different vertical spacing based on position */
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-center,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-left,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-right {
        flex-direction: column;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-center,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-left,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-right {
        flex-direction: column-reverse;
      }
      
      /* For reduced motion preferences */
      @media (prefers-reduced-motion: reduce) {
        .${Notification.BASE_NOTIFICATION_CLASS} {
          transition: opacity 0.1s ease;
          transform: translateY(0);
        }
        
        .${Notification.BASE_NOTIFICATION_CLASS}--with-progress::after {
          animation: none;
        }
      }
    `, 'userscripts-notification-styles');

            Notification.stylesInitialized = true;
        }

        /**
         * Injects default color variables for the notification component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
        static useDefaultColors() {
            const styleId = 'userscripts-notification-default-colors';
            if (!document.getElementById(styleId)) {
                const style = document.createElement('style');
                style.id = styleId;
                HTMLUtils.setHTMLSafely(style, `
        :root {
          /* Container styling */
          ${Notification.CSS_VAR_PREFIX}container-width: auto;
          ${Notification.CSS_VAR_PREFIX}container-max-width: 350px;
          ${Notification.CSS_VAR_PREFIX}container-bottom: 16px;
          ${Notification.CSS_VAR_PREFIX}container-top: 16px;
          ${Notification.CSS_VAR_PREFIX}container-left: 16px;
          ${Notification.CSS_VAR_PREFIX}container-right: 16px;
          
          /* Toast styling */
          ${Notification.CSS_VAR_PREFIX}font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
          ${Notification.CSS_VAR_PREFIX}font-size: 14px;
          ${Notification.CSS_VAR_PREFIX}line-height: 1.5;
          ${Notification.CSS_VAR_PREFIX}padding: 12px 16px;
          ${Notification.CSS_VAR_PREFIX}border-radius: 6px;
          ${Notification.CSS_VAR_PREFIX}shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          ${Notification.CSS_VAR_PREFIX}color: #ffffff;
          
          /* Progress bar */
          ${Notification.CSS_VAR_PREFIX}progress-height: 3px;
          ${Notification.CSS_VAR_PREFIX}progress-color: rgba(255, 255, 255, 0.5);
          
          /* Toast types */
          ${Notification.CSS_VAR_PREFIX}info-bg: #3498db;
          ${Notification.CSS_VAR_PREFIX}success-bg: #2ecc71;
          ${Notification.CSS_VAR_PREFIX}warning-bg: #f39c12;
          ${Notification.CSS_VAR_PREFIX}error-bg: #e74c3c;
          ${Notification.CSS_VAR_PREFIX}custom-bg: #7f8c8d;
        }

        @media (prefers-color-scheme: dark) {
          :root {
            ${Notification.CSS_VAR_PREFIX}shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            ${Notification.CSS_VAR_PREFIX}color: #e0e0e0;
            
            /* Themed Backgrounds */
            ${Notification.CSS_VAR_PREFIX}info-bg: #3498db;
            ${Notification.CSS_VAR_PREFIX}success-bg: #2ecc71;
            ${Notification.CSS_VAR_PREFIX}warning-bg: #f39c12;
            ${Notification.CSS_VAR_PREFIX}error-bg: #e74c3c;
            ${Notification.CSS_VAR_PREFIX}custom-bg: #5f6c6d;
          }
        }
      `);
                document.head.appendChild(style);
            }
        }

        /**
         * Creates and shows a notification.
         * @param {Object|string} options - Configuration options or message string
         * @param {string} [options.message] - The notification message
         * @param {string} [options.type='info'] - Notification type (info, success, warning, error, custom)
         * @param {number} [options.duration=3000] - How long to show the notification (ms)
         * @param {string} [options.position='bottom-center'] - Position (top-left, top-center, top-middle, top-right, bottom-left, bottom-center, bottom-middle, bottom-right)
         * @param {boolean} [options.showProgress=true] - Show progress bar
         * @param {boolean} [options.showClose=true] - Show close button
         * @param {Function} [options.onClick] - Callback when notification is clicked
         * @param {Function} [options.onClose] - Callback when notification closes
         * @param {string} [options.icon] - HTML for icon to display
         * @param {string} [options.className] - Additional CSS class
         * @param {boolean} [options.html=false] - Whether to interpret message as HTML
         * @param {Object} [options.style] - Custom inline styles for the notification
         * @return {string} ID of the created notification (can be used to close it)
         */
        static show(options) {
            // Initialize styles if not already done
            this.initStyles();

            // Allow passing just a message string
            if (typeof options === 'string') {
                options = {message: options};
            }

            // Set defaults
            const config = {
                message: '',
                type: 'info',
                duration: 3000,
                position: 'bottom-center',
                showProgress: true,
                showClose: true,
                onClick: null,
                onClose: null,
                icon: null,
                className: '',
                html: false,
                style: null,
                ...options
            };

            // Generate a unique ID for this notification
            const id = `${Notification.BASE_NOTIFICATION_CLASS}-${++this._idCounter}`;

            // Check if we're at the limit for the specified position
            const positionString = this._normalizePosition(config.position);
            const activeInPosition = this._activeNotifications.filter(n => n.position === positionString).length;

            // If we're at the limit, queue this notification
            if (activeInPosition >= this._maxNotificationsPerContainer) {
                this._queue.push({id, ...config});
                return id;
            }

            // Create and show the notification
            this._createNotification(id, config);
            return id;
        }

        /**
         * Convenience method to show an info notification
         * @param {string} message - The message to display
         * @param {Object} [options] - Additional options
         * @return {string} Notification ID
         */
        static info(message, options = {}) {
            return this.show({...options, message, type: 'info'});
        }

        /**
         * Convenience method to show a success notification
         * @param {string} message - The message to display
         * @param {Object} [options] - Additional options
         * @return {string} Notification ID
         */
        static success(message, options = {}) {
            return this.show({...options, message, type: 'success'});
        }

        /**
         * Convenience method to show a warning notification
         * @param {string} message - The message to display
         * @param {Object} [options] - Additional options
         * @return {string} Notification ID
         */
        static warning(message, options = {}) {
            return this.show({...options, message, type: 'warning'});
        }

        /**
         * Convenience method to show an error notification
         * @param {string} message - The message to display
         * @param {Object} [options] - Additional options
         * @return {string} Notification ID
         */
        static error(message, options = {}) {
            return this.show({...options, message, type: 'error'});
        }

        /**
         * Close a notification by ID
         * @param {string} id - The notification ID
         * @param {boolean} [animate=true] - Whether to animate the closing
         */
        static close(id, animate = true) {
            const element = document.getElementById(id);
            if (!element) {
                // Check if it's in the queue
                const queueIndex = this._queue.findIndex(n => n.id === id);
                if (queueIndex !== -1) {
                    this._queue.splice(queueIndex, 1);
                }
                return;
            }

            // Get the notification object
            const notificationIndex = this._activeNotifications.findIndex(n => n.id === id);
            if (notificationIndex === -1) return;

            const notification = this._activeNotifications[notificationIndex];

            // Remove from active notifications
            this._activeNotifications.splice(notificationIndex, 1);

            // If animated, fade out then remove
            if (animate) {
                element.classList.remove(`${Notification.BASE_NOTIFICATION_CLASS}--visible`);
                setTimeout(() => {
                    this._removeNotificationElement(element, notification);
                }, 300); // Match the transition time in CSS
            } else {
                this._removeNotificationElement(element, notification);
            }

            // Process the queue after removing
            this._processQueue(notification.position);
        }

        /**
         * Close all notifications
         * @param {string} [position] - Only close notifications in this position
         * @param {boolean} [animate=true] - Whether to animate the closing
         */
        static closeAll(position = null, animate = true) {
            // Clear the queue
            if (position) {
                const normalizedPosition = this._normalizePosition(position);
                this._queue = this._queue.filter(n => this._normalizePosition(n.position) !== normalizedPosition);
            } else {
                this._queue = [];
            }

            // Close active notifications
            const notificationsToClose = position
                ? this._activeNotifications.filter(n => n.position === this._normalizePosition(position))
                : [...this._activeNotifications];

            notificationsToClose.forEach(notification => {
                this.close(notification.id, animate);
            });
        }

        /**
         * Set the maximum number of notifications to show per container
         * @param {number} max - Maximum number of notifications
         */
        static setMaxNotifications(max) {
            if (typeof max === 'number' && max > 0) {
                this._maxNotificationsPerContainer = max;
            }
        }

        /**
         * Get a container element for a specific position, creating it if it doesn't exist
         * @param {string} position - The notification position
         * @return {HTMLElement} The container element
         * @private
         */
        static _getContainer(position) {
            const positionString = this._normalizePosition(position);

            if (this._containers[positionString]) {
                return this._containers[positionString];
            }

            // Create new container
            const container = document.createElement('div');
            container.className = `${Notification.BASE_NOTIFICATION_CLASS}-container ${Notification.BASE_NOTIFICATION_CLASS}-container--${positionString}`;
            document.body.appendChild(container);

            // Store for future use
            this._containers[positionString] = container;
            return container;
        }

        /**
         * Normalize position string to one of the supported values
         * @param {string} position - Position string
         * @return {string} Normalized position string
         * @private
         */
        static _normalizePosition(position) {
            const validPositions = [
                'top-center', 'top-left', 'top-right',
                'bottom-center', 'bottom-left', 'bottom-right'
            ];

            if (validPositions.includes(position)) {
                return position;
            }

            // Handle abbreviated positions
            if (position === 'top') return 'top-center';
            if (position === 'bottom') return 'bottom-center';
            
            // Handle alternative naming
            if (position === 'top-middle') return 'top-center';
            if (position === 'bottom-middle') return 'bottom-center';

            // Default
            return 'bottom-center';
        }

        /**
         * Create and show a notification
         * @param {string} id - The notification ID
         * @param {Object} config - Notification configuration
         * @private
         */
        static _createNotification(id, config) {
            const position = this._normalizePosition(config.position);
            const container = this._getContainer(position);

            // Create the notification element
            const element = document.createElement('div');
            element.id = id;
            element.className = `${Notification.BASE_NOTIFICATION_CLASS} ${Notification.BASE_NOTIFICATION_CLASS}--${config.type}`;

            if (config.showProgress && config.duration > 0) {
                element.classList.add(`${Notification.BASE_NOTIFICATION_CLASS}--with-progress`);
                // Set the animation duration for the progress bar
                element.style.setProperty('--progress-duration', `${config.duration}ms`);
            }

            if (config.className) {
                element.classList.add(config.className);
            }

            // Apply custom styles
            if (config.style && typeof config.style === 'object') {
                Object.assign(element.style, config.style);
            }

            // Create content structure using DOM methods instead of innerHTML
            
            // Add icon if provided
            if (config.icon) {
                const iconDiv = document.createElement('div');
                iconDiv.className = `${Notification.BASE_NOTIFICATION_CLASS}-icon`;
                HTMLUtils.setHTMLSafely(iconDiv, config.icon);
                element.appendChild(iconDiv);
            }

            // Add message content
            const contentDiv = document.createElement('div');
            contentDiv.className = `${Notification.BASE_NOTIFICATION_CLASS}-content`;
            HTMLUtils.setHTMLSafely(contentDiv, config.message);
            element.appendChild(contentDiv);

            // Add close button if needed
            if (config.showClose) {
                const closeButton = document.createElement('button');
                closeButton.className = `${Notification.BASE_NOTIFICATION_CLASS}-close`;
                closeButton.setAttribute('aria-label', 'Close notification');
                HTMLUtils.setHTMLSafely(closeButton, 'Ã—');
                element.appendChild(closeButton);
            }

            // Set up animations
            requestAnimationFrame(() => {
                container.appendChild(element);

                // Trigger layout/reflow before adding the visible class
                void element.offsetWidth;

                // Make visible
                element.classList.add(`${Notification.BASE_NOTIFICATION_CLASS}--visible`);

                // Set animation for progress bar if applicable
                const progressBar = element.querySelector(`.${Notification.BASE_NOTIFICATION_CLASS}--with-progress::after`);
                if (progressBar) {
                    progressBar.style.animationDuration = `${config.duration}ms`;
                }
            });

            // Add to active notifications
            this._activeNotifications.push({
                id,
                element,
                position,
                config
            });

            // Set up click handler
            if (config.onClick) {
                element.addEventListener('click', event => {
                    // Only trigger if not clicking the close button
                    if (!event.target.closest(`.${Notification.BASE_NOTIFICATION_CLASS}-close`)) {
                        config.onClick(event, id);
                    }
                });
            }

            // Set up close button handler
            const closeButton = element.querySelector(`.${Notification.BASE_NOTIFICATION_CLASS}-close`);
            if (closeButton) {
                closeButton.addEventListener('click', () => this.close(id, true));
            }

            // Set auto-close timeout if duration > 0
            if (config.duration > 0) {
                setTimeout(() => {
                    // Check if notification still exists before closing
                    if (document.getElementById(id)) {
                        this.close(id, true);
                    }
                }, config.duration);
            }
        }

        /**
         * Remove a notification element from the DOM
         * @param {HTMLElement} element - The notification element
         * @param {Object} notification - The notification object
         * @private
         */
        static _removeNotificationElement(element, notification) {
            if (!element) return;

            // Call onClose callback if provided
            if (notification && notification.config && notification.config.onClose) {
                try {
                    notification.config.onClose(notification.id);
                } catch (e) {
                    Logger.error(e, 'Error in notification onClose callback');
                }
            }

            // Remove the element
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }

            // Check if container is empty and remove it if so
            const container = this._containers[notification.position];
            if (container && !container.hasChildNodes()) {
                if (container.parentNode) {
                    container.parentNode.removeChild(container);
                }
                delete this._containers[notification.position];
            }
        }

        /**
         * Process the notification queue for a specific position
         * @param {string} position - Position to process
         * @private
         */
        static _processQueue(position) {
            const normalizedPosition = this._normalizePosition(position);

            // Check how many active notifications we have in this position
            const activeCount = this._activeNotifications.filter(n => n.position === normalizedPosition).length;

            // Check if we can show more
            if (activeCount >= this._maxNotificationsPerContainer) return;

            // Find the first queued notification for this position
            const queueIndex = this._queue.findIndex(n =>
                this._normalizePosition(n.position) === normalizedPosition
            );

            if (queueIndex !== -1) {
                // Remove from queue and show
                const nextNotification = this._queue.splice(queueIndex, 1)[0];
                this._createNotification(nextNotification.id, nextNotification);
            }
        }
    }

    // Static property to track if styles have been initialized
    Notification.stylesInitialized = false;

    /**
     * GMFunctions - Provides fallback implementations for Greasemonkey/Tampermonkey functions
     * Ensures compatibility across different userscript managers and direct browser execution
     */

    class GMFunctions {
        /**
         * Check if we're running in development mode (outside a userscript manager)
         * @return {boolean} True if in development environment
         */
        static isDevelopmentMode() {
            // In production, GM_info should be defined by the userscript manager
            return 'undefined' === typeof GM_info;
        }

        /**
         * Initialize fallbacks for missing GM functions
         * @return {Object} Object containing references to all GM functions (either native or polyfilled)
         */
        static initialize() {

            if (window.top !== window.self) {
                return {};
            }

            const isDevMode = this.isDevelopmentMode();

            Logger.debug('GMFunctions initializing', isDevMode ? 'in development mode' : 'in production mode');

            if (isDevMode) {
                // Create fallbacks for common GM functions
                this.setupAddStyle();
                this.setupXmlHttpRequest();
                this.setupSetClipboard();
                this.setupDownload();
                this.setupGetValue();
                this.setupSetValue();

                Logger.info('GM function fallbacks have been created for development mode');
            } else {
                Logger.debug('Using native userscript manager GM functions');
            }

            // Return references to all functions (either native or polyfilled)
            return {
                GM_addStyle: window.GM_addStyle,
                GM_xmlhttpRequest: window.GM_xmlhttpRequest,
                GM_setClipboard: window.GM_setClipboard,
                GM_download: window.GM_download,
                GM_getValue: window.GM_getValue,
                GM_setValue: window.GM_setValue,
            };
        }

        /**
         * Set up GM_addStyle fallback
         */
        static setupAddStyle() {
            window.GM_addStyle = function (css) {
                Logger.debug('GM_addStyle fallback executing', css.substring(0, 50) + '...');
                const style = document.createElement('style');
                style.textContent = css;
                document.head.appendChild(style);
                return style;
            };
        }

        /**
         * Set up GM_xmlhttpRequest fallback
         */
        static setupXmlHttpRequest() {
            window.GM_xmlhttpRequest = function (details) {
                Logger.debug('GM_xmlhttpRequest fallback executing', {
                    method: details.method,
                    url: details.url
                });

                const xhr = new XMLHttpRequest();
                xhr.open(details.method, details.url);

                if (details.headers) {
                    Object.keys(details.headers).forEach((key) => {
                        xhr.setRequestHeader(key, details.headers[key]);
                    });
                }

                xhr.onload = function () {
                    if (details.onload) {
                        const response = {
                            responseText: xhr.responseText,
                            response: xhr.response,
                            status: xhr.status,
                            statusText: xhr.statusText,
                            readyState: xhr.readyState,
                        };

                        Logger.debug('GM_xmlhttpRequest completed', {
                            status: xhr.status,
                            url: details.url
                        });

                        details.onload(response);
                    }
                };

                xhr.onerror = function () {
                    Logger.error('GM_xmlhttpRequest error', {
                        url: details.url,
                        status: xhr.status
                    });

                    if (details.onerror) {
                        details.onerror(xhr);
                    }
                };

                xhr.send(details.data);
                return xhr;
            };
        }

        /**
         * Set up GM_setClipboard fallback
         */
        static setupSetClipboard() {
            window.GM_setClipboard = function (text) {
                Logger.debug('GM_setClipboard fallback executing', {
                    textLength: text.length
                });

                // Create a temporary textarea element
                const textarea = document.createElement('textarea');
                textarea.value = text;

                // Make the textarea not visible
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';

                document.body.appendChild(textarea);
                textarea.select();

                // Try to copy the text
                let success = false;
                try {
                    success = document.execCommand('copy');
                    Logger.info('Clipboard copy ' + (success ? 'successful' : 'unsuccessful'));
                } catch (err) {
                    Logger.error(err, 'Error copying to clipboard');
                }

                // Clean up
                document.body.removeChild(textarea);
                return success;
            };
        }

        /**
         * Set up GM_download fallback
         */
        static setupDownload() {
            window.GM_download = function (options) {
                // Wrapping in a Promise to allow for async-like behavior if needed by caller,
                // though current implementation is synchronous.
                return new Promise((resolve, reject) => {
                    try {
                        const {url, name, onload, onerror} = options;

                        Logger.debug('GM_download fallback executing', {
                            url: url.substring(0, 100),
                            filename: name
                        });

                        // Create download link
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = name || 'download';
                        downloadLink.style.display = 'none';

                        // Add to document, click, and remove
                        document.body.appendChild(downloadLink);
                        downloadLink.click();

                        // Clean up
                        setTimeout(() => {
                            document.body.removeChild(downloadLink);
                            if (onload) {
                                Logger.debug('GM_download completed successfully');
                                onload();
                            }
                            resolve(true); // Resolve promise on success
                        }, 100);

                    } catch (err) {
                        Logger.error(err, 'Error downloading file');
                        if (options.onerror) options.onerror(err);
                        reject(err); // Reject promise on error
                    }
                });
            };
        }

        /**
         * Set up GM_getValue fallback using localStorage, returning a Promise.
         */
        static setupGetValue() {
            window.GM_getValue = function (key, defaultValue) {
                return new Promise((resolve) => {
                    try {
                        const storageKey = `GM_${key}`;
                        Logger.debug('GM_getValue fallback: Attempting to get \'' + storageKey + '\'');
                        const value = localStorage.getItem(storageKey);
                        if (value !== null) {
                            try {
                                const parsedValue = JSON.parse(value);
                                Logger.debug('GM_getValue fallback: Found and parsed \'' + storageKey + '\', value:', parsedValue);
                                resolve(parsedValue);
                            } catch (e) {
                                Logger.debug('GM_getValue fallback: Found non-JSON \'' + storageKey + '\', value:', value);
                                resolve(value); // Return as string if not JSON
                            }
                        } else {
                            Logger.debug('GM_getValue fallback: Key \'' + storageKey + '\' not found, returning default:', defaultValue);
                            resolve(defaultValue);
                        }
                    } catch (error) {
                        Logger.error(error, 'Error getting value for key (GM_getValue fallback): ' + key);
                        resolve(defaultValue);
                    }
                });
            };
        }

        /**
         * Set up GM_setValue fallback using localStorage, returning a Promise.
         */
        static setupSetValue() {
            window.GM_setValue = function (key, value) {
                return new Promise((resolve, reject) => {
                    try {
                        const storageKey = `GM_${key}`;
                        Logger.debug('GM_setValue fallback: Attempting to set \'' + storageKey + '\' to:', value);
                        localStorage.setItem(storageKey, JSON.stringify(value));
                        resolve();
                    } catch (error) {
                        Logger.error(error, 'Error setting value for key (GM_setValue fallback): ' + key);
                        reject(error);
                    }
                });
            };
        }
    }

    // Initialize the fallbacks (this will populate window.GM_getValue etc.)
    // The initialize method also returns the map of functions.
    const gmFunctions = GMFunctions.initialize();

    // Export the functions for direct import, matching the names used in CountryFilter.js
    gmFunctions.GM_addStyle;
    gmFunctions.GM_xmlhttpRequest;
    const GM_setClipboard = gmFunctions.GM_setClipboard;
    gmFunctions.GM_download;
    const getValue = gmFunctions.GM_getValue; // Maps to getValue for import { getValue }
    const setValue = gmFunctions.GM_setValue; // Maps to setValue for import { setValue }

    // For potential direct class usage if ever needed, though current pattern is to use the initialized functions.
    // export default GMFunctions; // Not currently used this way

    class ClipboardService {
        constructor() {
            this.logger = Logger.newPrefix('ClipboardService');
        }

        /**
         * Copy to clipboard with fallbacks
         * @param {string} content - The content to copy
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */
        async copyToClipboard(content) {
            if (!content) {
                this.logger.warn('No content to copy');
                return false;
            }

            this.logger.debug(`Attempting to copy ${content.length} characters to clipboard`);

            try {
                if (typeof GM_setClipboard !== 'undefined') {
                    GM_setClipboard(content);
                    this.logger.debug('âœ… GM_setClipboard succeeded');
                    return true;
                }
            } catch (error) {
                this.logger.warn('âš  GM_setClipboard failed:', error);
            }

            try {
                await navigator.clipboard.writeText(content);
                this.logger.debug('âœ… Clipboard API succeeded');
                return true;
            } catch (error) {
                this.logger.warn('âš  Clipboard API failed:', error);
            }

            const textarea = document.createElement('textarea');
            textarea.value = content;
            Object.assign(textarea.style, {
                position: 'fixed',
                top: '-9999px',
                left: '-9999px',
                opacity: '0',
                pointerEvents: 'none'
            });

            document.body.appendChild(textarea);

            try {
                textarea.select();
                textarea.setSelectionRange(0, content.length);
                const success = document.execCommand('copy');

                if (success) {
                    document.body.removeChild(textarea);
                    this.logger.debug('âœ… execCommand succeeded');
                    return true;
                }
            } catch (error) {
                this.logger.warn('âš  execCommand failed:', error);
            }

            try {
                this.logger.debug('Trying designMode hack...');
                document.designMode = 'on';

                const selection = window.getSelection();
                selection.removeAllRanges();

                const range = document.createRange();
                range.selectNodeContents(textarea);
                selection.addRange(range);

                const success = document.execCommand('copy');

                document.designMode = 'off';
                selection.removeAllRanges();

                if (success) {
                    document.body.removeChild(textarea);
                    this.logger.debug('âœ… designMode hack succeeded');
                    return true;
                }
            } catch (error) {
                this.logger.warn('âš  designMode hack failed:', error);
                document.designMode = 'off';
            }

            try {
                this.logger.warn('All automatic copy methods failed. Showing manual copy prompt...');
                window.prompt('All automatic copy methods failed. Please copy manually:', content);
                this.logger.debug('Manual copy prompt shown');
                return false;
            } catch (error) {
                this.logger.error('Even manual copy prompt failed:', error);
            } finally {
                if (textarea.parentNode) {
                    document.body.removeChild(textarea);
                }
            }

            return false;
        }
    }

    new ClipboardService();

    /**
     * SelectBox - A rich UI component for dropdown selects.
     * Creates customizable, accessible dropdown selects with categories and configurable options.
     */

    class SelectBox {
        /**
         * Create a new select box.
         * @param {Object} options - Configuration options.
         * @param {Array} options.items - Array of items or item categories.
         * @param {string} options.name - Name attribute for the select element.
         * @param {string} options.id - ID attribute for the select element.
         * @param {Function} options.onChange - Callback when selection changes.
         * @param {string} options.placeholder - Placeholder text when no selection.
         * @param {HTMLElement} options.container - Optional container to append the select box.
         * @param {Object} options.attributes - Additional HTML attributes for the select element.
         * @param {string} options.theme - Theme name (default, primary, etc.).
         * @param {string} options.size - Size name (small, medium, large).
         * @param {boolean} options.useCategorizedUI - Whether to use the rich category UI (default: false).
         */
        constructor(options) {
            this.items = options.items || [];
            this.name = options.name || '';
            this.id = options.id || SelectBox.generateUniqueId();
            this.onChange = options.onChange;
            this.placeholder = options.placeholder || 'Select an option';
            this.container = options.container;
            this.attributes = options.attributes || {};
            this.theme = options.theme || 'default';
            this.size = options.size || 'medium';
            this.useCategorizedUI = options.useCategorizedUI || false;
            this.label = options.label || '';
            this.required = options.required || false;
            this.labelPosition = options.labelPosition || 'top'; // 'top' or 'inline'

            // Store instance ID for events
            this.instanceId = this.id;

            // Detect if items are categorized or flat
            this.isCategorized = this.detectCategorizedItems();

            // DOM elements
            this.element = null; // Main wrapper element (contains label + containerElement)
            this.labelElement = null; // Label element
            this.containerElement = null; // Select container element
            this.selectElement = null; // Native select element (hidden)
            this.triggerElement = null; // Button to open dropdown
            this.dropdownElement = null; // Custom dropdown
            this.selectedValue = ''; // Current selected value
            this.selectedLabel = ''; // Current selected label

            // Ensure styles are initialized
            SelectBox.initStyles();

            // Create the select component
            this.create();
        }

        /**
         * Returns the unique base CSS class for the SelectBox component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for select boxes.
         */
        static get BASE_SELECT_CLASS() {
            return 'userscripts-select';
        }

        /**
         * Returns the CSS variable prefix used for theming the SelectBox component.
         * This prefix scopes all custom CSS variables (e.g., colors, borders) related to the select box.
         *
         * @return {string} The CSS variable prefix.
         */
        static get CSS_VAR_PREFIX() {
            return '--userscripts-select-';
        }

        /**
         * Initialize styles for all select boxes.
         * These styles reference CSS variables using our defined prefix.
         */
        static initStyles() {
            if (SelectBox.stylesInitialized) return;

            StyleManager.addStyles(`
      /* Main wrapper element */
      .${SelectBox.BASE_SELECT_CLASS}-wrapper {
        width: 100%;
      }
      
      /* Label styles */
      .${SelectBox.BASE_SELECT_CLASS}-label {
        display: block;
        margin-bottom: 4px;
        font-size: 12px;
        font-weight: 500;
        color: #555;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-label--inline {
        display: inline-block;
        margin-bottom: 0;
        margin-right: 0;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-wrapper--inline {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      /* Base container styles */
      .${SelectBox.BASE_SELECT_CLASS}-container {
        position: relative;
        width: 100%;
      }
      
      /* Select trigger button */
      .${SelectBox.BASE_SELECT_CLASS}-trigger {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        padding: 0.5rem 0.75rem;
        background-color: var(${SelectBox.CSS_VAR_PREFIX}bg, #ffffff);
        border: 1px solid var(${SelectBox.CSS_VAR_PREFIX}border, #d1d5db);
        border-radius: 0.375rem;
        font-family: inherit;
        font-size: 0.875rem;
        color: var(${SelectBox.CSS_VAR_PREFIX}color, #374151);
        cursor: pointer;
        text-align: left;
        transition: all 0.2s ease;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-trigger:hover {
        border-color: var(${SelectBox.CSS_VAR_PREFIX}border-hover, #9ca3af);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-trigger:focus {
        outline: none;
        border-color: var(${SelectBox.CSS_VAR_PREFIX}focus-border, #3b82f6);
        box-shadow: 0 0 0 3px var(${SelectBox.CSS_VAR_PREFIX}focus-shadow, rgba(59, 130, 246, 0.25));
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-trigger-icon {
        margin-left: 0.5rem;
        transition: transform 0.2s ease;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-trigger-icon.open {
        transform: rotate(180deg);
      }
      
      /* Dropdown styles */
      .${SelectBox.BASE_SELECT_CLASS}-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        z-index: 10;
        width: 100%;
        max-height: 0;
        overflow: hidden;
        background-color: var(${SelectBox.CSS_VAR_PREFIX}dropdown-bg, #ffffff);
        border-radius: 0.375rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        transition: max-height 0.2s ease, opacity 0.2s ease, transform 0.2s ease;
        opacity: 0;
        transform: translateY(-10px);
        margin-top: 0.25rem;
        border: 1px solid var(${SelectBox.CSS_VAR_PREFIX}border, #d1d5db);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-dropdown.open {
        max-height: 300px;
        opacity: 1;
        transform: translateY(0);
        overflow-y: auto;
        z-index: 100;
      }
      
      /* Categories */
      .${SelectBox.BASE_SELECT_CLASS}-category {
        border-bottom: 1px solid var(${SelectBox.CSS_VAR_PREFIX}category-border, #e5e7eb);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-category:last-child {
        border-bottom: none;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-category-label {
        padding: 0.5rem 0.75rem;
        font-size: 0.75rem;
        font-weight: 600;
        color: var(${SelectBox.CSS_VAR_PREFIX}category-color, #6b7280);
        text-transform: uppercase;
        background-color: var(${SelectBox.CSS_VAR_PREFIX}category-bg, #f9fafb);
      }
      
      /* Items */
      .${SelectBox.BASE_SELECT_CLASS}-items {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-item {
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
        color: var(${SelectBox.CSS_VAR_PREFIX}item-color, #374151);
        cursor: pointer;
        transition: background-color 0.1s ease;
        position: relative;
        display: flex;
        align-items: center;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-item:hover {
        background-color: var(${SelectBox.CSS_VAR_PREFIX}item-hover-bg, #f3f4f6);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-item.selected {
        background-color: var(${SelectBox.CSS_VAR_PREFIX}selected-bg, #EFF6FF);
        color: var(${SelectBox.CSS_VAR_PREFIX}selected-color, #2563EB);
        font-weight: 500;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-item.selected::before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 3px;
        background-color: var(${SelectBox.CSS_VAR_PREFIX}selected-indicator, #2563EB);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-item.disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      /* Item options */
      .${SelectBox.BASE_SELECT_CLASS}-item-options {
        padding: 0.25rem 0.75rem 0.5rem 1.75rem;
        background-color: var(${SelectBox.CSS_VAR_PREFIX}options-bg, #f9fafb);
        font-size: 0.8125rem;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transition: max-height 0.2s ease, opacity 0.2s ease, padding 0.2s ease;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-item-options.open {
        max-height: 200px;
        opacity: 1;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-option-row {
        display: flex;
        align-items: center;
        margin: 0.25rem 0;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-option-checkbox {
        margin-right: 0.5rem;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-option-label {
        color: var(${SelectBox.CSS_VAR_PREFIX}option-label-color, #4b5563);
      }
      
      /* Icon for options toggle */
      .${SelectBox.BASE_SELECT_CLASS}-option-toggle {
        margin-left: auto;
        padding: 0.25rem;
        background: none;
        border: none;
        cursor: pointer;
        color: var(${SelectBox.CSS_VAR_PREFIX}option-toggle-color, #6b7280);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-option-toggle:hover {
        color: var(${SelectBox.CSS_VAR_PREFIX}option-toggle-hover-color, #374151);
      }
      
      /* Size variations */
      .${SelectBox.BASE_SELECT_CLASS}-container--small .${SelectBox.BASE_SELECT_CLASS}-trigger {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-container--large .${SelectBox.BASE_SELECT_CLASS}-trigger {
        padding: 0.75rem 1rem;
        font-size: 1rem;
      }
      
      /* Theme variations */
      .${SelectBox.BASE_SELECT_CLASS}-container--primary .${SelectBox.BASE_SELECT_CLASS}-trigger {
        border-color: var(${SelectBox.CSS_VAR_PREFIX}primary-border, #3b82f6);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-container--primary .${SelectBox.BASE_SELECT_CLASS}-item.selected {
        background-color: var(${SelectBox.CSS_VAR_PREFIX}primary-selected-bg, #EFF6FF);
        color: var(${SelectBox.CSS_VAR_PREFIX}primary-selected-color, #2563EB);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-container--primary .${SelectBox.BASE_SELECT_CLASS}-item.selected::before {
        background-color: var(${SelectBox.CSS_VAR_PREFIX}primary-indicator, #2563EB);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-container--success .${SelectBox.BASE_SELECT_CLASS}-trigger {
        border-color: var(${SelectBox.CSS_VAR_PREFIX}success-border, #10b981);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-container--success .${SelectBox.BASE_SELECT_CLASS}-item.selected {
        background-color: var(${SelectBox.CSS_VAR_PREFIX}success-selected-bg, #ECFDF5);
        color: var(${SelectBox.CSS_VAR_PREFIX}success-selected-color, #059669);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-container--success .${SelectBox.BASE_SELECT_CLASS}-item.selected::before {
        background-color: var(${SelectBox.CSS_VAR_PREFIX}success-indicator, #10b981);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-container--danger .${SelectBox.BASE_SELECT_CLASS}-trigger {
        border-color: var(${SelectBox.CSS_VAR_PREFIX}danger-border, #ef4444);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-container--danger .${SelectBox.BASE_SELECT_CLASS}-item.selected {
        background-color: var(${SelectBox.CSS_VAR_PREFIX}danger-selected-bg, #FEF2F2);
        color: var(${SelectBox.CSS_VAR_PREFIX}danger-selected-color, #DC2626);
      }
      
      .${SelectBox.BASE_SELECT_CLASS}-container--danger .${SelectBox.BASE_SELECT_CLASS}-item.selected::before {
        background-color: var(${SelectBox.CSS_VAR_PREFIX}danger-indicator, #ef4444);
      }
      
      /* Placeholder for empty state */
      .${SelectBox.BASE_SELECT_CLASS}-placeholder {
        color: var(${SelectBox.CSS_VAR_PREFIX}placeholder-color, #9ca3af);
        font-style: italic;
      }
      
      /* Label */
      .${SelectBox.BASE_SELECT_CLASS}-label {
        display: block;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(${SelectBox.CSS_VAR_PREFIX}label-color, #374151);
      }
      
      /* Original select for accessibility and form submission */
      .${SelectBox.BASE_SELECT_CLASS}-native {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
        cursor: not-allowed;
      }

      /* Media query for dark mode */
      @media (prefers-color-scheme: dark) {
        .${SelectBox.BASE_SELECT_CLASS}-trigger {
          background-color: #2d2d2d;
          border-color: #555;
          color: #e0e0e0;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-trigger:hover {
          border-color: #777;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-trigger:focus {
          border-color: #3b82f6;
          box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-dropdown {
          background-color: #2d2d2d;
          border-color: #555;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-category {
          border-bottom-color: #444;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-category-label {
          color: #aaa;
          background-color: #3a3a3a;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-item {
          color: #e0e0e0;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-item:hover {
          background-color: #4a4a4a;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-item.selected {
          background-color: #2c3e50;
          color: #3b82f6;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-item.selected::before {
          background-color: #3b82f6;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-item-options {
          background-color: #3a3a3a;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-option-label {
          color: #ccc;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-option-toggle {
          color: #aaa;
        }
        
        .${SelectBox.BASE_SELECT_CLASS}-option-toggle:hover {
          color: #fff;
        }

        .${SelectBox.BASE_SELECT_CLASS}-container.disabled .${SelectBox.BASE_SELECT_CLASS}-trigger {
            background-color: #444;
            color: #888;
        }
      }
    `, 'userscripts-select-styles');

            SelectBox.stylesInitialized = true;
        }

        /**
         * Generate unique ID for the select box if not provided
         * Used for pubsub events
         */
        static generateUniqueId() {
            return `selectbox_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        }

        /**
         * Detect if items are categorized
         * @return {boolean} True if items are categorized
         */
        detectCategorizedItems() {
            // If useCategorizedUI is explicitly set, respect it
            if (this.useCategorizedUI !== undefined) return this.useCategorizedUI;

            // Otherwise, try to auto-detect based on items structure
            if (!this.items || 0 === this.items.length) return false;

            // Check if any item has a categories property
            return this.items.some((item) => item.category !== undefined || item.items !== undefined);
        }

        /**
         * Create the enhanced select box
         * @return {HTMLElement} The wrapper element
         */
        create() {
            // Create main wrapper element
            this.element = document.createElement('div');
            let wrapperClass = `${SelectBox.BASE_SELECT_CLASS}-wrapper`;
            if (this.labelPosition === 'inline' && this.label) {
                wrapperClass += ` ${SelectBox.BASE_SELECT_CLASS}-wrapper--inline`;
            }
            this.element.className = wrapperClass;

            // Create label if provided
            if (this.label) {
                this.labelElement = document.createElement('label');
                let labelClass = `${SelectBox.BASE_SELECT_CLASS}-label`;
                if (this.labelPosition === 'inline') {
                    labelClass += ` ${SelectBox.BASE_SELECT_CLASS}-label--inline`;
                }
                this.labelElement.className = labelClass;
                this.labelElement.textContent = this.label;
                if (this.required) {
                    this.labelElement.textContent += ' *';
                }
                this.element.appendChild(this.labelElement);
            }

            // Create main container
            this.containerElement = document.createElement('div');
            this.containerElement.className = `${SelectBox.BASE_SELECT_CLASS}-container ${SelectBox.BASE_SELECT_CLASS}-container--${this.theme} ${SelectBox.BASE_SELECT_CLASS}-container--${this.size}`;

            // Create native select element for form submission and accessibility
            this.createNativeSelect();

            // Create custom select UI
            if (this.isCategorized) {
                this.createCategorizedSelect();
            } else {
                this.createFlatSelect();
            }

            // Add event listeners
            this.addEventListeners();

            // Add containerElement to wrapper
            this.element.appendChild(this.containerElement);

            // Add to container if provided
            if (this.container) {
                this.container.appendChild(this.element);
            }

            return this.element;
        }

        /**
         * Create the hidden native select element
         */
        createNativeSelect() {
            this.selectElement = document.createElement('select');
            this.selectElement.name = this.name;
            this.selectElement.id = this.id;
            this.selectElement.className = `${SelectBox.BASE_SELECT_CLASS}-native`;

            // Apply additional attributes
            Object.entries(this.attributes).forEach(([key, value]) => {
                this.selectElement.setAttribute(key, value);
            });

            // Add placeholder option if needed
            if (this.placeholder) {
                const placeholderOption = document.createElement('option');
                placeholderOption.value = '';
                placeholderOption.textContent = this.placeholder;
                placeholderOption.disabled = true;
                placeholderOption.selected = !this.hasSelectedItem();
                this.selectElement.appendChild(placeholderOption);
            }

            // Add options
            this.addOptionsToNativeSelect();

            // Add to container
            this.containerElement.appendChild(this.selectElement);
        }

        /**
         * Add options to the native select element
         */
        addOptionsToNativeSelect() {
            // Helper function to add a single option
            const addOption = (item) => {
                const option = document.createElement('option');
                option.value = item.value;
                option.textContent = item.label;

                if (item.selected) {
                    option.selected = true;
                    this.selectedValue = item.value;
                    this.selectedLabel = item.label;
                }

                if (item.disabled) {
                    option.disabled = true;
                }

                this.selectElement.appendChild(option);
            };

            // For categorized items
            if (this.isCategorized) {
                this.items.forEach((category) => {
                    if (category.items && Array.isArray(category.items)) {
                        // Add optgroup if this is a category with a label
                        if (category.label) {
                            const optgroup = document.createElement('optgroup');
                            optgroup.label = category.label;

                            category.items.forEach((item) => {
                                const option = document.createElement('option');
                                option.value = item.value;
                                option.textContent = item.label;

                                if (item.selected) {
                                    option.selected = true;
                                    this.selectedValue = item.value;
                                    this.selectedLabel = item.label;
                                }

                                if (item.disabled) {
                                    option.disabled = true;
                                }

                                optgroup.appendChild(option);
                            });

                            this.selectElement.appendChild(optgroup);
                        } else {
                            // No category label, just add the items
                            category.items.forEach(addOption);
                        }
                    } else {
                        // This is a flat item, not a category
                        addOption(category);
                    }
                });
            } else {
                // For flat items
                this.items.forEach(addOption);
            }
        }

        /**
         * Create a categorized select UI
         */
        createCategorizedSelect() {
            // Create trigger button
            this.triggerElement = document.createElement('button');
            this.triggerElement.type = 'button';
            this.triggerElement.className = `${SelectBox.BASE_SELECT_CLASS}-trigger`;

            // Set initial text
            const triggerText = document.createElement('span');
            triggerText.textContent = this.selectedLabel || this.placeholder;
            if (!this.selectedLabel) {
                triggerText.className = `${SelectBox.BASE_SELECT_CLASS}-placeholder`;
            }
            this.triggerElement.appendChild(triggerText);

            // Add dropdown icon
            const triggerIcon = document.createElement('span');
            triggerIcon.className = `${SelectBox.BASE_SELECT_CLASS}-trigger-icon`;
            triggerIcon.textContent = 'â–¼';
            this.triggerElement.appendChild(triggerIcon);

            // Create dropdown
            this.dropdownElement = document.createElement('div');
            this.dropdownElement.className = `${SelectBox.BASE_SELECT_CLASS}-dropdown`;

            // Add categories and items
            this.items.forEach((category) => {
                // Check if this is a category with items
                if (category.items && Array.isArray(category.items)) {
                    const categoryElement = document.createElement('div');
                    categoryElement.className = `${SelectBox.BASE_SELECT_CLASS}-category`;

                    // Add category label if it exists
                    if (category.label) {
                        const categoryLabel = document.createElement('div');
                        categoryLabel.className = `${SelectBox.BASE_SELECT_CLASS}-category-label`;
                        categoryLabel.textContent = category.label;
                        categoryElement.appendChild(categoryLabel);
                    }

                    // Add items list
                    const itemsList = document.createElement('ul');
                    itemsList.className = `${SelectBox.BASE_SELECT_CLASS}-items`;

                    // Add items
                    category.items.forEach((item) => {
                        const itemElement = this.createItemElement(item);
                        itemsList.appendChild(itemElement);
                    });

                    categoryElement.appendChild(itemsList);
                    this.dropdownElement.appendChild(categoryElement);
                } else {
                    // This is a flat item, not a category
                    const itemsList = document.createElement('ul');
                    itemsList.className = `${SelectBox.BASE_SELECT_CLASS}-items`;

                    const itemElement = this.createItemElement(category);
                    itemsList.appendChild(itemElement);

                    this.dropdownElement.appendChild(itemsList);
                }
            });

            // Add elements to container
            this.containerElement.appendChild(this.triggerElement);
            this.containerElement.appendChild(this.dropdownElement);
        }

        /**
         * Create a flat select UI (simpler version)
         */
        createFlatSelect() {
            // Create trigger button
            this.triggerElement = document.createElement('button');
            this.triggerElement.type = 'button';
            this.triggerElement.className = `${SelectBox.BASE_SELECT_CLASS}-trigger`;

            // Set initial text
            const triggerText = document.createElement('span');
            triggerText.textContent = this.selectedLabel || this.placeholder;
            if (!this.selectedLabel) {
                triggerText.className = `${SelectBox.BASE_SELECT_CLASS}-placeholder`;
            }
            this.triggerElement.appendChild(triggerText);

            // Add dropdown icon
            const triggerIcon = document.createElement('span');
            triggerIcon.className = `${SelectBox.BASE_SELECT_CLASS}-trigger-icon`;
            triggerIcon.textContent = 'â–¼';
            this.triggerElement.appendChild(triggerIcon);

            // Create dropdown
            this.dropdownElement = document.createElement('div');
            this.dropdownElement.className = `${SelectBox.BASE_SELECT_CLASS}-dropdown`;

            // Add items list
            const itemsList = document.createElement('ul');
            itemsList.className = `${SelectBox.BASE_SELECT_CLASS}-items`;

            // Add items
            this.items.forEach((item) => {
                const itemElement = this.createItemElement(item);
                itemsList.appendChild(itemElement);
            });

            this.dropdownElement.appendChild(itemsList);

            // Add elements to container
            this.containerElement.appendChild(this.triggerElement);
            this.containerElement.appendChild(this.dropdownElement);
        }

        /**
         * Create an item element
         * @param {Object} item - The item data
         * @return {HTMLElement} The item element
         */
        createItemElement(item) {
            const itemElement = document.createElement('li');
            itemElement.className = `${SelectBox.BASE_SELECT_CLASS}-item`;
            itemElement.dataset.value = item.value;
            itemElement.textContent = item.label;

            if (item.selected) {
                itemElement.classList.add('selected');
            }

            if (item.disabled) {
                itemElement.classList.add('disabled');
            }

            // Handle item selection
            itemElement.addEventListener('click', (e) => {
                if (item.disabled) return;

                this.selectItem(item.value, item.label);
                this.closeDropdown();

                // Trigger onChange callback
                if (this.onChange) {
                    this.onChange(item.value, e);
                }
            });

            // Add options if available
            if (item.options && 0 < item.options.length) {
                // Add options toggle button
                const toggleButton = document.createElement('button');
                toggleButton.type = 'button';
                toggleButton.className = `${SelectBox.BASE_SELECT_CLASS}-option-toggle`;
                toggleButton.textContent = 'âš™ï¸';
                toggleButton.title = 'Options';

                itemElement.appendChild(toggleButton);

                // Create options container
                const optionsContainer = document.createElement('div');
                optionsContainer.className = `${SelectBox.BASE_SELECT_CLASS}-item-options`;

                // Add options
                item.options.forEach((option) => {
                    const optionRow = document.createElement('div');
                    optionRow.className = `${SelectBox.BASE_SELECT_CLASS}-option-row`;

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `${this.id}-option-${item.value}-${option.id}`;
                    checkbox.className = `${SelectBox.BASE_SELECT_CLASS}-option-checkbox`;
                    checkbox.checked = option.defaultValue || false;

                    const label = document.createElement('label');
                    label.htmlFor = checkbox.id;
                    label.className = `${SelectBox.BASE_SELECT_CLASS}-option-label`;
                    label.textContent = option.label;

                    if (option.description) {
                        label.title = option.description;
                    }

                    // Handle option change
                    checkbox.addEventListener('change', (e) => {
                        // Update option value
                        if (item.optionValues) {
                            item.optionValues[option.id] = e.target.checked;
                        }

                        // Stop propagation to prevent selecting the item
                        e.stopPropagation();
                    });

                    optionRow.appendChild(checkbox);
                    optionRow.appendChild(label);
                    optionsContainer.appendChild(optionRow);
                });

                // Add click handler for toggle button
                toggleButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent item selection
                    optionsContainer.classList.toggle('open');
                });

                // Add options container after the item
                itemElement.insertAdjacentElement('afterend', optionsContainer);
            }

            return itemElement;
        }

        /**
         * Add event listeners
         */
        addEventListeners() {
            // Toggle dropdown on trigger click - using the bound handler
            this.triggerElement.addEventListener('click', this._handleTriggerClick);

            // Other event listeners remain the same
            document.addEventListener('click', (e) => {
                if (!this.containerElement.contains(e.target)) {
                    this.closeDropdown();
                }
            });

            document.addEventListener('keydown', (e) => {
                if ('Escape' === e.key) {
                    this.closeDropdown();
                }
            });

            // Sync with native select
            this.selectElement.addEventListener('change', (e) => {
                this.selectItemFromNative();
            });
        }

        /**
         * Toggle dropdown visibility
         */
        toggleDropdown() {
            const isOpen = this.dropdownElement.classList.contains('open');

            if (isOpen) {
                this.closeDropdown();
            } else {
                this.openDropdown();
            }
        }

        /**
         * Open the dropdown
         */
        openDropdown() {
            this.dropdownElement.classList.add('open');
            this.triggerElement.querySelector(`.${SelectBox.BASE_SELECT_CLASS}-trigger-icon`).classList.add('open');

            // Ensure the selected item is visible
            const selectedItem = this.dropdownElement.querySelector(`.${SelectBox.BASE_SELECT_CLASS}-item.selected`);
            if (selectedItem) {
                selectedItem.scrollIntoView({block: 'nearest'});
            }

            // Get dropdown height for proper adjustment
            const dropdownHeight = this.dropdownElement.scrollHeight;

            // Publish event that dropdown is open with its height
            PubSub.publish('selectbox:dropdown:open', {
                id: this.instanceId,
                height: dropdownHeight,
            });
        }

        /**
         * Close the dropdown
         */
        closeDropdown() {
            this.dropdownElement.classList.remove('open');
            this.triggerElement.querySelector(`.${SelectBox.BASE_SELECT_CLASS}-trigger-icon`).classList.remove('open');

            // Close any open options
            const openOptions = this.dropdownElement.querySelectorAll(`.${SelectBox.BASE_SELECT_CLASS}-item-options.open`);
            openOptions.forEach((option) => {
                option.classList.remove('open');
            });

            // Publish event that dropdown is closed
            PubSub.publish('selectbox:dropdown:close', {
                id: this.instanceId,
            });
        }

        /**
         * Select an item
         * @param {string} value - The value to select
         * @param {string} label - The label text
         */
        selectItem(value, label) {
            // Update native select
            this.selectElement.value = value;

            // Update selected value and label
            this.selectedValue = value;
            this.selectedLabel = label;

            // Update trigger text
            const triggerText = this.triggerElement.querySelector('span:first-child');
            triggerText.textContent = label;
            triggerText.classList.remove(`${SelectBox.BASE_SELECT_CLASS}-placeholder`);

            // Update item classes
            const items = this.dropdownElement.querySelectorAll(`.${SelectBox.BASE_SELECT_CLASS}-item`);
            items.forEach((item) => {
                if (item.dataset.value === value) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        /**
         * Select item based on native select value
         */
        selectItemFromNative() {
            const value = this.selectElement.value;
            const selectedOption = this.selectElement.options[this.selectElement.selectedIndex];
            const label = selectedOption ? selectedOption.textContent : '';

            if (value && label) {
                this.selectItem(value, label);
            }
        }

        /**
         * Check if any item is selected
         * @return {boolean} True if at least one item is selected
         */
        hasSelectedItem() {
            if (this.isCategorized) {
                // For categorized items
                return this.items.some((category) => {
                    if (category.items && Array.isArray(category.items)) {
                        return category.items.some((item) => item.selected);
                    }
                    return category.selected;
                });
            }

            // For flat items
            return this.items.some((item) => item.selected);
        }

        /**
         * Get the currently selected value
         * @return {string} The value of the selected option
         */
        getValue() {
            return this.selectedValue;
        }

        destroy() {
            // Clean up any event listeners
            if (this.triggerElement) {
                this.triggerElement.removeEventListener('click', this._handleTriggerClick);
            }

            // Publish that this selectbox is being destroyed
            PubSub.publish('selectbox:destroy', {
                id: this.instanceId,
            });
        }

        /**
         * Set the selected value
         * @param {string} value - The value to select
         * @param {boolean} [triggerChange=false] - Whether to trigger the onChange event
         */
        setValue(value, triggerChange = false) {
            // Find the item with the given value
            let found = false;
            let label = '';

            const findInItems = (items) => {
                for (const item of items) {
                    if (item.value === value) {
                        found = true;
                        label = item.label;
                        return true;
                    }
                }
                return false;
            };

            if (this.isCategorized) {
                // Search in categorized items
                for (const category of this.items) {
                    if (category.items && Array.isArray(category.items)) {
                        if (findInItems(category.items)) {
                            break;
                        }
                    } else if (category.value === value) {
                        found = true;
                        label = category.label;
                        break;
                    }
                }
            } else {
                // Search in flat items
                findInItems(this.items);
            }

            if (found) {
                // Update the native select
                this.selectElement.value = value;

                // Update the custom UI
                this.selectItem(value, label);

                // Trigger change event if requested
                if (triggerChange && this.onChange) {
                    const event = new Event('change');
                    this.selectElement.dispatchEvent(event);
                }
            }
        }

        /**
         * Add a new option
         * @param {Object} item - An object with {value: string, label: string, selected: boolean}
         * @param {string} [categoryId] - Optional category ID to add the item to
         */
        addOption(item, categoryId) {
            if (this.isCategorized && categoryId) {
                // Add to specific category
                const categoryIndex = this.items.findIndex((category) =>
                    category.id === categoryId || category.value === categoryId,
                );

                if (0 <= categoryIndex) {
                    const category = this.items[categoryIndex];

                    if (!category.items) {
                        category.items = [];
                    }

                    category.items.push(item);
                } else {
                    // Category not found, add as flat item
                    this.items.push(item);
                }
            } else {
                // Add to flat items
                this.items.push(item);
            }

            // Update the native select
            const option = document.createElement('option');
            option.value = item.value;
            option.textContent = item.label;

            if (item.selected) {
                option.selected = true;
                this.selectedValue = item.value;
                this.selectedLabel = item.label;
            }

            if (item.disabled) {
                option.disabled = true;
            }

            this.selectElement.appendChild(option);

            // If using custom UI, we need to rebuild it
            this.rebuild();
        }

        /**
         * Remove an option by value
         * @param {string} value - The value of the option to remove
         */
        removeOption(value) {
            // Helper function to remove from an array of items
            const removeFromItems = (items) => {
                const index = items.findIndex((item) => item.value === value);
                if (0 <= index) {
                    items.splice(index, 1);
                    return true;
                }
                return false;
            };

            // Remove from the items array
            if (this.isCategorized) {

                for (const category of this.items) {
                    if (category.items && Array.isArray(category.items)) {
                        if (removeFromItems(category.items)) {
                            break;
                        }
                    } else if (category.value === value) {
                        const index = this.items.indexOf(category);
                        this.items.splice(index, 1);
                        break;
                    }
                }
            } else {
                // Remove from flat items
                removeFromItems(this.items);
            }

            // Remove from the native select
            const option = this.selectElement.querySelector(`option[value="${value}"]`);
            if (option) {
                option.remove();
            }

            // If it was the selected option, update selected value
            if (this.selectedValue === value) {
                this.selectedValue = '';
                this.selectedLabel = '';

                // Update trigger text to placeholder
                const triggerText = this.triggerElement.querySelector('span:first-child');
                triggerText.textContent = this.placeholder;
                triggerText.classList.add(`${SelectBox.BASE_SELECT_CLASS}-placeholder`);
            }

            // If using custom UI, we need to rebuild it
            this.rebuild();
        }

        /**
         * Update the options in the select box
         * @param {Array} items - New array of items
         * @param {boolean} [reset=false] - Whether to completely reset the options
         */
        updateOptions(items, reset = false) {
            if (reset) {
                // Clear all options in native select
                while (0 < this.selectElement.options.length) {
                    this.selectElement.options[0].remove();
                }

                // Reset items array
                this.items = [];

                // Reset selected value
                this.selectedValue = '';
                this.selectedLabel = '';
            }

            // Add new items
            this.items = items;

            // Re-detect if categorized
            this.isCategorized = this.detectCategorizedItems();

            // Add to native select
            this.addOptionsToNativeSelect();

            // Rebuild the UI
            this.rebuild();
        }

        _handleTriggerClick = (e) => {
            e.stopPropagation();
            this.toggleDropdown();
        }

        /**
         * Rebuild the custom UI
         */
        rebuild() {
            // Remove existing trigger and dropdown
            if (this.triggerElement) {
                this.triggerElement.remove();
            }

            if (this.dropdownElement) {
                this.dropdownElement.remove();
            }

            // Recreate the UI
            if (this.isCategorized) {
                this.createCategorizedSelect();
            } else {
                this.createFlatSelect();
            }

            // Re-add event listeners
            this.addEventListeners();
        }

        /**
         * Disable the select box
         * @param {boolean} disabled - Whether the select should be disabled
         */
        setDisabled(disabled) {
            // Update native select
            this.selectElement.disabled = disabled;

            // Update custom UI
            if (disabled) {
                this.containerElement.classList.add(`${SelectBox.BASE_SELECT_CLASS}-container--disabled`);
                this.triggerElement.disabled = true;
            } else {
                this.containerElement.classList.remove(`${SelectBox.BASE_SELECT_CLASS}-container--disabled`);
                this.triggerElement.disabled = false;
            }
        }

        /**
         * Set the theme of the select box
         * @param {string} theme - The new theme name
         */
        setTheme(theme) {
            this.theme = theme;

            // Update container class
            const themeClasses = ['default', 'primary', 'success', 'danger'];
            themeClasses.forEach((themeClass) => {
                this.containerElement.classList.remove(`${SelectBox.BASE_SELECT_CLASS}-container--${themeClass}`);
            });

            this.containerElement.classList.add(`${SelectBox.BASE_SELECT_CLASS}-container--${theme}`);
        }

        /**
         * Set the size of the select box
         * @param {string} size - The new size (e.g., "small", "medium", "large")
         */
        setSize(size) {
            this.size = size;

            // Update container class
            const sizeClasses = ['small', 'medium', 'large'];
            sizeClasses.forEach((sizeClass) => {
                this.containerElement.classList.remove(`${SelectBox.BASE_SELECT_CLASS}-container--${sizeClass}`);
            });

            this.containerElement.classList.add(`${SelectBox.BASE_SELECT_CLASS}-container--${size}`);
        }
    }

    /**
     * Button - A reusable UI component for buttons.
     * Creates customizable, accessible buttons with various states and callbacks.
     */

    /**
     * A reusable UI component for creating accessible, customizable buttons.
     */
    class Button {
      /**
         * Returns the unique base CSS class for the Button component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for buttons.
         */
      static get BASE_BUTTON_CLASS() {
        return 'userscripts-button';
      }
      /**
         * Returns the CSS variable prefix used for theming and styling the Button component.
         * This prefix scopes all custom CSS variables (e.g., colors, borders) related to the button.
         *
         * @return {string} The CSS variable prefix.
         */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-button-';
      }
      /**
         * Initialize styles for all buttons.
         * These styles reference the CSS variables with our defined prefix.
         */
      static initStyles() {
        if (Button.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts Button Component */
      .${Button.BASE_BUTTON_CLASS} {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-family: inherit;
        font-weight: 500;
        border-radius: 0.375rem;
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.15s ease-in-out;
        text-align: center;
        background-color: var(${Button.CSS_VAR_PREFIX}bg);
        color: var(${Button.CSS_VAR_PREFIX}color);
        border-color: var(${Button.CSS_VAR_PREFIX}border);
      }
      
      /* Button sizes */
      .${Button.BASE_BUTTON_CLASS}--small {
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        min-height: 1.75rem;
      }
      .${Button.BASE_BUTTON_CLASS}--medium {
        font-size: 0.875rem;
        padding: 0.5rem 1rem;
        min-height: 2.25rem;
      }
      .${Button.BASE_BUTTON_CLASS}--large {
        font-size: 1rem;
        padding: 0.75rem 1.5rem;
        min-height: 2.75rem;
      }
      
      /* Button themes using CSS variables */
      .${Button.BASE_BUTTON_CLASS}--default {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-default);
        color: var(${Button.CSS_VAR_PREFIX}color-default);
        border-color: var(${Button.CSS_VAR_PREFIX}border-default);
      }
      .${Button.BASE_BUTTON_CLASS}--default:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-default-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--primary {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-primary);
        color: var(${Button.CSS_VAR_PREFIX}color-primary);
        border-color: var(${Button.CSS_VAR_PREFIX}border-primary);
      }
      .${Button.BASE_BUTTON_CLASS}--primary:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-primary-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-primary-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--secondary {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-secondary);
        color: var(${Button.CSS_VAR_PREFIX}color-secondary);
        border-color: var(${Button.CSS_VAR_PREFIX}border-secondary);
      }
      .${Button.BASE_BUTTON_CLASS}--secondary:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-secondary-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-secondary-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--success {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-success);
        color: var(${Button.CSS_VAR_PREFIX}color-success);
        border-color: var(${Button.CSS_VAR_PREFIX}border-success);
      }
      .${Button.BASE_BUTTON_CLASS}--success:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-success-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-success-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--danger {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-danger);
        color: var(${Button.CSS_VAR_PREFIX}color-danger);
        border-color: var(${Button.CSS_VAR_PREFIX}border-danger);
      }
      .${Button.BASE_BUTTON_CLASS}--danger:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-danger-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-danger-hover);
      }
      
      /* Generic state styles */
      .${Button.BASE_BUTTON_CLASS}:disabled {
        opacity: 0.65;
        cursor: not-allowed;
        pointer-events: none;
      }
      .${Button.BASE_BUTTON_CLASS}:focus {
        outline: none;
        box-shadow: 0 0 0 3px var(${Button.CSS_VAR_PREFIX}focus-shadow);
      }
      
      /* Generic pseudo-class rules */
      .${Button.BASE_BUTTON_CLASS}:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-hover);
      }
      .${Button.BASE_BUTTON_CLASS}:active:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-active);
      }
      
      /* Button content */
      .${Button.BASE_BUTTON_CLASS}__icon {
        display: inline-flex;
        margin-right: 0.5rem;
      }
      .${Button.BASE_BUTTON_CLASS}__text {
        display: inline-block;
      }
    `, 'userscripts-button-styles');

        Button.stylesInitialized = true;
      }
      /**
         * Inject default color variables for the button component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
      static useDefaultColors() {
        const styleId = 'userscripts-button-default-colors';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          HTMLUtils.setHTMLSafely(style, `
        :root {
          ${Button.CSS_VAR_PREFIX}bg-default: #f3f4f6;
          ${Button.CSS_VAR_PREFIX}color-default: #374151;
          ${Button.CSS_VAR_PREFIX}border-default: #d1d5db;
          ${Button.CSS_VAR_PREFIX}bg-default-hover: #e5e7eb;
          
          ${Button.CSS_VAR_PREFIX}bg-primary: #3b82f6;
          ${Button.CSS_VAR_PREFIX}color-primary: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-primary: #3b82f6;
          ${Button.CSS_VAR_PREFIX}bg-primary-hover: #2563eb;
          ${Button.CSS_VAR_PREFIX}border-primary-hover: #2563eb;
          
          ${Button.CSS_VAR_PREFIX}bg-secondary: #6b7280;
          ${Button.CSS_VAR_PREFIX}color-secondary: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-secondary: #6b7280;
          ${Button.CSS_VAR_PREFIX}bg-secondary-hover: #4b5563;
          ${Button.CSS_VAR_PREFIX}border-secondary-hover: #4b5563;
          
          ${Button.CSS_VAR_PREFIX}bg-success: #10b981;
          ${Button.CSS_VAR_PREFIX}color-success: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-success: #10b981;
          ${Button.CSS_VAR_PREFIX}bg-success-hover: #059669;
          ${Button.CSS_VAR_PREFIX}border-success-hover: #059669;
          
          ${Button.CSS_VAR_PREFIX}bg-danger: #ef4444;
          ${Button.CSS_VAR_PREFIX}color-danger: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-danger: #ef4444;
          ${Button.CSS_VAR_PREFIX}bg-danger-hover: #dc2626;
          ${Button.CSS_VAR_PREFIX}border-danger-hover: #dc2626;
          
          ${Button.CSS_VAR_PREFIX}bg-hover: #e0e0e0;
          ${Button.CSS_VAR_PREFIX}bg-active: #d0d0d0;
          
          ${Button.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.3);
        }

        @media (prefers-color-scheme: dark) {
          :root {
            ${Button.CSS_VAR_PREFIX}bg-default: #4a4a4a;
            ${Button.CSS_VAR_PREFIX}color-default: #e0e0e0;
            ${Button.CSS_VAR_PREFIX}border-default: #6b7280;
            ${Button.CSS_VAR_PREFIX}bg-default-hover: #5a5a5a;

            ${Button.CSS_VAR_PREFIX}bg-primary: #3b82f6;
            ${Button.CSS_VAR_PREFIX}color-primary: #ffffff;
            ${Button.CSS_VAR_PREFIX}border-primary: #3b82f6;
            ${Button.CSS_VAR_PREFIX}bg-primary-hover: #2563eb;
            ${Button.CSS_VAR_PREFIX}border-primary-hover: #2563eb;

            ${Button.CSS_VAR_PREFIX}bg-secondary: #6b7280;
            ${Button.CSS_VAR_PREFIX}color-secondary: #ffffff;
            ${Button.CSS_VAR_PREFIX}border-secondary: #6b7280;
            ${Button.CSS_VAR_PREFIX}bg-secondary-hover: #5a6268;
            ${Button.CSS_VAR_PREFIX}border-secondary-hover: #5a6268;

            ${Button.CSS_VAR_PREFIX}bg-success: #10b981;
            ${Button.CSS_VAR_PREFIX}color-success: #ffffff;
            ${Button.CSS_VAR_PREFIX}border-success: #10b981;
            ${Button.CSS_VAR_PREFIX}bg-success-hover: #059669;
            ${Button.CSS_VAR_PREFIX}border-success-hover: #059669;

            ${Button.CSS_VAR_PREFIX}bg-danger: #ef4444;
            ${Button.CSS_VAR_PREFIX}color-danger: #ffffff;
            ${Button.CSS_VAR_PREFIX}border-danger: #ef4444;
            ${Button.CSS_VAR_PREFIX}bg-danger-hover: #dc2626;
            ${Button.CSS_VAR_PREFIX}border-danger-hover: #dc2626;
            
            ${Button.CSS_VAR_PREFIX}bg-hover: #555;
            ${Button.CSS_VAR_PREFIX}bg-active: #666;

            ${Button.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.4);
          }
        }
      `);
          document.head.appendChild(style);
        }
      }
      /**
         * Create a new Button.
         * @param {Object} options - Configuration options.
         * @param {String} options.text - Button text.
         * @param {String} [options.type="button"] - Button type.
         * @param {String} [options.className] - Additional custom CSS class.
         * @param {Function} options.onClick - Click event handler.
         * @param {String} [options.id] - Button ID.
         * @param {HTMLElement} [options.container] - Container to append the button to.
         * @param {Object} [options.attributes={}] - Additional HTML attributes.
         * @param {String} [options.theme="default"] - Button theme.
         * @param {String} [options.size="medium"] - Button size.
         * @param {Boolean} [options.disabled=false] - Disabled state.
         * @param {String} [options.icon] - Optional icon HTML.
         * @param {String} [options.successText] - Success state text.
         * @param {Number} [options.successDuration=1500] - Success state duration (ms).
         */
      constructor(options) {
        this.text = options.text || '';
        this.type = options.type || 'button';
        this.customClassName = options.className || '';
        this.onClick = options.onClick;
        this.id = options.id;
        this.container = options.container;
        this.attributes = options.attributes || {};
        this.theme = options.theme;
        this.size = options.size || 'medium';
        this.disabled = options.disabled || false;
        this.icon = options.icon || null;
        this.successText = options.successText || null;
        this.successDuration = options.successDuration || 1500;
        this.originalText = this.text;

        // These properties will refer to the DOM elements.
        this.button = null;
        this.textElement = null;

        Button.initStyles();
        this.create();
      }


      /**
         * Create the button element and, if a container is provided, append it.
         * @return {HTMLButtonElement} The created button element.
         */
      create() {
        this.button = document.createElement('button');
        this.button.type = this.type;
        this.button.disabled = this.disabled;
        if (this.id) this.button.id = this.id;
        this.button._buttonInstance = this;
        this.updateButtonClasses();
        this.updateContent();
        if (this.onClick) this.button.addEventListener('click', (e) => this.handleClick(e));
        Object.entries(this.attributes).forEach(([key, value]) => {
          this.button.setAttribute(key, value);
        });
        if (this.container) this.container.appendChild(this.button);
        return this.button;
      }

      /**
         * Update the classes on the button element based on theme, size, and custom classes.
         */
      updateButtonClasses() {
        const classNames = [Button.BASE_BUTTON_CLASS];
        classNames.push(`${Button.BASE_BUTTON_CLASS}--${this.theme}`);
        classNames.push(`${Button.BASE_BUTTON_CLASS}--${this.size}`);
        if (this.customClassName) classNames.push(this.customClassName);
        this.button.className = classNames.join(' ');
      }

      /**
         * Update the button content (icon and text).
         */
      updateContent() {
        // Clear existing content using DOM methods instead of innerHTML
        while (this.button.firstChild) {
          this.button.removeChild(this.button.firstChild);
        }
        
        if (this.icon) {
          const iconSpan = document.createElement('span');
          iconSpan.className = `${Button.BASE_BUTTON_CLASS}__icon`;
          HTMLUtils.setHTMLSafely(iconSpan, this.icon);
          this.button.appendChild(iconSpan);
        }
        this.textElement = document.createElement('span');
        this.textElement.className = `${Button.BASE_BUTTON_CLASS}__text`;
        this.textElement.textContent = this.text;
        this.button.appendChild(this.textElement);
      }

      /**
         * Handle click events on the button.
         * @param {Event} e - The click event.
         */
      handleClick(e) {
        if (this.disabled) return;
        const result = this.onClick(e);
        if (this.successText && false !== result) {
          this.showSuccessState();
        }
      }

      /**
         * Show a success state by temporarily changing the button's text and theme.
         */
      showSuccessState() {
        const originalText = this.text;
        const originalTheme = this.theme;
        this.setText(this.successText);
        this.setTheme('success');
        setTimeout(() => {
          this.setText(originalText);
          this.setTheme(originalTheme);
        }, this.successDuration);
      }

      /**
         * Set the button's text.
         * @param {String} text - The new text to display.
         */
      setText(text) {
        this.text = text;
        if (this.textElement) {
          this.textElement.textContent = text;
        } else {
          this.updateContent();
        }
      }

      /**
         * Reset the button's text to its original value.
         */
      resetText() {
        this.setText(this.originalText);
      }

      /**
         * Set an icon for the button.
         * @param {String} iconHtml - The HTML string for the icon.
         */
      setIcon(iconHtml) {
        this.icon = iconHtml;
        this.updateContent();
      }

      /**
         * Enable or disable the button.
         * @param {Boolean} disabled - Whether the button should be disabled.
         */
      setDisabled(disabled) {
        this.disabled = disabled;
        this.button.disabled = disabled;
      }

      /**
         * Toggle the disabled state of the button.
         * @return {Boolean} The new disabled state.
         */
      toggleDisabled() {
        this.setDisabled(!this.disabled);
        return this.disabled;
      }

      /**
         * Change the button's theme.
         * @param {String} theme - The new theme (e.g., "default", "primary", etc.).
         */
      setTheme(theme) {
        this.button.classList.remove(`${Button.BASE_BUTTON_CLASS}--${this.theme}`);
        this.theme = theme;
        this.button.classList.add(`${Button.BASE_BUTTON_CLASS}--${this.theme}`);
      }

      /**
         * Change the button's size.
         * @param {String} size - The new size (e.g., "small", "medium", "large").
         */
      setSize(size) {
        this.button.classList.remove(`${Button.BASE_BUTTON_CLASS}--${this.size}`);
        this.size = size;
        this.button.classList.add(`${Button.BASE_BUTTON_CLASS}--${this.size}`);
      }

      /**
         * Apply a custom CSS class to the button.
         * @param {String} className - The custom class name.
         */
      setCustomClass(className) {
        if (this.customClassName) {
          this.button.classList.remove(this.customClassName);
        }
        this.customClassName = className;
        if (className) {
          this.button.classList.add(className);
        }
      }
    }

    // Static property to track if styles have been initialized.
    Button.stylesInitialized = false;
    Button.initStyles();

    /**
     * Enhanced version of the ProgressBar core component with Eksi-style UI
     * This replaces the existing ProgressBar.js file in the core/ui directory
     */

    class ProgressBar {
      /**
         * Returns the unique base CSS class for the ProgressBar component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for progress bars.
         */
      static get BASE_PROGRESS_CLASS() {
        return 'userscripts-progress';
      }
      /**
         * Returns the CSS variable prefix used for theming the ProgressBar component.
         * This prefix scopes all custom CSS variables (e.g., colors) related to the progress bar.
         *
         * @return {string} The CSS variable prefix.
         */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-progress-';
      }
      /**
         * Initialize styles for all progress bars.
         * These styles reference the CSS variables with our defined prefix.
         */
      static initStyles() {
        if (ProgressBar.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts ProgressBar Component */
      .${ProgressBar.BASE_PROGRESS_CLASS} {
        width: 100%;
        margin: 10px 0;
        position: relative;
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-label {
        font-size: 0.875rem;
        margin-bottom: 4px;
        display: block;
        color: var(${ProgressBar.CSS_VAR_PREFIX}label-color, #555);
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-bar {
        height: 20px;
        background-color: var(${ProgressBar.CSS_VAR_PREFIX}bar-bg, #f3f3f3);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        height: 100%;
        width: 0%;
        border-radius: 10px;
        transition: width 0.5s ease;
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}fill-bg)), 
          var(${ProgressBar.CSS_VAR_PREFIX}fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}fill-bg))
        );
        position: relative;
        overflow: hidden;
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-fill::after {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.1) 25%,
          transparent 25%,
          transparent 50%,
          rgba(255, 255, 255, 0.1) 50%,
          rgba(255, 255, 255, 0.1) 75%,
          transparent 75%,
          transparent 100%
        );
        background-size: 30px 30px;
        animation: ${ProgressBar.BASE_PROGRESS_CLASS}-stripes 1s linear infinite;
      }
      
      @keyframes ${ProgressBar.BASE_PROGRESS_CLASS}-stripes {
        0% {
          background-position: 0 0;
        }
        100% {
          background-position: 30px 0;
        }
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-text {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 10px;
        font-size: 0.75rem;
        color: var(${ProgressBar.CSS_VAR_PREFIX}text-color, #333);
        font-weight: bold;
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
        z-index: 1;
      }
      
      /* Themes */
      .${ProgressBar.BASE_PROGRESS_CLASS}--default .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}default-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}default-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--primary .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--success .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}success-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}success-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--danger .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--warning .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-bg))
        );
      }
      
      /* Sizes */
      .${ProgressBar.BASE_PROGRESS_CLASS}--small .${ProgressBar.BASE_PROGRESS_CLASS}-bar {
        height: 8px;
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--large .${ProgressBar.BASE_PROGRESS_CLASS}-bar {
        height: 24px;
      }
    `, 'userscripts-progress-styles');
        ProgressBar.stylesInitialized = true;
      }
      /**
         * Injects default color variables for the ProgressBar component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
      static useDefaultColors() {
        const styleId = 'userscripts-progress-default-colors';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          style.innerHTML = `
        :root {
          /* Base colors */
          ${ProgressBar.CSS_VAR_PREFIX}label-color: #555;
          ${ProgressBar.CSS_VAR_PREFIX}bar-bg: #f3f3f3;
          ${ProgressBar.CSS_VAR_PREFIX}fill-bg: #6b7280;
          ${ProgressBar.CSS_VAR_PREFIX}text-color: #333;
          
          /* Theme colors with gradients */
          ${ProgressBar.CSS_VAR_PREFIX}default-fill-bg: #6b7280;
          ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-start: #6b7280;
          ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-end: #4b5563;
          
          ${ProgressBar.CSS_VAR_PREFIX}primary-fill-bg: #3b82f6;
          ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-start: #3b82f6;
          ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-end: #2563eb;
          
          ${ProgressBar.CSS_VAR_PREFIX}success-fill-bg: #10b981;
          ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-start: #10b981;
          ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-end: #059669;
          
          ${ProgressBar.CSS_VAR_PREFIX}danger-fill-bg: #ef4444;
          ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-start: #ef4444;
          ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-end: #dc2626;
          
          ${ProgressBar.CSS_VAR_PREFIX}warning-fill-bg: #f59e0b;
          ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-start: #f59e0b;
          ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-end: #d97706;
        }

        @media (prefers-color-scheme: dark) {
          :root {
            /* Base colors */
            ${ProgressBar.CSS_VAR_PREFIX}label-color: #e0e0e0;
            ${ProgressBar.CSS_VAR_PREFIX}bar-bg: #2d2d2d;
            ${ProgressBar.CSS_VAR_PREFIX}text-color: #ffffff;
            
            /* Theme colors with gradients */
            ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-start: #6b7280;
            ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-end: #4b5563;
            
            ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-start: #3b82f6;
            ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-end: #2563eb;
            
            ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-start: #10b981;
            ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-end: #059669;
            
            ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-start: #ef4444;
            ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-end: #dc2626;
            
            ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-start: #f59e0b;
            ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-end: #d97706;
          }
        }
      `;
          document.head.appendChild(style);
        }
      }
      /**
         * Create a new progress bar.
         * @param {Object} options - Configuration options.
         * @param {number} options.initialValue - Initial progress value (0-100).
         * @param {string} [options.className='userscripts-progress'] - CSS class for styling.
         * @param {HTMLElement} options.container - Container element to which the progress bar will be appended.
         * @param {boolean} [options.showText=true] - Whether to display the progress text.
         * @param {boolean} [options.showLabel=false] - Whether to display a label above the progress bar.
         * @param {string} [options.label=''] - Label text to display if showLabel is true.
         * @param {string} [options.theme='default'] - Theme for the progress bar (e.g., "default", "primary", "success").
         * @param {string} [options.size='normal'] - Size of the progress bar ('small', 'normal', 'large').
         */
      constructor(options) {
        this.value = options.initialValue || 0;
        this.className = options.className || ProgressBar.BASE_PROGRESS_CLASS;
        this.container = options.container;
        this.showText = options.showText !== undefined ? options.showText : true;
        this.showLabel = options.showLabel || false;
        this.label = options.label || '';
        this.theme = options.theme || 'default';
        this.size = options.size || 'normal';

        this.progressElement = null;
        this.progressBarElement = null;
        this.progressFillElement = null;
        this.progressTextElement = null;
        this.labelElement = null;

        ProgressBar.initStyles();
        this.create();
      }


      /**
         * Creates the progress bar elements and appends them to the container if provided.
         * @return {HTMLElement} The created progress bar container element.
         */
      create() {
        // Create the progress bar container
        this.progressElement = document.createElement('div');
        this.progressElement.className = `${this.className} ${this.className}--${this.theme}`;

        if ('normal' !== this.size) {
          this.progressElement.classList.add(`${this.className}--${this.size}`);
        }

        // Add a label if requested
        if (this.showLabel) {
          this.labelElement = document.createElement('span');
          this.labelElement.className = `${this.className}-label`;
          this.labelElement.textContent = this.label;
          this.progressElement.appendChild(this.labelElement);
        }

        // Create the progress bar and its fill
        this.progressBarElement = document.createElement('div');
        this.progressBarElement.className = `${this.className}-bar`;

        this.progressFillElement = document.createElement('div');
        this.progressFillElement.className = `${this.className}-fill`;
        this.progressFillElement.style.width = `${this.value}%`;

        this.progressBarElement.appendChild(this.progressFillElement);
        this.progressElement.appendChild(this.progressBarElement);

        // Add progress text as absolute positioned element
        if (this.showText) {
          this.progressTextElement = document.createElement('div');
          this.progressTextElement.className = `${this.className}-text`;
          this.progressTextElement.textContent = `${this.value}%`;
          this.progressBarElement.appendChild(this.progressTextElement);
        }

        // Append the entire progress element to the container, if one was provided
        if (this.container) {
          this.container.appendChild(this.progressElement);
        }
        return this.progressElement;
      }

      /**
         * Updates the progress value and (optionally) the display text.
         * @param {number} value - The new progress value (between 0 and 100).
         * @param {string} [text] - Optional custom text to display.
         * @return {number} The updated progress value.
         */
      setValue(value, text) {
        this.value = Math.min(100, Math.max(0, value));
        if (this.progressFillElement) {
          this.progressFillElement.style.width = `${this.value}%`;
        }
        if (this.showText && this.progressTextElement) {
          this.progressTextElement.textContent = text || `${this.value}%`;
        }
        return this.value;
      }

      /**
         * Changes the progress bar theme by updating the theme class.
         * @param {string} theme - The new theme (e.g., "default", "primary", "success", etc.).
         */
      setTheme(theme) {
        this.theme = theme;
        if (this.progressElement) {
          // Remove any existing theme class (assumed to be in the format `${this.className}--<theme>`)
          const classes = this.progressElement.className.split(' ');
          const nonThemeClasses = classes.filter((cls) =>
            !cls.startsWith(`${this.className}--`) ||
                    cls === `${this.className}--${this.size}`, // Keep size class
          );
          this.progressElement.className = `${nonThemeClasses.join(' ')} ${this.className}--${this.theme}`;
        }
      }

      /**
         * Changes the progress bar size.
         * @param {string} size - The new size ('small', 'normal', 'large').
         */
      setSize(size) {
        this.size = size;
        if (this.progressElement) {
          // Remove size classes
          this.progressElement.classList.remove(`${this.className}--small`);
          this.progressElement.classList.remove(`${this.className}--large`);

          // Add new size class if not normal
          if ('normal' !== size) {
            this.progressElement.classList.add(`${this.className}--${size}`);
          }
        }
      }

      /**
         * Sets the label text for the progress bar.
         * @param {string} label - The new label text.
         */
      setLabel(label) {
        this.label = label;
        if (this.labelElement) {
          this.labelElement.textContent = label;
        }
      }

      /**
         * Shows or hides the entire progress bar.
         * @param {boolean} visible - True to show, false to hide.
         */
      setVisible(visible) {
        if (this.progressElement) {
          this.progressElement.style.display = visible ? '' : 'none';
        }
      }

      /**
         * Destroys the progress bar and removes it from the DOM.
         */
      destroy() {
        if (this.progressElement && this.progressElement.parentNode) {
          this.progressElement.parentNode.removeChild(this.progressElement);
        }
        this.progressElement = null;
        this.progressBarElement = null;
        this.progressFillElement = null;
        this.progressTextElement = null;
        this.labelElement = null;
      }
    }

    // Static property to track if styles have been initialized.
    ProgressBar.stylesInitialized = false;

    // Initialize styles when imported.
    ProgressBar.initStyles();

    /**
     * Checkbox - A reusable UI component for checkboxes.
     * Creates customizable, accessible checkboxes with various states and callbacks.
     */

    /**
     * A reusable UI component for creating accessible, customizable checkboxes.
     */
    class Checkbox {
      /**
         * Returns the unique base CSS class for the Checkbox component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for checkboxes.
         */
      static get BASE_CHECKBOX_CLASS() {
        return 'userscripts-checkbox';
      }
      /**
         * Returns the CSS variable prefix used for theming and styling the Checkbox component.
         * This prefix scopes all custom CSS variables (e.g., colors, borders) related to the checkbox.
         *
         * @return {string} The CSS variable prefix.
         */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-checkbox-';
      }
      /**
         * Initialize styles for all checkboxes.
         * These styles reference the CSS variables with our defined prefix.
         */
      static initStyles() {
        if (Checkbox.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts Checkbox Component */
      .${Checkbox.BASE_CHECKBOX_CLASS}-container {
        display: inline-flex;
        align-items: center;
        position: relative;
        cursor: pointer;
        user-select: none;
        font-family: inherit;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled {
        opacity: 0.65;
        cursor: not-allowed;
      }
      
      /* Hide native checkbox */
      .${Checkbox.BASE_CHECKBOX_CLASS}-native {
        position: absolute;
        opacity: 0;
        height: 0;
        width: 0;
      }
      
      /* Custom checkbox appearance */
      .${Checkbox.BASE_CHECKBOX_CLASS} {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 0.25rem;
        border: 2px solid var(${Checkbox.CSS_VAR_PREFIX}border-color);
        background-color: var(${Checkbox.CSS_VAR_PREFIX}bg);
        transition: all 0.2s ease;
        position: relative;
      }
      
      /* Check mark (initially hidden) */
      .${Checkbox.BASE_CHECKBOX_CLASS}::after {
        content: '';
        position: absolute;
        opacity: 0;
        transform: rotate(45deg) scale(0);
        width: 0.3125rem;
        height: 0.625rem;
        border-right: 2px solid var(${Checkbox.CSS_VAR_PREFIX}checkmark-color);
        border-bottom: 2px solid var(${Checkbox.CSS_VAR_PREFIX}checkmark-color);
        transition: all 0.2s ease;
      }
      
      /* When checkbox is checked */
      .${Checkbox.BASE_CHECKBOX_CLASS}--checked {
        background-color: var(${Checkbox.CSS_VAR_PREFIX}checked-bg);
        border-color: var(${Checkbox.CSS_VAR_PREFIX}checked-border);
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--checked::after {
        opacity: 1;
        transform: rotate(45deg) scale(1);
      }
      
      /* Indeterminate state */
      .${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate::after {
        opacity: 1;
        transform: rotate(0) scale(1);
        width: 0.625rem;
        height: 0.125rem;
        border-right: none;
        border-bottom: 2px solid var(${Checkbox.CSS_VAR_PREFIX}checkmark-color);
      }
      
      /* On hover */
      .${Checkbox.BASE_CHECKBOX_CLASS}-container:hover .${Checkbox.BASE_CHECKBOX_CLASS}:not(.${Checkbox.BASE_CHECKBOX_CLASS}--checked):not(.${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate) {
        border-color: var(${Checkbox.CSS_VAR_PREFIX}hover-border);
        background-color: var(${Checkbox.CSS_VAR_PREFIX}hover-bg);
      }
      
      /* On focus */
      .${Checkbox.BASE_CHECKBOX_CLASS}-container:focus-within .${Checkbox.BASE_CHECKBOX_CLASS} {
        box-shadow: 0 0 0 3px var(${Checkbox.CSS_VAR_PREFIX}focus-shadow);
      }
      
      /* Label styles */
      .${Checkbox.BASE_CHECKBOX_CLASS}-label {
        margin-left: 0.5rem;
        font-size: 0.875rem;
      }
      
      /* Checkbox sizes */
      .${Checkbox.BASE_CHECKBOX_CLASS}--small {
        width: 1rem;
        height: 1rem;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--small::after {
        width: 0.25rem;
        height: 0.5rem;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--large {
        width: 1.5rem;
        height: 1.5rem;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--large::after {
        width: 0.375rem;
        height: 0.75rem;
      }
    `, 'userscripts-checkbox-styles');

        Checkbox.stylesInitialized = true;
      }
      /**
         * Inject default color variables for the checkbox component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
      static useDefaultColors() {
        const styleId = 'userscripts-checkbox-default-colors';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          HTMLUtils.setHTMLSafely(style, `
        :root {
          /* Default state */
          ${Checkbox.CSS_VAR_PREFIX}bg: #ffffff;
          ${Checkbox.CSS_VAR_PREFIX}border-color: #d1d5db;
          ${Checkbox.CSS_VAR_PREFIX}hover-bg: #f3f4f6;
          ${Checkbox.CSS_VAR_PREFIX}hover-border: #9ca3af;
          
          /* Checked state */
          ${Checkbox.CSS_VAR_PREFIX}checked-bg: #3b82f6;
          ${Checkbox.CSS_VAR_PREFIX}checked-border: #3b82f6;
          ${Checkbox.CSS_VAR_PREFIX}checkmark-color: #ffffff;
          
          /* Focus state */
          ${Checkbox.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.3);
        }

        @media (prefers-color-scheme: dark) {
          :root {
            /* Default state */
            ${Checkbox.CSS_VAR_PREFIX}bg: #2d2d2d;
            ${Checkbox.CSS_VAR_PREFIX}border-color: #555;
            ${Checkbox.CSS_VAR_PREFIX}hover-bg: #4a4a4a;
            ${Checkbox.CSS_VAR_PREFIX}hover-border: #777;

            /* Checked state */
            ${Checkbox.CSS_VAR_PREFIX}checked-bg: #3b82f6;
            ${Checkbox.CSS_VAR_PREFIX}checked-border: #3b82f6;
            ${Checkbox.CSS_VAR_PREFIX}checkmark-color: #ffffff;

            /* Focus state */
            ${Checkbox.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.4);
          }
        }
      `);
          document.head.appendChild(style);
        }
      }
      /**
         * Create a new Checkbox.
         * @param {Object} options - Configuration options.
         * @param {String} [options.label] - Checkbox label text.
         * @param {Boolean} [options.checked=false] - Initial checked state.
         * @param {Boolean} [options.indeterminate=false] - Initial indeterminate state.
         * @param {String} [options.id] - Checkbox ID.
         * @param {String} [options.name] - Input name attribute.
         * @param {Function} [options.onChange] - Change event handler.
         * @param {HTMLElement} [options.container] - Container to append the checkbox to.
         * @param {String} [options.className] - Additional custom CSS class.
         * @param {Boolean} [options.disabled=false] - Disabled state.
         * @param {String} [options.size="medium"] - Checkbox size.
         * @param {Object} [options.attributes={}] - Additional HTML attributes.
         */
      constructor(options = {}) {
        this.label = options.label || '';
        this.checked = options.checked || false;
        this.indeterminate = options.indeterminate || false;
        this.id = options.id;
        this.name = options.name;
        this.onChange = options.onChange;
        this.container = options.container;
        this.customClassName = options.className || '';
        this.disabled = options.disabled || false;
        this.size = options.size || 'medium';
        this.attributes = options.attributes || {};

        // DOM elements references
        this.checkboxContainer = null;
        this.customCheckbox = null;
        this.nativeCheckbox = null;
        this.labelElement = null;

        Checkbox.initStyles();
        this.create();
      }


      /**
         * Create the checkbox UI and, if a container is provided, append it.
         * @return {HTMLElement} The created checkbox container element.
         */
      create() {
        // Create container
        this.checkboxContainer = document.createElement('label');
        this.checkboxContainer.className = `${Checkbox.BASE_CHECKBOX_CLASS}-container`;
        if (this.customClassName) {
          this.checkboxContainer.classList.add(this.customClassName);
        }
        if (this.disabled) {
          this.checkboxContainer.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled`);
        }

        // Create hidden native checkbox for accessibility
        this.nativeCheckbox = document.createElement('input');
        this.nativeCheckbox.type = 'checkbox';
        this.nativeCheckbox.className = `${Checkbox.BASE_CHECKBOX_CLASS}-native`;
        this.nativeCheckbox.checked = this.checked;
        this.nativeCheckbox.indeterminate = this.indeterminate;
        this.nativeCheckbox.disabled = this.disabled;

        if (this.id) this.nativeCheckbox.id = this.id;
        if (this.name) this.nativeCheckbox.name = this.name;

        Object.entries(this.attributes).forEach(([key, value]) => {
          this.nativeCheckbox.setAttribute(key, value);
        });

        // Create custom checkbox visual
        this.customCheckbox = document.createElement('span');
        this.customCheckbox.className = `${Checkbox.BASE_CHECKBOX_CLASS} ${Checkbox.BASE_CHECKBOX_CLASS}--${this.size}`;
        if (this.checked) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        } else if (this.indeterminate) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        }

        // Create label if provided
        if (this.label) {
          this.labelElement = document.createElement('span');
          this.labelElement.className = `${Checkbox.BASE_CHECKBOX_CLASS}-label`;
          this.labelElement.textContent = this.label;
        }

        // Set up event listeners
        this.nativeCheckbox.addEventListener('change', (e) => this.handleChange(e));
        this.nativeCheckbox.addEventListener('focus', () => this.handleFocus());
        this.nativeCheckbox.addEventListener('blur', () => this.handleBlur());

        // Assemble the component
        this.checkboxContainer.appendChild(this.nativeCheckbox);
        this.checkboxContainer.appendChild(this.customCheckbox);
        if (this.labelElement) {
          this.checkboxContainer.appendChild(this.labelElement);
        }

        // Add to container if provided
        if (this.container) {
          this.container.appendChild(this.checkboxContainer);
        }

        // Store reference to instance on DOM element for potential external access
        this.checkboxContainer._checkboxInstance = this;

        return this.checkboxContainer;
      }

      /**
         * Handle change events.
         * @param {Event} e - The change event.
         */
      handleChange(e) {
        this.checked = this.nativeCheckbox.checked;
        this.indeterminate = this.nativeCheckbox.indeterminate;

        if (this.checked) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        } else if (this.indeterminate) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        } else {
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        }

        if (this.onChange) {
          this.onChange(e);
        }
      }

      /**
         * Handle focus events.
         */
      handleFocus() {
        // Additional focus behaviors can be added here if needed
      }

      /**
         * Handle blur events.
         */
      handleBlur() {
        // Additional blur behaviors can be added here if needed
      }

      /**
         * Set the checked state.
         * @param {Boolean} checked - The new checked state.
         */
      setChecked(checked) {
        this.checked = checked;
        this.nativeCheckbox.checked = checked;

        if (checked) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
          this.indeterminate = false;
          this.nativeCheckbox.indeterminate = false;
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        } else {
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        }
      }

      /**
         * Set the indeterminate state.
         * @param {Boolean} indeterminate - The new indeterminate state.
         */
      setIndeterminate(indeterminate) {
        this.indeterminate = indeterminate;
        this.nativeCheckbox.indeterminate = indeterminate;

        if (indeterminate) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        } else {
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        }
      }

      /**
         * Toggle the checked state.
         * @return {Boolean} The new checked state.
         */
      toggle() {
        this.setChecked(!this.checked);
        return this.checked;
      }

      /**
         * Set the disabled state.
         * @param {Boolean} disabled - The new disabled state.
         */
      setDisabled(disabled) {
        this.disabled = disabled;
        this.nativeCheckbox.disabled = disabled;

        if (disabled) {
          this.checkboxContainer.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled`);
        } else {
          this.checkboxContainer.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled`);
        }
      }

      /**
         * Set the label text.
         * @param {String} text - The new label text.
         */
      setLabel(text) {
        this.label = text;

        if (!this.labelElement) {
          this.labelElement = document.createElement('span');
          this.labelElement.className = `${Checkbox.BASE_CHECKBOX_CLASS}-label`;
          this.checkboxContainer.appendChild(this.labelElement);
        }

        this.labelElement.textContent = text;
      }

      /**
         * Change the checkbox size.
         * @param {String} size - The new size (e.g., "small", "medium", "large").
         */
      setSize(size) {
        this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--${this.size}`);
        this.size = size;
        this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--${this.size}`);
      }

      /**
         * Apply a custom CSS class to the checkbox container.
         * @param {String} className - The custom class name.
         */
      setCustomClass(className) {
        if (this.customClassName) {
          this.checkboxContainer.classList.remove(this.customClassName);
        }
        this.customClassName = className;
        if (className) {
          this.checkboxContainer.classList.add(className);
        }
      }

      /**
         * Get the current checked state.
         * @return {Boolean} The current checked state.
         */
      isChecked() {
        return this.checked;
      }

      /**
         * Get the current indeterminate state.
         * @return {Boolean} The current indeterminate state.
         */
      isIndeterminate() {
        return this.indeterminate;
      }

      /**
         * Get the current disabled state.
         * @return {Boolean} The current disabled state.
         */
      isDisabled() {
        return this.disabled;
      }

      /**
         * Shows or hides the entire checkbox.
         * @param {Boolean} visible - True to show, false to hide.
         */
      setVisible(visible) {
        if (this.checkboxContainer) {
          this.checkboxContainer.style.display = visible ? '' : 'none';
        }
      }

      /**
         * Destroys the checkbox and removes it from the DOM.
         */
      destroy() {
        if (this.checkboxContainer && this.checkboxContainer.parentNode) {
          this.checkboxContainer.parentNode.removeChild(this.checkboxContainer);
        }
        this.checkboxContainer = null;
        this.customCheckbox = null;
        this.nativeCheckbox = null;
        this.labelElement = null;
      }
    }

    // Static property to track if styles have been initialized.
    Checkbox.stylesInitialized = false;
    Checkbox.initStyles();

    /**
     * SidebarPanel - A reusable UI component for creating a sidebar panel with a trigger button
     * Similar to Wallapop's help button that shifts the site content
     */

    /**
     * A reusable component that creates a toggle button and sidebar panel
     */
    class SidebarPanel {
        // Panel states
        static PANEL_STATES = {
            OPENED: 'opened',
            CLOSED: 'closed'
        };

        // Panel positions
        static PANEL_POSITIONS = {
            RIGHT: 'right',
            LEFT: 'left'
        };

        // Panel transitions
        static PANEL_TRANSITIONS = {
            SLIDE: 'slide',
            PUSH: 'push'
        };

        // GM storage keys
        static STORAGE_KEYS = {
            PANEL_STATE: 'sidebar-panel-state',
            PANEL_SETTINGS: 'sidebar-panel-settings'
        };

        // PubSub events
        static EVENTS = {
            PANEL_OPEN: 'sidebar-panel-open',
            PANEL_CLOSE: 'sidebar-panel-close',
            PANEL_TOGGLE: 'sidebar-panel-toggle',
            PANEL_INITIALIZED: 'sidebar-panel-initialized'
        };

        /**
         * Create a new SidebarPanel.
         * @param {Object} options - Configuration options.
         * @param {String} options.title - Panel title.
         * @param {String} [options.id="sidebar-panel"] - Unique ID for the panel.
         * @param {String} [options.position="right"] - Position of the panel ("right" or "left").
         * @param {String} [options.transition="slide"] - Transition effect ("slide" or "push").
         * @param {String} [options.buttonIcon="?"] - HTML content for the toggle button.
         * @param {Boolean} [options.showButton=true] - Whether to show the toggle button.
         * @param {String} [options.namespace="userscripts"] - Namespace for CSS classes.
         * @param {Function} [options.onOpen=null] - Callback when panel opens.
         * @param {Function} [options.onClose=null] - Callback when panel closes.
         * @param {Boolean} [options.overlay=true] - Whether to show an overlay behind the panel.
         * @param {Object} [options.content={}] - Content configuration.
         * @param {String|HTMLElement} [options.content.html=null] - HTML content for the panel.
         * @param {Function} [options.content.generator=null] - Function that returns content.
         * @param {Boolean} [options.rememberState=true] - Whether to remember the panel state.
         * @param {Object} [options.style={}] - Custom style options.
         * @param {String} [options.style.width="320px"] - Panel width.
         * @param {String} [options.style.buttonSize="48px"] - Button size.
         * @param {String} [options.style.buttonColor="#fff"] - Button text color.
         * @param {String} [options.style.buttonBg="#625df5"] - Button background color.
         * @param {String} [options.style.panelBg="#fff"] - Panel background color.
         */
        constructor(options = {}) {
            // Process and store options with defaults
            this.options = {
                title: options.title || 'Panel',
                id: options.id || 'sidebar-panel',
                position: options.position || SidebarPanel.PANEL_POSITIONS.RIGHT,
                transition: options.transition || SidebarPanel.PANEL_TRANSITIONS.SLIDE,
                buttonIcon: options.buttonIcon || '?',
                showButton: options.showButton !== false,
                namespace: options.namespace || 'userscripts',
                onOpen: options.onOpen || null,
                onClose: options.onClose || null,
                overlay: options.overlay !== false,
                content: options.content || {},
                rememberState: options.rememberState !== false,
                style: options.style || {}
            };

            // Default styles
            this.options.style = {
                buttonColor: '#fff',
                buttonBg: '#625df5',
                panelBg: '#fff',
                ...options.style
            };

            // Setup base class names based on namespace
            this.baseClass = `${this.options.namespace}-sidebar-panel`;
            this.cssVarPrefix = `--${this.options.namespace}-sidebar-panel-`;

            // Elements references
            this.container = null;
            this.panel = null;
            this.button = null;
            this.closeButton = null;
            this.content = null;
            this.header = null;
            this.footer = null;
            this.overlay = null;

            // Panel state
            this.state = this.getSavedState() || SidebarPanel.PANEL_STATES.CLOSED;

            // Storage key for this specific panel instance
            this.storageKey = `${SidebarPanel.STORAGE_KEYS.PANEL_STATE}-${this.options.id}`;
        }

        /**
         * Initialize the styles for the SidebarPanel
         * @param {String} namespace - Optional namespace to prevent CSS collisions
         */
        static initStyles(namespace = 'userscripts') {
            const baseClass = `${namespace}-sidebar-panel`;
            const cssVarPrefix = `--${namespace}-sidebar-panel-`;

            StyleManager.addStyles(`
            /* Base styles for the sidebar panel */
            .${baseClass}-container {
                position: fixed;
                top: 0;
                height: 100%;
                z-index: 9998;
                transition: transform 0.3s ease-in-out;
            }
            
            .${baseClass}-container--right {
                right: 0;
                transform: translateX(100%);
            }
            
            .${baseClass}-container--left {
                left: 0;
                transform: translateX(-100%);
            }
            
            .${baseClass}-container--opened {
                transform: translateX(0);
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            }
            
            .${baseClass} {
                width: var(${cssVarPrefix}width, 320px);
                height: 100%;
                background-color: var(${cssVarPrefix}bg, #fff);
                display: flex;
                flex-direction: column;
                overflow: hidden;
                position: relative;
            }
            
            .${baseClass}-header {
                padding: 16px;
                background-color: var(${cssVarPrefix}header-bg, #f5f5f5);
                border-bottom: 1px solid var(${cssVarPrefix}border-color, #eee);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .${baseClass}-title {
                font-weight: bold;
                font-size: 18px;
                color: var(${cssVarPrefix}title-color, #333);
                margin: 0;
            }
            
            .${baseClass}-close {
                background: none;
                border: none;
                cursor: pointer;
                font-size: 24px;
                line-height: 24px;
                padding: 0;
                width: 24px;
                height: 24px;
                color: var(${cssVarPrefix}close-color, #777);
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .${baseClass}-close:hover {
                color: var(${cssVarPrefix}close-color-hover, #333);
            }
            
            .${baseClass}-content {
                flex: 1;
                overflow-y: auto;
                padding: 16px;
            }
            
            .${baseClass}-footer {
                padding: 16px;
                background-color: var(${cssVarPrefix}footer-bg, #f5f5f5);
                border-top: 1px solid var(${cssVarPrefix}border-color, #eee);
            }
            
            /* Toggle button styles */
            .${baseClass}-toggle {
                position: fixed;
                width: var(${cssVarPrefix}button-size, 48px);
                height: var(${cssVarPrefix}button-size, 48px);
                border-radius: 50%;
                background-color: var(${cssVarPrefix}button-bg, #625df5);
                color: var(${cssVarPrefix}button-color, #fff);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                z-index: 9999;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                border: none;
                outline: none;
                transition: background-color 0.2s ease, transform 0.2s ease;
            }
            
            .${baseClass}-toggle:hover {
                background-color: var(${cssVarPrefix}button-bg-hover, #514dc6);
                transform: scale(1.05);
            }
            
            .${baseClass}-toggle--right {
                right: 20px;
                bottom: 20px;
            }
            
            .${baseClass}-toggle--left {
                left: 20px;
                bottom: 20px;
            }
            
            /* For push transition effect */
            body.${baseClass}-push-active--right {
                transition: margin-left 0.3s ease-in-out;
            }
            
            body.${baseClass}-push-active--right.${baseClass}-push--opened {
                margin-left: calc(-1 * var(${cssVarPrefix}width, 320px));
            }
            
            body.${baseClass}-push-active--left {
                transition: margin-right 0.3s ease-in-out;
            }
            
            body.${baseClass}-push-active--left.${baseClass}-push--opened {
                margin-right: calc(-1 * var(${cssVarPrefix}width, 320px));
            }
            
            /* Overlay for slide transition */
            .${baseClass}-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 9997;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            }
            
            .${baseClass}-overlay--visible {
                opacity: 1;
                visibility: visible;
            }
            
            /* Responsive styles */
            @media (max-width: 768px) {
                .${baseClass} {
                    width: 85vw;
                }
            }

            .${baseClass}-footer-content {
                /* Add any specific footer content styling here */
            }

            @media (prefers-color-scheme: dark) {
                .${baseClass} {
                    background-color: var(${cssVarPrefix}bg, #2d2d2d);
                }

                .${baseClass}-header {
                    background-color: #3a3a3a;
                    border-bottom-color: #444;
                }

                .${baseClass}-title {
                    color: #e0e0e0;
                }

                .${baseClass}-close {
                    color: #aaa;
                }

                .${baseClass}-close:hover {
                    color: #fff;
                }

                .${baseClass}-footer {
                    background-color: #3a3a3a;
                    border-top-color: #444;
                }

                .${baseClass}-overlay {
                    background-color: rgba(0, 0, 0, 0.7);
                }

                .${baseClass}-toggle {
                    background-color: var(${cssVarPrefix}button-bg, #3b82f6);
                }

                .${baseClass}-toggle:hover {
                    background-color: var(${cssVarPrefix}button-bg-hover, #2563eb);
                }
            }
        `, `sidebar-panel-styles-${namespace}`);
        }

        /**
         * Initialize the panel
         */
        async init() {
            // Ensure styles are initialized only once
            if (!document.head.dataset.sidebarPanelStylesInitialized) {
            SidebarPanel.initStyles(this.options.namespace);
                document.head.dataset.sidebarPanelStylesInitialized = 'true';
            }

            // Apply any custom styles from options
            this.applyCustomStyles();

            // Create UI elements
            await this.createPanel();
            if (this.options.showButton) {
                this.createToggleButton();
            }
            if (this.options.overlay && this.options.transition === 'slide') {
                this.createOverlay();
            }

            // Setup event listeners
            this.setupEvents();

            // Set initial state without animation
                if (this.state === SidebarPanel.PANEL_STATES.OPENED) {
                this.open(false);
            }

            // Publish initialized event
            PubSub.publish(SidebarPanel.EVENTS.PANEL_INITIALIZED, this);
            Logger.debug(`SidebarPanel initialized: ${this.options.id}`);
        }

        /**
         * Apply custom styles from options
         */
        applyCustomStyles() {
            const customStyles = {};

            // Process style options
            if (this.options.style.width) {
                customStyles[`${this.cssVarPrefix}width`] = this.options.style.width;
            }
            if (this.options.style.buttonSize) {
                customStyles[`${this.cssVarPrefix}button-size`] = this.options.style.buttonSize;
            }
            if (this.options.style.buttonColor) {
                customStyles[`${this.cssVarPrefix}button-color`] = this.options.style.buttonColor;
            }
            if (this.options.style.buttonBg) {
                customStyles[`${this.cssVarPrefix}button-bg`] = this.options.style.buttonBg;
            }
            if (this.options.style.buttonBgHover) {
                customStyles[`${this.cssVarPrefix}button-bg-hover`] = this.options.style.buttonBgHover;
            }
            if (this.options.style.panelBg) {
                customStyles[`${this.cssVarPrefix}bg`] = this.options.style.panelBg;
            }

            // Apply the CSS variables using StyleManager
            if (Object.keys(customStyles).length > 0) {
                const styleId = `${this.baseClass}-custom-${this.options.id}`;
                let cssText = `:root {\n`;

                for (const [key, value] of Object.entries(customStyles)) {
                    cssText += `  ${key}: ${value};\n`;
                }

                cssText += `}\n`;
                StyleManager.addStyles(cssText, styleId);
            }
        }

        /**
         * Creates and configures the main panel element
         */
        async createPanel() {
            this.container = document.createElement('div');
            this.container.id = this.options.id;
            this.container.className = `${this.baseClass}-container ${this.baseClass}-container--${this.options.position}`;

            this.panel = document.createElement('div');
            this.panel.className = this.baseClass;

            // Create header with title and close button
            this.header = document.createElement('div');
            this.header.className = `${this.baseClass}-header`;

            const titleElement = document.createElement('h2');
            titleElement.className = `${this.baseClass}-title`;
            titleElement.textContent = this.options.title;

            this.closeButton = document.createElement('button');
            this.closeButton.className = `${this.baseClass}-close`;
            HTMLUtils.setHTMLSafely(this.closeButton, '&times;');
            this.closeButton.setAttribute('aria-label', 'Close Panel');

            this.header.appendChild(titleElement);
            this.header.appendChild(this.closeButton);

            // Create content area
            this.content = document.createElement('div');
            this.content.className = `${this.baseClass}-content`;

            // Populate content
            await this.setContent(this.options.content);

            // Create footer if provided
            if (this.options.content.footer) {
                this.footer = document.createElement('div');
                this.footer.className = `${this.baseClass}-footer`;
                HTMLUtils.setHTMLSafely(this.footer, this.options.content.footer);
            }

            // Assemble panel
            this.panel.appendChild(this.header);
            this.panel.appendChild(this.content);
            if (this.footer) {
                this.panel.appendChild(this.footer);
            }

            this.container.appendChild(this.panel);

            // Add panel to the DOM
            document.body.appendChild(this.container);
            Logger.debug('Panel created and added to DOM');
        }

        /**
         * Create toggle button
         */
        createToggleButton() {
            if (!this.options.showButton) return;
            this.button = document.createElement('button');
            this.button.className = `${this.baseClass}-toggle ${this.baseClass}-toggle--${this.options.position}`;
            HTMLUtils.setHTMLSafely(this.button, this.options.buttonIcon);
            this.button.setAttribute('aria-label', 'Toggle Panel');
            document.body.appendChild(this.button);
        }

        /**
         * Create overlay element
         */
        createOverlay() {
            this.overlay = document.createElement('div');
            this.overlay.className = `${this.baseClass}-overlay`;
            document.body.appendChild(this.overlay);
        }

        /**
         * Set up event listeners
         */
        setupEvents() {
            // Toggle button click
            if (this.button) {
                this.button.addEventListener('click', () => this.toggle());
            }

            // Close button click
            if (this.closeButton) {
                this.closeButton.addEventListener('click', () => this.close());
            }

            // Overlay click
            if (this.overlay) {
                this.overlay.addEventListener('click', () => this.close());
            }

            // Listen for PubSub events
            this.subscriptions = [
                PubSub.subscribe(`${SidebarPanel.EVENTS.PANEL_OPEN}-${this.options.id}`, () => this.open()),
                PubSub.subscribe(`${SidebarPanel.EVENTS.PANEL_CLOSE}-${this.options.id}`, () => this.close()),
                PubSub.subscribe(`${SidebarPanel.EVENTS.PANEL_TOGGLE}-${this.options.id}`, () => this.toggle())
            ];

            // ESC key to close
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.state === SidebarPanel.PANEL_STATES.OPENED) {
                    this.close();
                }
            });
        }

        /**
         * Toggle panel state
         */
        toggle() {
            if (this.state === SidebarPanel.PANEL_STATES.CLOSED) {
                this.open();
            } else {
                this.close();
            }
        }

        /**
         * Open the panel
         * @param {Boolean} animate - Whether to animate the opening
         */
        open(animate = true) {
            if (this.state === SidebarPanel.PANEL_STATES.OPENED) return;

            this.state = SidebarPanel.PANEL_STATES.OPENED;

            // Update panel class
            if (!animate) {
                this.container.style.transition = 'none';
                requestAnimationFrame(() => {
                    this.container.style.transition = '';
                });
            }

            this.container.classList.add(`${this.baseClass}-container--opened`);

            // Handle push transition
            if (this.options.transition === SidebarPanel.PANEL_TRANSITIONS.PUSH) {
                document.body.classList.add(`${this.baseClass}-push-active--${this.options.position}`);
                document.body.classList.add(`${this.baseClass}-push--opened`);
            }

            // Show overlay
            if (this.overlay) {
                this.overlay.classList.add(`${this.baseClass}-overlay--visible`);
            }

            // Save state
            if (this.options.rememberState) {
                this.saveState();
            }

            // Call onOpen callback if provided
            if (typeof this.options.onOpen === 'function') {
                this.options.onOpen();
            }

            // Publish event
            PubSub.publish(SidebarPanel.EVENTS.PANEL_OPEN, {
                id: this.options.id,
                panel: this
            });

            Logger.debug(`SidebarPanel opened: ${this.options.id}`);
        }

        /**
         * Close the panel
         */
        close() {
            if (this.state === SidebarPanel.PANEL_STATES.CLOSED) return;

            this.state = SidebarPanel.PANEL_STATES.CLOSED;

            // Update panel class
            this.container.classList.remove(`${this.baseClass}-container--opened`);

            // Handle push transition
            if (this.options.transition === SidebarPanel.PANEL_TRANSITIONS.PUSH) {
                document.body.classList.remove(`${this.baseClass}-push--opened`);
                // We keep the active class for transition
                setTimeout(() => {
                    if (this.state === SidebarPanel.PANEL_STATES.CLOSED) {
                        document.body.classList.remove(`${this.baseClass}-push-active--${this.options.position}`);
                    }
                }, 300); // Match transition duration
            }

            // Hide overlay
            if (this.overlay) {
                this.overlay.classList.remove(`${this.baseClass}-overlay--visible`);
            }

            // Save state
            if (this.options.rememberState) {
                this.saveState();
            }

            // Call onClose callback if provided
            if (typeof this.options.onClose === 'function') {
                this.options.onClose();
            }

            // Publish event
            PubSub.publish(SidebarPanel.EVENTS.PANEL_CLOSE, {
                id: this.options.id,
                panel: this
            });

            Logger.debug(`SidebarPanel closed: ${this.options.id}`);
        }

        /**
         * Get saved panel state from GM storage
         * @return {String|null} Panel state or null if not found
         */
        async getSavedState() {
            if (!this.options.rememberState) return null;

            try {
                // Use directly imported getValue
                const savedState = await getValue(this.storageKey, SidebarPanel.PANEL_STATES.CLOSED);
                // Validate state
                if (Object.values(SidebarPanel.PANEL_STATES).includes(savedState)) {
                    Logger.debug('Retrieved saved panel state:', savedState, 'for key:', this.storageKey);
                    return savedState;
                }
                Logger.warn('Invalid saved panel state retrieved:', savedState, 'for key:', this.storageKey);
            } catch (error) {
                Logger.error('Error retrieving saved panel state:', error, 'for key:', this.storageKey);
            }
            return SidebarPanel.PANEL_STATES.CLOSED; // Default to closed on error or invalid
        }

        /**
         * Save the current panel state (opened/closed) if rememberState is enabled.
         */
        async saveState() {
            if (!this.options.rememberState) return;

            try {
                // Use directly imported setValue
                await setValue(this.storageKey, this.state);
                Logger.debug('Saved panel state:', this.state, 'for key:', this.storageKey);
            } catch (error) {
                Logger.error('Error saving panel state:', error, 'for key:', this.storageKey);
            }
        }

        /**
         * @param {Object} contentConfig - Content configuration object
         */
        async setContent(contentConfig) {
            if (!this.content) return;
            this.content.textContent = ''; // Clearing content safely

            if (contentConfig.html) {
                if (typeof contentConfig.html === 'string') {
                    HTMLUtils.setHTMLSafely(this.content, contentConfig.html);
                } else if (contentConfig.html instanceof HTMLElement) {
                    this.content.appendChild(contentConfig.html);
                }
            } else if (typeof contentConfig.generator === 'function') {
                const generatedContent = await contentConfig.generator();
                if (typeof generatedContent === 'string') {
                    HTMLUtils.setHTMLSafely(this.content, generatedContent);
                } else if (generatedContent instanceof HTMLElement) {
                    this.content.appendChild(generatedContent);
                }
            }
            Logger.debug('Panel content updated');
        }

        /**
         * Set panel title
         * @param {String} title - New title text
         */
        setTitle(title) {
            const titleElement = this.header ? this.header.querySelector(`.${this.baseClass}-title`) : null;
            if (titleElement) {
                titleElement.textContent = title;
                this.options.title = title;
            }
        }

        /**
         * Set button icon
         * @param {String} iconHtml - Text content for icon (no HTML allowed for CSP compliance)
         */
        setButtonIcon(iconHtml) {
            if (this.button) {
                HTMLUtils.setHTMLSafely(this.button, iconHtml);
                this.options.buttonIcon = iconHtml;
            }
        }

        /**
         * Destroy the panel and clean up
         */
        destroy() {
            // Remove DOM elements
            if (this.container && this.container.parentNode) {
                this.container.parentNode.removeChild(this.container);
            }

            if (this.button && this.button.parentNode) {
                this.button.parentNode.removeChild(this.button);
            }

            if (this.overlay && this.overlay.parentNode) {
                this.overlay.parentNode.removeChild(this.overlay);
            }

            // Remove body classes
            document.body.classList.remove(`${this.baseClass}-push-active--${this.options.position}`);
            document.body.classList.remove(`${this.baseClass}-push--opened`);

            // Unsubscribe from PubSub events
            if (this.subscriptions) {
                this.subscriptions.forEach(subscriptionId => {
                    PubSub.unsubscribe(subscriptionId);
                });
            }

            Logger.debug(`SidebarPanel destroyed: ${this.options.id}`);
        }
    }

    /**
     * Input - A reusable input field component with theming and validation
     * Provides consistent styling and behavior across userscripts
     */

    class Input {
        static BASE_INPUT_CLASS = 'userscript-input';
        static THEMES = {
            default: 'default',
            primary: 'primary',
            success: 'success',
            warning: 'warning',
            danger: 'danger'
        };
        static SIZES = {
            small: 'small',
            medium: 'medium',
            large: 'large'
        };

        /**
         * Initialize default styles for Input components
         */
        static initStyles(options = {}) {
            const { scopeSelector = '' } = options;
            const styleId = `input-component${scopeSelector ? '-' + scopeSelector.replace(/[^a-zA-Z0-9]/g, '') : ''}`;

            if (StyleManager.hasStyles(styleId)) {
                return;
            }

            const selectorPrefix = scopeSelector ? `${scopeSelector} ` : '';

            const styles = `
            ${selectorPrefix}.${Input.BASE_INPUT_CLASS} {
                position: relative;
                display: inline-block;
                width: 100%;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-field {
                width: 100%;
                padding: 8px 12px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                font-size: 14px;
                box-sizing: border-box;
                transition: all 0.2s ease;
                background: #fff;
                color: #222;
                outline: none;
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #4285f4;
                box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-field:disabled {
                background: #f0f0f0;
                color: #888;
                cursor: not-allowed;
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-field::placeholder {
                color: #222;
                opacity: 0.7;
            }

            /* Themes */
            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--primary .${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #4285f4;
                box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--success .${Input.BASE_INPUT_CLASS}-field {
                border-color: #28a745;
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--success .${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #28a745;
                box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2);
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--warning .${Input.BASE_INPUT_CLASS}-field {
                border-color: #ffc107;
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--warning .${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #ffc107;
                box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.2);
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--danger .${Input.BASE_INPUT_CLASS}-field {
                border-color: #dc3545;
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--danger .${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #dc3545;
                box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.2);
            }

            /* Sizes */
            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--small .${Input.BASE_INPUT_CLASS}-field {
                padding: 6px 10px;
                font-size: 12px;
            }

            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--large .${Input.BASE_INPUT_CLASS}-field {
                padding: 12px 16px;
                font-size: 16px;
            }

            /* Label */
            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-label {
                display: block;
                margin-bottom: 4px;
                font-size: 13px;
                font-weight: 500;
                color: #333;
            }

            /* Error message */
            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-error {
                display: block;
                margin-top: 4px;
                font-size: 12px;
                color: #dc3545;
            }

            /* Helper text */
            ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-helper {
                display: block;
                margin-top: 4px;
                font-size: 12px;
                color: #666;
            }

            /* Dark theme */
            @media (prefers-color-scheme: dark) {
                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-field {
                    background: #2d2d2d;
                    color: #e0e0e0;
                    border-color: #555;
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-field:focus {
                    border-color: #4285f4;
                    box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-field:disabled {
                    background: #444;
                    color: #888;
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-field::placeholder {
                    color: #e0e0e0;
                    opacity: 0.5;
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-label {
                    color: #e0e0e0;
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}-helper {
                    color: #aaa;
                }

                /* Themes in dark mode */
                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--primary .${Input.BASE_INPUT_CLASS}-field:focus {
                    border-color: #4285f4;
                    box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--success .${Input.BASE_INPUT_CLASS}-field {
                    background-color: #2d2d2d;
                    color: #e0e0e0;
                    border-color: #28a745;
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--success .${Input.BASE_INPUT_CLASS}-field:focus {
                    box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.3);
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--warning .${Input.BASE_INPUT_CLASS}-field {
                     background-color: #2d2d2d;
                    color: #e0e0e0;
                    border-color: #ffc107;
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--warning .${Input.BASE_INPUT_CLASS}-field:focus {
                    box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.3);
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--danger .${Input.BASE_INPUT_CLASS}-field {
                     background-color: #2d2d2d;
                    color: #e0e0e0;
                    border-color: #dc3545;
                }

                ${selectorPrefix}.${Input.BASE_INPUT_CLASS}--danger .${Input.BASE_INPUT_CLASS}-field:focus {
                    box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.3);
                }
            }
        `;

            StyleManager.addStyles(styles, styleId);
        }

        /**
         * Use default color scheme
         */
        static useDefaultColors() {
            // Colors are already defined in initStyles
            // This method exists for API consistency with other components
        }

        /**
         * Create a new Input instance
         * @param {Object} options - Configuration options
         * @param {string} [options.type='text'] - Input type (text, number, email, password, etc.)
         * @param {string} [options.value=''] - Initial value
         * @param {string} [options.placeholder=''] - Placeholder text
         * @param {string} [options.label=''] - Label text
         * @param {string} [options.helperText=''] - Helper text
         * @param {string} [options.theme='default'] - Theme (default, primary, success, warning, danger)
         * @param {string} [options.size='medium'] - Size (small, medium, large)
         * @param {boolean} [options.disabled=false] - Whether input is disabled
         * @param {boolean} [options.required=false] - Whether input is required
         * @param {string} [options.min] - Minimum value (for number inputs)
         * @param {string} [options.max] - Maximum value (for number inputs)
         * @param {string} [options.step] - Step value (for number inputs)
         * @param {Function} [options.onInput] - Input event handler
         * @param {Function} [options.onChange] - Change event handler
         * @param {Function} [options.onFocus] - Focus event handler
         * @param {Function} [options.onBlur] - Blur event handler
         * @param {Function} [options.validator] - Custom validation function
         * @param {HTMLElement} [options.container] - Container to append to
         * @param {string} [options.className] - Additional CSS class
         * @param {Object} [options.attributes={}] - HTML attributes to set on the input element (e.g., {autocomplete: 'off'})
         */
        constructor(options = {}) {
            this.options = {
                type: 'text',
                value: '',
                placeholder: '',
                label: '',
                helperText: '',
                theme: Input.THEMES.default,
                size: Input.SIZES.medium,
                disabled: false,
                required: false,
                onInput: null,
                onChange: null,
                onFocus: null,
                onBlur: null,
                validator: null,
                container: null,
                className: '',
                attributes: {},
                ...options
            };

            this.isValid = true;
            this.errorMessage = '';

            Input.initStyles({ scopeSelector: this.options.scopeSelector });
            this.createElement();
            this.setupEventListeners();

            if (this.options.container) {
                this.options.container.appendChild(this.element);
            }
        }

        /**
         * Create the input element structure
         */
        createElement() {
            // Main container
            this.element = document.createElement('div');
            this.element.className = this.buildClassName();

            // Label
            if (this.options.label) {
                this.labelElement = document.createElement('label');
                this.labelElement.className = `${Input.BASE_INPUT_CLASS}-label`;
                this.labelElement.textContent = this.options.label;
                if (this.options.required) {
                    this.labelElement.textContent += ' *';
                }
                this.element.appendChild(this.labelElement);
            }

            // Input field
            this.inputElement = document.createElement('input');
            this.inputElement.type = this.options.type;
            this.inputElement.className = `${Input.BASE_INPUT_CLASS}-field`;
            this.inputElement.value = this.options.value;
            this.inputElement.placeholder = this.options.placeholder;
            this.inputElement.disabled = this.options.disabled;
            this.inputElement.required = this.options.required;

            // Set number-specific attributes
            if (this.options.type === 'number') {
                if (this.options.min !== undefined) {
                    this.inputElement.min = this.options.min;
                }
                if (this.options.max !== undefined) {
                    this.inputElement.max = this.options.max;
                }
                if (this.options.step !== undefined) {
                    this.inputElement.step = this.options.step;
                }
            }

            // Apply custom attributes
            if (this.options.attributes && typeof this.options.attributes === 'object') {
                Object.entries(this.options.attributes).forEach(([key, value]) => {
                    this.inputElement.setAttribute(key, value);
                });
            }

            this.element.appendChild(this.inputElement);

            // Helper text
            if (this.options.helperText) {
                this.helperElement = document.createElement('span');
                this.helperElement.className = `${Input.BASE_INPUT_CLASS}-helper`;
                this.helperElement.textContent = this.options.helperText;
                this.element.appendChild(this.helperElement);
            }

            // Error message container (initially hidden)
            this.errorElement = document.createElement('span');
            this.errorElement.className = `${Input.BASE_INPUT_CLASS}-error`;
            this.errorElement.style.display = 'none';
            this.element.appendChild(this.errorElement);
        }

        /**
         * Setup event listeners
         */
        setupEventListeners() {
            if (this.options.onInput) {
                this.inputElement.addEventListener('input', (e) => {
                    this.validate();
                    this.options.onInput(e, this);
                });
            } else {
                this.inputElement.addEventListener('input', () => {
                    this.validate();
                });
            }

            if (this.options.onChange) {
                this.inputElement.addEventListener('change', (e) => {
                    this.validate();
                    this.options.onChange(e, this);
                });
            }

            if (this.options.onFocus) {
                this.inputElement.addEventListener('focus', (e) => {
                    this.options.onFocus(e, this);
                });
            }

            if (this.options.onBlur) {
                this.inputElement.addEventListener('blur', (e) => {
                    this.validate();
                    this.options.onBlur(e, this);
                });
            }
        }

        /**
         * Build CSS class name
         */
        buildClassName() {
            const classes = [Input.BASE_INPUT_CLASS];
            
            if (this.options.theme && this.options.theme !== Input.THEMES.default) {
                classes.push(`${Input.BASE_INPUT_CLASS}--${this.options.theme}`);
            }
            
            if (this.options.size && this.options.size !== Input.SIZES.medium) {
                classes.push(`${Input.BASE_INPUT_CLASS}--${this.options.size}`);
            }
            
            if (this.options.className) {
                classes.push(this.options.className);
            }
            
            return classes.join(' ');
        }

        /**
         * Validate input value
         */
        validate() {
            this.isValid = true;
            this.errorMessage = '';

            // Required validation
            if (this.options.required && !this.inputElement.value.trim()) {
                this.isValid = false;
                this.errorMessage = 'This field is required';
            }

            // Custom validation
            if (this.isValid && this.options.validator) {
                const validationResult = this.options.validator(this.inputElement.value, this);
                if (validationResult !== true) {
                    this.isValid = false;
                    this.errorMessage = validationResult || 'Invalid value';
                }
            }

            // Update error display
            this.updateErrorDisplay();
            return this.isValid;
        }

        /**
         * Update error message display
         */
        updateErrorDisplay() {
            if (!this.isValid && this.errorMessage) {
                this.errorElement.textContent = this.errorMessage;
                this.errorElement.style.display = 'block';
                this.setTheme(Input.THEMES.danger);
            } else {
                this.errorElement.style.display = 'none';
                this.setTheme(this.options.theme);
            }
        }

        /**
         * Get current value
         */
        getValue() {
            return this.inputElement.value;
        }

        /**
         * Set value
         */
        setValue(value) {
            this.inputElement.value = value;
            this.validate();
        }

        /**
         * Set theme
         */
        setTheme(theme) {
            // Remove existing theme classes
            Object.values(Input.THEMES).forEach(t => {
                if (t !== Input.THEMES.default) {
                    this.element.classList.remove(`${Input.BASE_INPUT_CLASS}--${t}`);
                }
            });

            // Add new theme class
            if (theme && theme !== Input.THEMES.default) {
                this.element.classList.add(`${Input.BASE_INPUT_CLASS}--${theme}`);
            }
        }

        /**
         * Set disabled state
         */
        setDisabled(disabled) {
            this.options.disabled = disabled;
            this.inputElement.disabled = disabled;
        }

        /**
         * Focus the input
         */
        focus() {
            this.inputElement.focus();
        }

        /**
         * Blur the input
         */
        blur() {
            this.inputElement.blur();
        }

        /**
         * Get the DOM element
         */
        getElement() {
            return this.element;
        }

        /**
         * Destroy the input and clean up
         */
        destroy() {
            if (this.element && this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
        }
    }

    /**
     * TextArea - A reusable textarea component with theming and validation
     * Provides consistent styling and behavior across userscripts
     */

    class TextArea {
        static BASE_TEXTAREA_CLASS = 'userscript-textarea';
        static THEMES = {
            default: 'default',
            primary: 'primary',
            success: 'success',
            warning: 'warning',
            danger: 'danger'
        };
        static SIZES = {
            small: 'small',
            medium: 'medium',
            large: 'large'
        };

        /**
         * Initialize default styles for TextArea components
         */
        static initStyles(options = {}) {
            const { scopeSelector = '' } = options;
            const styleId = `textarea-component${scopeSelector ? '-' + scopeSelector.replace(/[^a-zA-Z0-9]/g, '') : ''}`;

            if (StyleManager.hasStyles(styleId)) {
                return;
            }

            const selectorPrefix = scopeSelector ? `${scopeSelector} ` : '';

            const styles = `
            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS} {
                position: relative;
                display: inline-block;
                width: 100%;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-field {
                width: 100%;
                padding: 8px 12px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                font-size: 14px;
                box-sizing: border-box;
                transition: all 0.2s ease;
                background: #fff;
                color: #222;
                outline: none;
                resize: vertical;
                font-family: inherit;
                line-height: 1.4;
                min-height: 80px;
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #4285f4;
                box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-field:disabled {
                background: #f0f0f0;
                color: #888;
                cursor: not-allowed;
                resize: none;
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-field::placeholder {
                color: #222;
                opacity: 0.7;
            }

            /* Themes */
            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--primary .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #4285f4;
                box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--success .${TextArea.BASE_TEXTAREA_CLASS}-field {
                border-color: #28a745;
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--success .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #28a745;
                box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2);
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--warning .${TextArea.BASE_TEXTAREA_CLASS}-field {
                border-color: #ffc107;
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--warning .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #ffc107;
                box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.2);
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--danger .${TextArea.BASE_TEXTAREA_CLASS}-field {
                border-color: #dc3545;
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--danger .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #dc3545;
                box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.2);
            }

            /* Sizes */
            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--small .${TextArea.BASE_TEXTAREA_CLASS}-field {
                padding: 6px 10px;
                font-size: 12px;
                min-height: 60px;
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--large .${TextArea.BASE_TEXTAREA_CLASS}-field {
                padding: 12px 16px;
                font-size: 16px;
                min-height: 120px;
            }

            /* Label */
            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-label {
                display: block;
                margin-bottom: 4px;
                font-size: 13px;
                font-weight: 500;
                color: #333;
            }

            /* Error message */
            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-error {
                display: block;
                margin-top: 4px;
                font-size: 12px;
                color: #dc3545;
            }

            /* Helper text */
            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-helper {
                display: block;
                margin-top: 4px;
                font-size: 12px;
                color: #666;
            }

            /* Character counter */
            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-counter {
                display: block;
                margin-top: 4px;
                font-size: 11px;
                color: #999;
                text-align: right;
            }

            ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-counter--limit-reached {
                color: #dc3545;
            }

            /* Dark theme */
            @media (prefers-color-scheme: dark) {
                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-field {
                    background: #2d2d2d;
                    color: #e0e0e0;
                    border-color: #555;
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                    border-color: #4285f4;
                    box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-field:disabled {
                    background: #444;
                    color: #888;
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-field::placeholder {
                    color: #e0e0e0;
                    opacity: 0.5;
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-label {
                    color: #e0e0e0;
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-helper {
                    color: #aaa;
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}-counter {
                    color: #aaa;
                }

                /* Themes in dark mode */
                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--primary .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                    border-color: #4285f4;
                    box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.3);
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--success .${TextArea.BASE_TEXTAREA_CLASS}-field {
                    background: #2d2d2d;
                    border-color: #28a745;
                    color: #e0e0e0;
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--success .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                    box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.3);
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--warning .${TextArea.BASE_TEXTAREA_CLASS}-field {
                    background: #2d2d2d;
                    border-color: #ffc107;
                    color: #e0e0e0;
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--warning .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                    box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.3);
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--danger .${TextArea.BASE_TEXTAREA_CLASS}-field {
                    background: #2d2d2d;
                    border-color: #dc3545;
                    color: #e0e0e0;
                }

                ${selectorPrefix}.${TextArea.BASE_TEXTAREA_CLASS}--danger .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                    box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.3);
                }
            }
        `;

            StyleManager.addStyles(styles, styleId);
        }

        /**
         * Use default color scheme
         */
        static useDefaultColors() {
            // Colors are already defined in initStyles
            // This method exists for API consistency with other components
        }

        /**
         * Create a new TextArea instance
         * @param {Object} options - Configuration options
         * @param {string} [options.value=''] - Initial value
         * @param {string} [options.placeholder=''] - Placeholder text
         * @param {string} [options.label=''] - Label text
         * @param {string} [options.helperText=''] - Helper text
         * @param {string} [options.theme='default'] - Theme (default, primary, success, warning, danger)
         * @param {string} [options.size='medium'] - Size (small, medium, large)
         * @param {boolean} [options.disabled=false] - Whether textarea is disabled
         * @param {boolean} [options.required=false] - Whether textarea is required
         * @param {number} [options.rows] - Number of rows
         * @param {number} [options.cols] - Number of columns
         * @param {number} [options.maxLength] - Maximum character length
         * @param {boolean} [options.showCounter=false] - Show character counter
         * @param {boolean} [options.autoResize=false] - Auto-resize to content
         * @param {Function} [options.onInput] - Input event handler
         * @param {Function} [options.onChange] - Change event handler
         * @param {Function} [options.onFocus] - Focus event handler
         * @param {Function} [options.onBlur] - Blur event handler
         * @param {Function} [options.validator] - Custom validation function
         * @param {HTMLElement} [options.container] - Container to append to
         * @param {string} [options.className] - Additional CSS class
         * @param {string} [options.scopeSelector] - CSS selector to scope styles
         * @param {Object} [options.attributes={}] - HTML attributes to set on the textarea element (e.g., {autocomplete: 'off'})
         */
        constructor(options = {}) {
            this.options = {
                value: '',
                placeholder: '',
                label: '',
                helperText: '',
                theme: TextArea.THEMES.default,
                size: TextArea.SIZES.medium,
                disabled: false,
                required: false,
                rows: null,
                cols: null,
                maxLength: null,
                showCounter: false,
                autoResize: false,
                onInput: null,
                onChange: null,
                onFocus: null,
                onBlur: null,
                validator: null,
                container: null,
                className: '',
                scopeSelector: '',
                attributes: {},
                ...options
            };

            this.isValid = true;
            this.errorMessage = '';

            TextArea.initStyles({ scopeSelector: this.options.scopeSelector });
            this.createElement();
            this.setupEventListeners();

            if (this.options.container) {
                this.options.container.appendChild(this.element);
            }
        }

        /**
         * Create the textarea element structure
         */
        createElement() {
            // Main container
            this.element = document.createElement('div');
            this.element.className = this.buildClassName();

            // Label
            if (this.options.label) {
                this.labelElement = document.createElement('label');
                this.labelElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-label`;
                this.labelElement.textContent = this.options.label;
                if (this.options.required) {
                    this.labelElement.textContent += ' *';
                }
                this.element.appendChild(this.labelElement);
            }

            // TextArea field
            this.textareaElement = document.createElement('textarea');
            this.textareaElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-field`;
            this.textareaElement.value = this.options.value;
            this.textareaElement.placeholder = this.options.placeholder;
            this.textareaElement.disabled = this.options.disabled;
            this.textareaElement.required = this.options.required;

            // Set rows and cols if specified
            if (this.options.rows) {
                this.textareaElement.rows = this.options.rows;
            }
            if (this.options.cols) {
                this.textareaElement.cols = this.options.cols;
            }
            if (this.options.maxLength) {
                this.textareaElement.maxLength = this.options.maxLength;
            }

            // Apply custom attributes
            if (this.options.attributes && typeof this.options.attributes === 'object') {
                Object.entries(this.options.attributes).forEach(([key, value]) => {
                    this.textareaElement.setAttribute(key, value);
                });
            }

            this.element.appendChild(this.textareaElement);

            // Helper text
            if (this.options.helperText) {
                this.helperElement = document.createElement('span');
                this.helperElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-helper`;
                this.helperElement.textContent = this.options.helperText;
                this.element.appendChild(this.helperElement);
            }

            // Character counter
            if (this.options.showCounter || this.options.maxLength) {
                this.counterElement = document.createElement('span');
                this.counterElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-counter`;
                this.updateCounter();
                this.element.appendChild(this.counterElement);
            }

            // Error message container (initially hidden)
            this.errorElement = document.createElement('span');
            this.errorElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-error`;
            this.errorElement.style.display = 'none';
            this.element.appendChild(this.errorElement);
        }

        /**
         * Setup event listeners
         */
        setupEventListeners() {
            if (this.options.onInput) {
                this.textareaElement.addEventListener('input', (e) => {
                    this.handleInput();
                    this.options.onInput(e, this);
                });
            } else {
                this.textareaElement.addEventListener('input', () => {
                    this.handleInput();
                });
            }

            if (this.options.onChange) {
                this.textareaElement.addEventListener('change', (e) => {
                    this.validate();
                    this.options.onChange(e, this);
                });
            }

            if (this.options.onFocus) {
                this.textareaElement.addEventListener('focus', (e) => {
                    this.options.onFocus(e, this);
                });
            }

            if (this.options.onBlur) {
                this.textareaElement.addEventListener('blur', (e) => {
                    this.validate();
                    this.options.onBlur(e, this);
                });
            }

            // Auto-resize functionality
            if (this.options.autoResize) {
                this.textareaElement.addEventListener('input', () => {
                    this.autoResize();
                });
            }
        }

        /**
         * Handle input events
         */
        handleInput() {
            this.updateCounter();
            this.validate();
            
            if (this.options.autoResize) {
                this.autoResize();
            }
        }

        /**
         * Auto-resize textarea to content
         */
        autoResize() {
            this.textareaElement.style.height = 'auto';
            this.textareaElement.style.height = this.textareaElement.scrollHeight + 'px';
        }

        /**
         * Update character counter
         */
        updateCounter() {
            if (!this.counterElement) return;

            const currentLength = this.textareaElement.value.length;
            let counterText = `${currentLength}`;

            if (this.options.maxLength) {
                counterText += ` / ${this.options.maxLength}`;
                
                // Update counter styling based on limit
                if (currentLength >= this.options.maxLength) {
                    this.counterElement.classList.add(`${TextArea.BASE_TEXTAREA_CLASS}-counter--limit-reached`);
                } else {
                    this.counterElement.classList.remove(`${TextArea.BASE_TEXTAREA_CLASS}-counter--limit-reached`);
                }
            }

            this.counterElement.textContent = counterText;
        }

        /**
         * Build CSS class name
         */
        buildClassName() {
            const classes = [TextArea.BASE_TEXTAREA_CLASS];
            
            if (this.options.theme && this.options.theme !== TextArea.THEMES.default) {
                classes.push(`${TextArea.BASE_TEXTAREA_CLASS}--${this.options.theme}`);
            }
            
            if (this.options.size && this.options.size !== TextArea.SIZES.medium) {
                classes.push(`${TextArea.BASE_TEXTAREA_CLASS}--${this.options.size}`);
            }
            
            if (this.options.className) {
                classes.push(this.options.className);
            }
            
            return classes.join(' ');
        }

        /**
         * Validate textarea value
         */
        validate() {
            this.isValid = true;
            this.errorMessage = '';

            // Required validation
            if (this.options.required && !this.textareaElement.value.trim()) {
                this.isValid = false;
                this.errorMessage = 'This field is required';
            }

            // Max length validation
            if (this.isValid && this.options.maxLength && this.textareaElement.value.length > this.options.maxLength) {
                this.isValid = false;
                this.errorMessage = `Text must not exceed ${this.options.maxLength} characters`;
            }

            // Custom validation
            if (this.isValid && this.options.validator) {
                const validationResult = this.options.validator(this.textareaElement.value, this);
                if (validationResult !== true) {
                    this.isValid = false;
                    this.errorMessage = validationResult || 'Invalid value';
                }
            }

            // Update error display
            this.updateErrorDisplay();
            return this.isValid;
        }

        /**
         * Update error message display
         */
        updateErrorDisplay() {
            if (!this.isValid && this.errorMessage) {
                this.errorElement.textContent = this.errorMessage;
                this.errorElement.style.display = 'block';
                this.setTheme(TextArea.THEMES.danger);
            } else {
                this.errorElement.style.display = 'none';
                this.setTheme(this.options.theme);
            }
        }

        /**
         * Get current value
         */
        getValue() {
            return this.textareaElement.value;
        }

        /**
         * Set value
         */
        setValue(value) {
            this.textareaElement.value = value;
            this.updateCounter();
            this.validate();
            
            if (this.options.autoResize) {
                this.autoResize();
            }
        }

        /**
         * Set theme
         */
        setTheme(theme) {
            // Remove existing theme classes
            Object.values(TextArea.THEMES).forEach(t => {
                if (t !== TextArea.THEMES.default) {
                    this.element.classList.remove(`${TextArea.BASE_TEXTAREA_CLASS}--${t}`);
                }
            });

            // Add new theme class
            if (theme && theme !== TextArea.THEMES.default) {
                this.element.classList.add(`${TextArea.BASE_TEXTAREA_CLASS}--${theme}`);
            }
        }

        /**
         * Set disabled state
         */
        setDisabled(disabled) {
            this.options.disabled = disabled;
            this.textareaElement.disabled = disabled;
        }

        /**
         * Focus the textarea
         */
        focus() {
            this.textareaElement.focus();
        }

        /**
         * Blur the textarea
         */
        blur() {
            this.textareaElement.blur();
        }

        /**
         * Get the DOM element
         */
        getElement() {
            return this.element;
        }

        /**
         * Destroy the textarea and clean up
         */
        destroy() {
            if (this.element && this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
        }
    }

    /**
     * Tabs - A reusable UI component for tabbed interfaces.
     * Creates accessible, customizable tabs with content panels.
     */

    /**
     * A reusable UI component for creating accessible, customizable tabs.
     */
    class Tabs {
      /**
       * Returns the unique base CSS class for the Tabs component.
       * @return {string} The base CSS class name for tabs.
       */
      static get BASE_TABS_CLASS() {
        return 'userscripts-tabs';
      }

      /**
       * Returns the CSS variable prefix used for theming the Tabs component.
       * @return {string} The CSS variable prefix.
       */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-tabs-';
      }

      /**
       * Initialize styles for all tabs.
       */
      static initStyles() {
        if (Tabs.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts Tabs Component */
      .${Tabs.BASE_TABS_CLASS} {
        width: 100%;
        display: flex;
        flex-direction: column;
      }
      
      .${Tabs.BASE_TABS_CLASS}__header {
        display: flex;
        flex-wrap: wrap;
        align-items: flex-end;
        border-bottom: 2px solid var(${Tabs.CSS_VAR_PREFIX}border-color, #e5e7eb);
        background-color: var(${Tabs.CSS_VAR_PREFIX}header-bg, #f9fafb);
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        min-height: 2.75rem;
      }
      
      .${Tabs.BASE_TABS_CLASS}__tab {
        flex: 1 1 auto;
        min-width: fit-content;
        padding: 0.75rem 1rem;
        background-color: transparent;
        border: none;
        border-bottom: 2px solid transparent;
        cursor: pointer;
        font-family: inherit;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(${Tabs.CSS_VAR_PREFIX}tab-color, #6b7280);
        transition: all 0.2s ease-in-out;
        white-space: nowrap;
        user-select: none;
        position: relative;
        margin-bottom: -2px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        max-width: fit-content;
      }
      
      .${Tabs.BASE_TABS_CLASS}__tab:hover:not(.${Tabs.BASE_TABS_CLASS}__tab--active) {
        color: var(${Tabs.CSS_VAR_PREFIX}tab-hover-color, #374151);
        background-color: var(${Tabs.CSS_VAR_PREFIX}tab-hover-bg, #f3f4f6);
      }
      
      .${Tabs.BASE_TABS_CLASS}__tab--active {
        color: var(${Tabs.CSS_VAR_PREFIX}tab-active-color, #2563eb);
        border-bottom-color: var(${Tabs.CSS_VAR_PREFIX}tab-active-border, #2563eb);
        background-color: var(${Tabs.CSS_VAR_PREFIX}tab-active-bg, #ffffff);
        font-weight: 600;
      }
      
      .${Tabs.BASE_TABS_CLASS}__tab:focus {
        outline: 2px solid var(${Tabs.CSS_VAR_PREFIX}tab-focus-color, #2563eb);
        outline-offset: -2px;
      }
      
      .${Tabs.BASE_TABS_CLASS}__content {
        display: none;
        padding: 1rem 0;
        animation: fadeIn 0.2s ease-in-out;
      }
      
      .${Tabs.BASE_TABS_CLASS}__content--active {
        display: block;
      }
      
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
    `, 'userscripts-tabs-styles');
        Tabs.stylesInitialized = true;
      }

      /**
       * Use default color scheme
       */
      static useDefaultColors() {
        StyleManager.addStyles(`
      .${Tabs.BASE_TABS_CLASS} {
        --${Tabs.BASE_TABS_CLASS.replace('userscripts-', '')}-border-color: #e5e7eb;
        --${Tabs.BASE_TABS_CLASS.replace('userscripts-', '')}-header-bg: #f9fafb;
        --${Tabs.BASE_TABS_CLASS.replace('userscripts-', '')}-tab-color: #6b7280;
        --${Tabs.BASE_TABS_CLASS.replace('userscripts-', '')}-tab-hover-color: #374151;
        --${Tabs.BASE_TABS_CLASS.replace('userscripts-', '')}-tab-hover-bg: #f3f4f6;
        --${Tabs.BASE_TABS_CLASS.replace('userscripts-', '')}-tab-active-color: #2563eb;
        --${Tabs.BASE_TABS_CLASS.replace('userscripts-', '')}-tab-active-border: #2563eb;
        --${Tabs.BASE_TABS_CLASS.replace('userscripts-', '')}-tab-active-bg: #ffffff;
        --${Tabs.BASE_TABS_CLASS.replace('userscripts-', '')}-tab-focus-color: #2563eb;
      }
    `, 'userscripts-tabs-default-colors');
      }

      /**
       * Create a new Tabs instance.
       * @param {Object} options - Configuration options.
       * @param {Array<Object>} options.tabs - Array of tab configurations.
       * @param {string} options.tabs[].id - Unique ID for the tab.
       * @param {string} options.tabs[].label - Label text for the tab button.
       * @param {HTMLElement|Function} options.tabs[].content - Content element or function that returns content.
       * @param {string} [options.defaultTab] - ID of the default active tab.
       * @param {Function} [options.onTabChange] - Callback when tab changes (receives tabId).
       * @param {HTMLElement} [options.container] - Container element to append tabs to.
       * @param {string} [options.className] - Additional CSS class name.
       */
      constructor(options = {}) {
        this.tabs = options.tabs || [];
        this.defaultTab = options.defaultTab || (this.tabs.length > 0 ? this.tabs[0].id : null);
        this.onTabChange = options.onTabChange || null;
        this.container = options.container || null;
        this.className = options.className || '';
        
        this.activeTabId = this.defaultTab;
        this.tabElements = new Map();
        this.contentElements = new Map();
        
        // Initialize styles if not already done
        Tabs.initStyles();
        
        // Create the tabs structure
        this.element = this.create();
        
        // Append to container if provided
        if (this.container) {
          this.container.appendChild(this.element);
        }
        
        // Activate default tab
        if (this.defaultTab) {
          this.switchToTab(this.defaultTab);
        }
      }

      /**
       * Create the tabs DOM structure.
       * @return {HTMLElement} The tabs container element.
       */
      create() {
        const container = document.createElement('div');
        container.className = `${Tabs.BASE_TABS_CLASS} ${this.className}`.trim();
        
        // Create header with tab buttons
        const header = document.createElement('div');
        header.className = `${Tabs.BASE_TABS_CLASS}__header`;
        
        // Create content container
        const contentContainer = document.createElement('div');
        contentContainer.className = `${Tabs.BASE_TABS_CLASS}__content-container`;
        
        // Create tabs and content panels
        this.tabs.forEach((tabConfig, index) => {
          // Create tab button
          const tabButton = document.createElement('button');
          tabButton.className = `${Tabs.BASE_TABS_CLASS}__tab`;
          tabButton.setAttribute('role', 'tab');
          tabButton.setAttribute('aria-selected', 'false');
          tabButton.setAttribute('aria-controls', `tab-panel-${tabConfig.id}`);
          tabButton.setAttribute('id', `tab-button-${tabConfig.id}`);
          tabButton.textContent = tabConfig.label;
          
          tabButton.addEventListener('click', () => {
            this.switchToTab(tabConfig.id);
          });
          
          // Create content panel
          const contentPanel = document.createElement('div');
          contentPanel.className = `${Tabs.BASE_TABS_CLASS}__content`;
          contentPanel.setAttribute('role', 'tabpanel');
          contentPanel.setAttribute('aria-labelledby', `tab-button-${tabConfig.id}`);
          contentPanel.setAttribute('id', `tab-panel-${tabConfig.id}`);
          
          // Set content
          if (typeof tabConfig.content === 'function') {
            const content = tabConfig.content();
            if (content instanceof HTMLElement) {
              contentPanel.appendChild(content);
            } else if (typeof content === 'string') {
              HTMLUtils.setHTMLSafely(contentPanel, content);
            }
          } else if (tabConfig.content instanceof HTMLElement) {
            contentPanel.appendChild(tabConfig.content);
          } else if (typeof tabConfig.content === 'string') {
            HTMLUtils.setHTMLSafely(contentPanel, tabConfig.content);
          }
          
          header.appendChild(tabButton);
          contentContainer.appendChild(contentPanel);
          
          // Store references
          this.tabElements.set(tabConfig.id, tabButton);
          this.contentElements.set(tabConfig.id, contentPanel);
        });
        
        container.appendChild(header);
        container.appendChild(contentContainer);
        
        return container;
      }

      /**
       * Switch to a specific tab.
       * @param {string} tabId - ID of the tab to activate.
       */
      switchToTab(tabId) {
        if (!this.tabElements.has(tabId) || !this.contentElements.has(tabId)) {
          Logger.warn(`Tab with ID "${tabId}" not found`);
          return;
        }
        
        // Deactivate all tabs
        this.tabElements.forEach((button, id) => {
          button.classList.remove(`${Tabs.BASE_TABS_CLASS}__tab--active`);
          button.setAttribute('aria-selected', 'false');
        });
        
        this.contentElements.forEach((panel, id) => {
          panel.classList.remove(`${Tabs.BASE_TABS_CLASS}__content--active`);
        });
        
        // Activate selected tab
        const activeButton = this.tabElements.get(tabId);
        const activePanel = this.contentElements.get(tabId);
        
        if (activeButton && activePanel) {
          activeButton.classList.add(`${Tabs.BASE_TABS_CLASS}__tab--active`);
          activeButton.setAttribute('aria-selected', 'true');
          activePanel.classList.add(`${Tabs.BASE_TABS_CLASS}__content--active`);
          
          this.activeTabId = tabId;
          
          // Call callback if provided
          if (this.onTabChange) {
            this.onTabChange(tabId);
          }
        }
      }

      /**
       * Get the currently active tab ID.
       * @return {string} The active tab ID.
       */
      getActiveTab() {
        return this.activeTabId;
      }

      /**
       * Get the tabs container element.
       * @return {HTMLElement} The tabs container.
       */
      getElement() {
        return this.element;
      }

      /**
       * Update tab content.
       * @param {string} tabId - ID of the tab to update.
       * @param {HTMLElement|string|Function} content - New content.
       */
      updateTabContent(tabId, content) {
        const panel = this.contentElements.get(tabId);
        if (!panel) {
          Logger.warn(`Tab panel with ID "${tabId}" not found`);
          return;
        }
        
        // Clear existing content
        panel.innerHTML = '';
        
        // Set new content
        if (typeof content === 'function') {
          const newContent = content();
          if (newContent instanceof HTMLElement) {
            panel.appendChild(newContent);
          } else if (typeof newContent === 'string') {
            HTMLUtils.setHTMLSafely(panel, newContent);
          }
        } else if (content instanceof HTMLElement) {
          panel.appendChild(content);
        } else if (typeof content === 'string') {
          HTMLUtils.setHTMLSafely(panel, content);
        }
      }

      /**
       * Destroy the tabs component and clean up.
       */
      destroy() {
        if (this.element && this.element.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
        this.tabElements.clear();
        this.contentElements.clear();
      }
    }

    /**
     * InfoBox - A reusable UI component for informational callout boxes
     * Provides consistent styling for info, warning, and notice boxes
     */

    class InfoBox {
        static BASE_INFOBOX_CLASS = 'userscript-infobox';
        static VARIANTS = {
            info: 'info',
            warning: 'warning',
            success: 'success',
            error: 'error',
            default: 'default'
        };

        /**
         * Initialize default styles for InfoBox components
         */
        static initStyles(options = {}) {
            const { scopeSelector = '' } = options;
            const styleId = `infobox-component${scopeSelector ? '-' + scopeSelector.replace(/[^a-zA-Z0-9]/g, '') : ''}`;

            if (StyleManager.hasStyles(styleId)) {
                return;
            }

            const selectorPrefix = scopeSelector ? `${scopeSelector} ` : '';

            const styles = `
            ${selectorPrefix}.${InfoBox.BASE_INFOBOX_CLASS} {
                font-size: 11px;
                color: #666;
                margin-bottom: 12px;
                padding: 8px;
                background: #f5f5f5;
                border-radius: 4px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                line-height: 1.5;
            }

            /* Variants */
            ${selectorPrefix}.${InfoBox.BASE_INFOBOX_CLASS}--info {
                background: #e3f2fd;
                color: #1565c0;
                border-left: 3px solid #2196f3;
            }

            ${selectorPrefix}.${InfoBox.BASE_INFOBOX_CLASS}--warning {
                background: #fff3e0;
                color: #e65100;
                border-left: 3px solid #ff9800;
            }

            ${selectorPrefix}.${InfoBox.BASE_INFOBOX_CLASS}--success {
                background: #e8f5e9;
                color: #2e7d32;
                border-left: 3px solid #4caf50;
            }

            ${selectorPrefix}.${InfoBox.BASE_INFOBOX_CLASS}--error {
                background: #ffebee;
                color: #c62828;
                border-left: 3px solid #f44336;
            }

            ${selectorPrefix}.${InfoBox.BASE_INFOBOX_CLASS}--default {
                background: #f5f5f5;
                color: #666;
            }
        `;

            StyleManager.addStyles(styles, styleId);
        }

        /**
         * Create an InfoBox element
         * @param {Object} options - Configuration options
         * @param {string|HTMLElement} options.content - Text content or HTML element(s) to display
         * @param {string} [options.variant='default'] - Variant (info, warning, success, error, default)
         * @param {HTMLElement} [options.container] - Container to append the InfoBox to
         * @param {string} [options.className] - Additional CSS class
         * @param {string} [options.scopeSelector] - Scope selector for styles
         * @param {boolean} [options.html=false] - Whether to interpret content as HTML (use with caution)
         * @return {HTMLElement} The created InfoBox element
         */
        static create(options = {}) {
            const {
                content = '',
                variant = 'default',
                container = null,
                className = '',
                scopeSelector = '',
                html = false
            } = options;

            // Initialize styles
            InfoBox.initStyles({ scopeSelector });

            // Create the InfoBox element
            const infoBox = document.createElement('div');
            infoBox.className = `${InfoBox.BASE_INFOBOX_CLASS} ${InfoBox.BASE_INFOBOX_CLASS}--${variant} ${className}`.trim();

            // Set content
            if (html && typeof content === 'string') {
                // Use innerHTML only if explicitly requested (security risk, but sometimes needed)
                infoBox.innerHTML = content;
            } else if (typeof content === 'string') {
                // Safe text content - split by newlines and create elements
                const lines = content.split('\n');
                lines.forEach((line, index) => {
                    if (line.trim()) {
                        infoBox.appendChild(document.createTextNode(line));
                    }
                    if (index < lines.length - 1) {
                        infoBox.appendChild(document.createElement('br'));
                    }
                });
            } else if (content instanceof HTMLElement) {
                // Append element directly
                infoBox.appendChild(content);
            } else if (Array.isArray(content)) {
                // Append multiple elements
                content.forEach(item => {
                    if (item instanceof HTMLElement || item instanceof Text) {
                        // Handle both HTML elements and Text nodes
                        infoBox.appendChild(item);
                    } else if (typeof item === 'string') {
                        infoBox.appendChild(document.createTextNode(item));
                    } else if (item instanceof Node) {
                        // Handle any other Node type (e.g., Comment, DocumentFragment)
                        infoBox.appendChild(item);
                    }
                });
            }

            // Append to container if provided
            if (container) {
                container.appendChild(infoBox);
            }

            return infoBox;
        }

        /**
         * Convenience method to create an info variant InfoBox
         * @param {string|HTMLElement} content - Content to display
         * @param {Object} [options] - Additional options
         * @return {HTMLElement} The created InfoBox element
         */
        static info(content, options = {}) {
            return InfoBox.create({ ...options, content, variant: 'info' });
        }

        /**
         * Convenience method to create a warning variant InfoBox
         * @param {string|HTMLElement} content - Content to display
         * @param {Object} [options] - Additional options
         * @return {HTMLElement} The created InfoBox element
         */
        static warning(content, options = {}) {
            return InfoBox.create({ ...options, content, variant: 'warning' });
        }

        /**
         * Convenience method to create a success variant InfoBox
         * @param {string|HTMLElement} content - Content to display
         * @param {Object} [options] - Additional options
         * @return {HTMLElement} The created InfoBox element
         */
        static success(content, options = {}) {
            return InfoBox.create({ ...options, content, variant: 'success' });
        }

        /**
         * Convenience method to create an error variant InfoBox
         * @param {string|HTMLElement} content - Content to display
         * @param {Object} [options] - Additional options
         * @return {HTMLElement} The created InfoBox element
         */
        static error(content, options = {}) {
            return InfoBox.create({ ...options, content, variant: 'error' });
        }
    }

    // Import core components

    // Configure logger
    Logger.setPrefix("Meta AI Media Enhancer");
    Logger.DEBUG = true;

    /**
     * Meta AI Media Enhancer
     * Automates prompt sending to Meta AI Media with multiple prompts and configurable delays
     */
    class MetaAIMediaEnhancer {
        // Configuration
        static SELECTORS = {
            PROMPT_AREA: [
                'div[aria-label="Describe your image..."][contenteditable="true"]',
                'div[contenteditable="true"][role="textbox"][aria-label*="image"]',
                'div[contenteditable="true"][role="textbox"]',
                'div[contenteditable="true"]'
            ],
            // Keep the original aria-label selector, but add language-agnostic fallbacks
            SEND_BUTTON: [
                'div[aria-label="Send"][role="button"]:not([aria-disabled="true"])',
                'div[aria-label="Send"][role="button"]',
                'div[role="button"][aria-label="Send"]',
                // Language-agnostic fallbacks (role + icon shape + enabled)
                'div[role="button"]:has(svg path[d^="M16.0279"]):not([aria-disabled="true"])',
                'div[role="button"]:has(svg path[d^="M16.0279"])'
            ],
            SEND_BUTTON_DISABLED: [
                'div[aria-label="Send"][aria-disabled="true"]',
                'div[role="button"][aria-disabled="true"][aria-label="Send"]',
                // Language-agnostic fallback for disabled state
                'div[role="button"][aria-disabled="true"]:has(svg path[d^="M16.0279"])'
            ]
        };

        static SETTINGS_KEYS = {
            MULTIPLE_PROMPTS: 'maime-multiple-prompts',
            DELAY_SECONDS: 'maime-delay-seconds',
            SHOW_NOTIFICATIONS: 'maime-show-notifications',
            PANEL_POSITION: 'maime-panel-position',
            AUTO_CLEAR_PROMPT: 'maime-auto-clear-prompt',
            PROMPT_MODE: 'maime-prompt-mode',
            AUTO_RUN_PROMPT: 'maime-auto-run-prompt',
            BASE_PROMPT_MULTIPLE: 'maime-base-prompt-multiple',
            BASE_PROMPT_POSITION: 'maime-base-prompt-position',
            MULTIPLE_PROMPTS_START_COUNT: 'maime-multiple-prompts-start-count',
            TEMPLATE_PROMPT: 'maime-template-prompt',
            OVERRIDE_ITERATIONS: 'maime-override-iterations',
            DEFAULT_ITERATIONS: 'maime-default-iterations'
        };

        static DEFAULT_SETTINGS = {
            MULTIPLE_PROMPTS: '',
            DELAY_SECONDS: 3,
            SHOW_NOTIFICATIONS: true,
            PANEL_POSITION: { x: 20, y: 20 },
            AUTO_CLEAR_PROMPT: true,
            PROMPT_MODE: 'multiple',
            AUTO_RUN_PROMPT: '',
            BASE_PROMPT_MULTIPLE: '',
            BASE_PROMPT_POSITION: 'after',
            MULTIPLE_PROMPTS_START_COUNT: 0,
            TEMPLATE_PROMPT: 'This is iteration {iteration} of {total}. Please provide a response.',
            OVERRIDE_ITERATIONS: false,
            DEFAULT_ITERATIONS: 10
        };

        static EVENTS = {
            PROMPT_SENT: 'meta-ai-media:prompt-sent',
            AUTOMATION_STARTED: 'meta-ai-media:automation-started',
            AUTOMATION_STOPPED: 'meta-ai-media:automation-stopped',
            AUTOMATION_ITERATION: 'meta-ai-media:automation-iteration',
            SETTINGS_CHANGED: 'meta-ai-media:settings-changed'
        };

        constructor() {
            this.isRunning = false;
            this.shouldStop = false;
            this.currentIndex = 0;
            this.totalPrompts = 0;
            this.settings = { ...MetaAIMediaEnhancer.DEFAULT_SETTINGS };
            this.sidebarPanel = null;
            this.enhancerId = 'meta-ai-media-enhancer-container';
            this.subscriptionIds = [];
            
            // Debouncer for text saving
            this.textSaveDebouncer = new Debouncer(() => {
                this.saveSettings();
            }, 500);
            
            this.userInteraction = UserInteractionDetector.getInstance({
                debug: Logger.DEBUG,
                namespace: 'meta-ai-media-enhancer',
                interactionWindow: 200,
                interactionThrottle: 100
            });

            Logger.info("Initializing Meta AI Media Enhancer");

            this.setupEventHandlers();
            this.urlWatcher = new UrlChangeWatcher([
                new PollingStrategy(this.handleUrlChange.bind(this), 1000)
            ], false);

            this.loadSettings().then(() => {
                this.init();
            });
            
            window.addEventListener('beforeunload', () => {
                this.cleanup();
            });
        }

        /**
         * Simple delay function
         */
        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Setup PubSub event handlers
         */
        setupEventHandlers() {
            this.subscriptionIds.push(
                PubSub.subscribe(MetaAIMediaEnhancer.EVENTS.SETTINGS_CHANGED, (data) => {
                    this.handleSettingsChanged(data);
                })
            );

            Logger.debug("PubSub event handlers setup complete");
        }

        /**
         * Cleanup resources
         */
        cleanup() {
            this.subscriptionIds.forEach(id => {
                PubSub.unsubscribe(id);
            });
            this.subscriptionIds = [];
            
            if (this.isRunning) {
                this.shouldStop = true;
            }
            
            Logger.debug("All subscriptions and resources cleaned up");
        }

        /**
         * Load saved settings
         */
        async loadSettings() {
            try {
                for (const [settingName, storageKey] of Object.entries(MetaAIMediaEnhancer.SETTINGS_KEYS)) {
                    const savedValue = await getValue(storageKey, null);
                    if (savedValue !== null) {
                        this.settings[settingName] = savedValue;
                    }
                }
                Logger.debug("Settings loaded", this.settings);
            } catch (error) {
                Logger.error("Error loading settings:", error);
            }
        }

        /**
         * Save settings
         */
        async saveSettings() {
            try {
                for (const [settingName, storageKey] of Object.entries(MetaAIMediaEnhancer.SETTINGS_KEYS)) {
                    await setValue(storageKey, this.settings[settingName]);
                }
                Logger.debug("Settings saved", this.settings);
                PubSub.publish(MetaAIMediaEnhancer.EVENTS.SETTINGS_CHANGED, this.settings);
            } catch (error) {
                Logger.error("Error saving settings:", error);
            }
        }

        /**
         * Initialize the enhancer
         */
        async init() {
            try {
                Logger.info("Enhancer starting initialization...");

                try {
                    document.body.id = this.enhancerId;
                } catch (error) {
                    Logger.warn('Failed to set body ID:', error);
                }

                await this.waitForPageReady();
                Logger.info("Page is ready, proceeding with initialization.");

                try {
                    SidebarPanel.initStyles();
                    Button.initStyles();
                    Button.useDefaultColors();
                    Checkbox.initStyles();
                    Checkbox.useDefaultColors();
                    Notification.initStyles();
                    Notification.useDefaultColors();
                    Input.initStyles();
                    Input.useDefaultColors();
                    TextArea.initStyles();
                    TextArea.useDefaultColors();
                    SelectBox.initStyles();
                    SelectBox.useDefaultColors();
                    Tabs.initStyles();
                    Tabs.useDefaultColors();
                } catch (error) {
                    Logger.error('Error initializing styles:', error);
                }

                StyleManager.addStyles(`
                .meta-ai-prompts-textarea,
                .meta-ai-delay-input,
                .auto-run-prompt-textarea,
                .auto-run-multiple-prompts-textarea,
                .auto-run-base-prompt-multiple-textarea,
                .auto-run-template-prompt-textarea {
                    margin-bottom: 12px;
                }
                
                .meta-ai-prompts-textarea textarea,
                .auto-run-multiple-prompts-textarea textarea,
                .auto-run-base-prompt-multiple-textarea textarea,
                .auto-run-template-prompt-textarea textarea {
                    max-height: 300px !important;
                    overflow-y: auto !important;
                }
                
                .auto-run-prompt-textarea textarea,
                .auto-run-base-prompt-multiple-textarea textarea {
                    max-height: 200px !important;
                    overflow-y: auto !important;
                }
                
                .meta-ai-status-display {
                    font-size: 12px;
                    color: #666;
                    text-align: center;
                    padding: 8px;
                    background: #f5f5f5;
                    border-radius: 4px;
                    margin-top: 8px;
                }
                
                /* Settings section improvements */
                #meta-ai-media-enhancer-panel h3 {
                    margin-top: 0;
                }
                
                /* Checkbox label styling for better readability */
                #meta-ai-media-enhancer-panel input[type="checkbox"] + label {
                    font-size: 13px;
                    line-height: 1.5;
                    color: #555;
                    cursor: pointer;
                    user-select: none;
                }
                
                #meta-ai-media-enhancer-panel input[type="checkbox"] + label:hover {
                    color: #333;
                }
                
                .single-prompt-container,
                .multiple-prompt-container,
                .template-prompt-container {
                    margin-bottom: 12px;
                }
                
                .single-prompt-container label,
                .multiple-prompt-container label,
                .template-prompt-container label {
                    display: block;
                    margin-bottom: 4px;
                    font-size: 12px;
                    color: #555;
                    font-weight: 500;
                }
            `, 'meta-ai-media-enhancer-custom-styles');

                await this.createSidebarPanel();

                Logger.success("Meta AI Media Enhancer initialized successfully!");
            } catch (error) {
                Logger.error('Error during initialization:', error);
                this.showNotification('Failed to initialize enhancer. Please refresh the page.', 'error');
            }
        }

        /**
         * Wait for page to be ready
         */
        async waitForPageReady() {
            if (document.readyState !== 'complete') {
                await new Promise(resolve => {
                    window.addEventListener('load', resolve, { once: true });
                });
            }
            
            try {
                await HTMLUtils.waitForElement('body', 5000);
                await new Promise(resolve => setTimeout(resolve, 1000));
                Logger.debug('Page ready - main elements found');
            } catch (error) {
                Logger.warn('Some page elements not found, but continuing:', error.message);
            }
        }

        /**
         * Create the sidebar panel
         */
        async createSidebarPanel() {
            this.sidebarPanel = new SidebarPanel({
                title: 'ðŸŽ¨ Meta AI Media Enhancer',
                id: 'meta-ai-media-enhancer-panel',
                position: 'right',
                transition: 'slide',
                buttonIcon: 'ðŸŽ¨',
                content: {
                    generator: () => this.createPanelContent()
                },
                style: {
                    width: '400px',
                    buttonSize: '48px',
                    buttonColor: '#fff',
                    buttonBg: '#0084ff',
                    panelBg: '#fff'
                },
                rememberState: true
            });

            // Initialize the panel to create DOM elements
            await this.sidebarPanel.init();

            Logger.debug("SidebarPanel created and initialized");
        }

        /**
         * Create panel content
         */
        createPanelContent() {
            const content = document.createElement('div');
            content.style.cssText = `
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
        `;

            // Create tabs to separate prompt automation and settings
            const tabsContainer = document.createElement('div');
            
            this.tabs = new Tabs({
                tabs: [
                    {
                        id: 'prompt-automation',
                        label: 'ðŸ”„ Prompt Automation',
                        content: () => {
                            const tabContent = document.createElement('div');
                            this.createAutomationSection(tabContent);
                            return tabContent;
                        }
                    },
                    {
                        id: 'settings',
                        label: 'âš™ï¸ Settings',
                        content: () => {
                            const tabContent = document.createElement('div');
                            this.createSettingsSection(tabContent);
                            return tabContent;
                        }
                    }
                ],
                defaultTab: 'prompt-automation',
                container: tabsContainer
            });

            content.appendChild(tabsContainer);

            return content;
        }

        /**
         * Create automation section
         */
        createAutomationSection(container) {
            const section = document.createElement('div');
            section.style.marginBottom = '20px';

            const title = document.createElement('h3');
            title.textContent = 'ðŸš€ Prompt Automation';
            title.style.cssText = 'margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #333;';
            section.appendChild(title);

            // Prompt mode selector
            const promptModeContainer = document.createElement('div');
            promptModeContainer.style.marginBottom = '12px';

            this.promptModeSelect = new SelectBox({
                items: [
                    { value: 'single', label: 'Single Prompt (same for all iterations)', selected: (this.settings.PROMPT_MODE || 'multiple') === 'single' },
                    { value: 'multiple', label: 'Multiple Prompts (different for each iteration)', selected: (this.settings.PROMPT_MODE || 'multiple') === 'multiple' },
                    { value: 'template', label: 'Template Prompts (with variables)', selected: (this.settings.PROMPT_MODE || 'multiple') === 'template' }
                ],
                name: 'prompt-mode',
                id: 'prompt-mode-select',
                label: 'Prompt Mode:',
                placeholder: 'Select prompt mode',
                container: promptModeContainer,
                theme: 'default',
                size: 'medium',
                onChange: (value) => {
                    this.settings.PROMPT_MODE = value;
                    this.saveSettings();
                    this.updatePromptInputVisibility();
                }
            });

            // Single prompt input
            this.singlePromptContainer = document.createElement('div');
            this.singlePromptContainer.className = 'single-prompt-container';
            this.singlePromptContainer.style.display = (this.settings.PROMPT_MODE || 'multiple') === 'single' ? 'block' : 'none';
            
            this.promptTextArea = new TextArea({
                value: this.settings.AUTO_RUN_PROMPT || '',
                label: 'Single Prompt:',
                placeholder: 'Enter prompt to use for all iterations (optional)',
                rows: 3,
                theme: 'primary',
                size: 'medium',
                className: 'auto-run-prompt-textarea',
                attributes: { autocomplete: 'off', 'data-lpignore': 'true' },
                onInput: (event, textArea) => {
                    this.settings.AUTO_RUN_PROMPT = textArea.getValue();
                    this.textSaveDebouncer.trigger();
                },
                onBlur: (event, textArea) => {
                    this.settings.AUTO_RUN_PROMPT = textArea.getValue();
                    this.saveSettings();
                },
                container: this.singlePromptContainer,
                autoResize: true,
                scopeSelector: `#${this.enhancerId}`
            });

            // Multiple prompts input
            this.multiplePromptContainer = document.createElement('div');
            this.multiplePromptContainer.className = 'multiple-prompt-container';
            this.multiplePromptContainer.style.display = (this.settings.PROMPT_MODE || 'multiple') === 'multiple' ? 'block' : 'none';

            const multiplePromptPlaceholder = `Enter prompts separated by --- (three dashes):

First prompt here
can be multiline
---
Second prompt here
also multiline
---
Third prompt`;

            this.multiplePromptTextArea = new TextArea({
                value: this.settings.MULTIPLE_PROMPTS || '',
                label: 'Multiple Prompts:',
                placeholder: multiplePromptPlaceholder,
                rows: 8,
                theme: 'primary',
                size: 'medium',
                className: 'auto-run-multiple-prompts-textarea',
                attributes: { autocomplete: 'off', 'data-lpignore': 'true' },
                onInput: (event, textArea) => {
                    this.settings.MULTIPLE_PROMPTS = textArea.getValue();
                    this.textSaveDebouncer.trigger();
                    this.updateIterationInputBehavior(this.settings.PROMPT_MODE || 'multiple');
                },
                onBlur: (event, textArea) => {
                    this.settings.MULTIPLE_PROMPTS = textArea.getValue();
                    this.saveSettings();
                },
                container: this.multiplePromptContainer,
                autoResize: true,
                scopeSelector: `#${this.enhancerId}`
            });

            // Base prompt for multiple prompts
            const basePromptPositionContainer = document.createElement('div');
            basePromptPositionContainer.style.cssText = 'margin-bottom: 8px; margin-top: 12px; display: flex; align-items: center; gap: 8px;';

            const basePromptPosition = this.settings.BASE_PROMPT_POSITION || 'after';
            this.basePromptPositionSelect = new SelectBox({
                items: [
                    { value: 'before', label: 'Before prompt', selected: basePromptPosition === 'before' },
                    { value: 'after', label: 'After prompt', selected: basePromptPosition === 'after' }
                ],
                name: 'base-prompt-position',
                id: 'base-prompt-position-select',
                label: 'Position:',
                labelPosition: 'inline',
                placeholder: 'Select position',
                container: basePromptPositionContainer,
                theme: 'default',
                size: 'small',
                onChange: (value) => {
                    this.settings.BASE_PROMPT_POSITION = value;
                    this.saveSettings();
                    const newPlaceholder = value === 'before' 
                        ? 'Enter base prompt to prepend to each prompt (optional)'
                        : 'Enter base prompt to append to each prompt (optional)';
                    if (this.basePromptMultipleTextArea && this.basePromptMultipleTextArea.textareaElement) {
                        this.basePromptMultipleTextArea.textareaElement.placeholder = newPlaceholder;
                    }
                }
            });

            const basePromptPlaceholder = (this.settings.BASE_PROMPT_POSITION || 'after') === 'before' 
                ? 'Enter base prompt to prepend to each prompt (optional)'
                : 'Enter base prompt to append to each prompt (optional)';

            this.basePromptMultipleTextArea = new TextArea({
                value: this.settings.BASE_PROMPT_MULTIPLE || '',
                label: 'Base Prompt (optional):',
                placeholder: basePromptPlaceholder,
                rows: 3,
                theme: 'primary',
                size: 'medium',
                className: 'auto-run-base-prompt-multiple-textarea',
                attributes: { autocomplete: 'off', 'data-lpignore': 'true' },
                onInput: (event, textArea) => {
                    this.settings.BASE_PROMPT_MULTIPLE = textArea.getValue();
                    this.textSaveDebouncer.trigger();
                },
                onBlur: (event, textArea) => {
                    this.settings.BASE_PROMPT_MULTIPLE = textArea.getValue();
                    this.saveSettings();
                },
                container: this.multiplePromptContainer,
                autoResize: true,
                scopeSelector: `#${this.enhancerId}`
            });

            this.multiplePromptContainer.appendChild(basePromptPositionContainer);

            // Start count input for multiple prompts
            const startCountContainer = document.createElement('div');
            startCountContainer.style.marginBottom = '12px';
            startCountContainer.style.marginTop = '12px';

            this.multiplePromptsStartCountInput = new Input({
                type: 'number',
                label: 'Start from prompt number:',
                value: this.settings.MULTIPLE_PROMPTS_START_COUNT !== undefined 
                    ? this.settings.MULTIPLE_PROMPTS_START_COUNT 
                    : 0,
                placeholder: '0',
                min: 0,
                className: 'multiple-prompts-start-count-input',
                attributes: { autocomplete: 'off', 'data-lpignore': 'true' },
                scopeSelector: `#${this.enhancerId}`,
                validator: (value) => {
                    const num = parseInt(value, 10);
                    if (isNaN(num) || num < 0) {
                        return 'Please enter a number >= 0';
                    }
                    return true;
                },
                onChange: (event, input) => {
                    const value = parseInt(input.getValue(), 10);
                    if (!isNaN(value) && value >= 0) {
                        this.settings.MULTIPLE_PROMPTS_START_COUNT = value;
                        this.saveSettings();
                    }
                },
                container: startCountContainer
            });

            InfoBox.create({
                content: 'Set to 0 to start from the first prompt (1-indexed)',
                variant: 'default',
                container: startCountContainer,
                scopeSelector: `#${this.enhancerId}`
            });

            this.multiplePromptContainer.appendChild(startCountContainer);

            // Template prompts input
            this.templatePromptContainer = document.createElement('div');
            this.templatePromptContainer.className = 'template-prompt-container';
            this.templatePromptContainer.style.display = (this.settings.PROMPT_MODE || 'multiple') === 'template' ? 'block' : 'none';

            this.templatePromptTextArea = new TextArea({
                value: this.settings.TEMPLATE_PROMPT || 'This is iteration {iteration} of {total}. Please provide a response.',
                label: 'Template Prompt (use {iteration}, {total}, {timestamp}):',
                placeholder: 'Template with variables: {iteration}, {total}, {timestamp}',
                rows: 3,
                theme: 'primary',
                size: 'medium',
                className: 'auto-run-template-prompt-textarea',
                attributes: { autocomplete: 'off', 'data-lpignore': 'true' },
                onInput: (event, textArea) => {
                    this.settings.TEMPLATE_PROMPT = textArea.getValue();
                    this.textSaveDebouncer.trigger();
                },
                onBlur: (event, textArea) => {
                    this.settings.TEMPLATE_PROMPT = textArea.getValue();
                    this.saveSettings();
                },
                container: this.templatePromptContainer,
                autoResize: true,
                scopeSelector: `#${this.enhancerId}`
            });

            // Iterations input container
            const iterationsContainer = document.createElement('div');
            iterationsContainer.style.marginBottom = '12px';

            this.iterationsInfoText = document.createElement('div');
            this.iterationsInfoText.style.cssText = 'font-size: 11px; color: #666; margin-bottom: 4px;';
            this.updateIterationInputBehavior(this.settings.PROMPT_MODE || 'multiple');

            this.overrideIterationsCheckbox = new Checkbox({
                label: 'Override automatic iteration count (run multiple cycles)',
                checked: this.settings.OVERRIDE_ITERATIONS || false,
                onChange: (event) => {
                    this.settings.OVERRIDE_ITERATIONS = this.overrideIterationsCheckbox.isChecked();
                    this.saveSettings();
                    this.updateIterationInputBehavior(this.settings.PROMPT_MODE || 'multiple');
                },
                container: iterationsContainer,
                size: 'small'
            });

            this.iterationsInput = new Input({
                type: 'number',
                label: 'Number of iterations:',
                value: this.settings.DEFAULT_ITERATIONS || 10,
                placeholder: 'Number of iterations',
                min: 1,
                max: 100,
                className: 'auto-run-iterations-input',
                attributes: { autocomplete: 'off', 'data-lpignore': 'true' },
                scopeSelector: `#${this.enhancerId}`,
                validator: (value) => {
                    const num = parseInt(value, 10);
                    if (isNaN(num) || num < 1) {
                        return 'Please enter a number greater than 0';
                    }
                    if (num > 100) {
                        return 'Maximum 100 iterations allowed';
                    }
                    return true;
                },
                onChange: (event, input) => {
                    const value = parseInt(input.getValue(), 10);
                    if (!isNaN(value) && value > 0) {
                        this.settings.DEFAULT_ITERATIONS = value;
                        this.saveSettings();
                    }
                },
                container: iterationsContainer
            });

            iterationsContainer.appendChild(this.iterationsInfoText);

            // Delay input
            const delayContainer = document.createElement('div');
            delayContainer.style.marginBottom = '12px';

            const delayLabel = document.createElement('label');
            delayLabel.textContent = 'Delay between prompts (seconds):';
            delayLabel.style.cssText = 'display: block; margin-bottom: 4px; font-size: 12px; color: #555;';

            this.delayInput = new Input({
                type: 'number',
                value: this.settings.DELAY_SECONDS,
                placeholder: 'Delay in seconds',
                min: 0,
                max: 300,
                step: 0.5,
                className: 'meta-ai-delay-input',
                scopeSelector: `#${this.enhancerId}`,
                validator: (value) => {
                    const num = parseFloat(value);
                    if (isNaN(num) || num < 0) {
                        return 'Please enter a number greater than or equal to 0';
                    }
                    if (num > 300) {
                        return 'Maximum 300 seconds allowed';
                    }
                    return true;
                },
                onChange: (event, input) => {
                    const value = parseFloat(input.getValue());
                    if (!isNaN(value) && value >= 0) {
                        this.settings.DELAY_SECONDS = value;
                        this.saveSettings();
                    }
                },
                container: delayContainer
            });

            delayContainer.appendChild(delayLabel);

            // Button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'margin-bottom: 10px;';

            this.toggleButton = new Button({
                text: 'Start Automation',
                theme: 'primary',
                size: 'medium',
                onClick: (event) => this.handleToggleButtonClick(event),
                className: 'meta-ai-toggle-button',
                container: buttonContainer
            });

            // Status display
            this.statusElement = document.createElement('div');
            this.statusElement.className = 'meta-ai-status-display';
            this.statusElement.textContent = 'Ready to start';

            section.appendChild(promptModeContainer);
            section.appendChild(this.singlePromptContainer);
            section.appendChild(this.multiplePromptContainer);
            section.appendChild(this.templatePromptContainer);
            section.appendChild(iterationsContainer);
            section.appendChild(delayContainer);
            section.appendChild(buttonContainer);
            section.appendChild(this.statusElement);

            container.appendChild(section);
        }

        /**
         * Create settings section
         */
        createSettingsSection(container) {
            const section = document.createElement('div');
            section.style.cssText = `
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #e0e0e0;
        `;

            const title = document.createElement('h3');
            title.textContent = 'âš™ï¸ Settings';
            title.style.cssText = `
            margin: 0 0 16px 0;
            font-size: 14px;
            font-weight: 600;
            color: #333;
            letter-spacing: 0.3px;
        `;

            // Create a container for checkboxes with better spacing
            const checkboxesContainer = document.createElement('div');
            checkboxesContainer.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 14px;
            padding: 0;
        `;

            // Auto clear prompt checkbox container
            const autoClearContainer = document.createElement('div');
            autoClearContainer.style.cssText = `
            display: flex;
            align-items: center;
            padding: 8px 0;
        `;

            this.autoClearCheckbox = new Checkbox({
                label: 'Auto-clear prompt after sending',
                checked: this.settings.AUTO_CLEAR_PROMPT !== false,
                onChange: (event) => {
                    this.settings.AUTO_CLEAR_PROMPT = this.autoClearCheckbox.isChecked();
                    this.saveSettings();
                },
                container: autoClearContainer,
                size: 'small'
            });

            // Show notifications checkbox container
            const notificationsContainer = document.createElement('div');
            notificationsContainer.style.cssText = `
            display: flex;
            align-items: center;
            padding: 8px 0;
        `;

            this.showNotificationsCheckbox = new Checkbox({
                label: 'Show notifications',
                checked: this.settings.SHOW_NOTIFICATIONS !== false,
                onChange: (event) => {
                    this.settings.SHOW_NOTIFICATIONS = this.showNotificationsCheckbox.isChecked();
                    this.saveSettings();
                },
                container: notificationsContainer,
                size: 'small'
            });

            // Assemble the section
            checkboxesContainer.appendChild(autoClearContainer);
            checkboxesContainer.appendChild(notificationsContainer);
            
            section.appendChild(title);
            section.appendChild(checkboxesContainer);

            container.appendChild(section);
        }

        /**
         * Show container based on mode selection
         * @param {string} mode - Current mode value
         * @param {Object} modeContainerMap - Map of mode values to container elements
         */
        showContainerByMode(mode, modeContainerMap) {
            // Hide all containers first
            Object.values(modeContainerMap).forEach(container => {
                if (container) {
                    container.style.display = 'none';
                }
            });

            // Show the container for the current mode
            const activeContainer = modeContainerMap[mode];
            if (activeContainer) {
                activeContainer.style.display = 'block';
            }
        }

        /**
         * Update prompt input visibility based on mode
         */
        updatePromptInputVisibility() {
            const mode = this.settings.PROMPT_MODE || 'multiple';
            const modeContainerMap = {
                'single': this.singlePromptContainer,
                'multiple': this.multiplePromptContainer,
                'template': this.templatePromptContainer
            };
            this.showContainerByMode(mode, modeContainerMap);
        }

        /**
         * Update iteration input behavior based on mode
         */
        updateIterationInputBehavior(mode) {
            if (!this.iterationsInfoText) return;

            if (mode === 'multiple') {
                const multiplePrompts = this.settings.MULTIPLE_PROMPTS
                    ? this.settings.MULTIPLE_PROMPTS.split('---')
                        .map(p => p.trim())
                        .filter(p => p.length > 0)
                    : [];
                
                const promptCount = multiplePrompts.length;
                if (promptCount > 0) {
                    this.iterationsInfoText.textContent = `Number of iterations to run (${promptCount} prompts available)`;
                } else {
                    this.iterationsInfoText.textContent = 'Number of iterations to run';
                }
            } else {
                this.iterationsInfoText.textContent = 'Number of iterations to run';
            }
        }

        /**
         * Handle toggle button click
         */
        handleToggleButtonClick(event) {
            const isUserInitiated = this.userInteraction.isUserEvent(event);
            
            Logger.info('Toggle button clicked', {
                isUserInitiated,
                currentState: this.isRunning
            });

            if (isUserInitiated) {
                this.toggleAutomation();
            } else {
                Logger.warn('Programmatic toggle button click detected - ignoring');
            }
        }

        /**
         * Toggle automation
         */
        async toggleAutomation() {
            if (this.isRunning) {
                this.stopAutomation();
            } else {
                await this.startAutomation();
            }
        }

        /**
         * Get all prompts based on mode and iterations
         */
        getAllPrompts(iterations) {
            const mode = this.settings.PROMPT_MODE || 'multiple';
            const prompts = [];

            switch (mode) {
                case 'single':
                    const singlePrompt = this.settings.AUTO_RUN_PROMPT || '';
                    for (let i = 0; i < iterations; i++) {
                        prompts.push(singlePrompt);
                    }
                    break;

                case 'multiple':
                    const multiplePrompts = this.settings.MULTIPLE_PROMPTS
                        ? this.settings.MULTIPLE_PROMPTS.split('---')
                            .map(p => p.trim())
                            .filter(p => p.length > 0)
                        : [];
                    
                    if (multiplePrompts.length === 0) {
                        break;
                    }

                    const basePrompt = (this.settings.BASE_PROMPT_MULTIPLE || '').trim();
                    const basePromptPosition = this.settings.BASE_PROMPT_POSITION || 'after';
                    const startCount = this.settings.MULTIPLE_PROMPTS_START_COUNT || 0;
                    
                    // Validate start count (1-indexed, so max is multiplePrompts.length)
                    const validStartCount = Math.max(0, Math.min(startCount, multiplePrompts.length));
                    
                    // Calculate starting index (convert from 1-indexed to 0-indexed)
                    const startIndex = validStartCount > 0 ? validStartCount - 1 : 0;

                    // Fill prompts array by cycling through available prompts, starting from startIndex
                    for (let i = 0; i < iterations; i++) {
                        // Calculate the actual prompt index (accounting for start count and cycling)
                        const actualIndex = (startIndex + i) % multiplePrompts.length;
                        let combinedPrompt = multiplePrompts[actualIndex];
                        
                        // Combine with base prompt if provided
                        if (basePrompt) {
                            if (basePromptPosition === 'before') {
                                combinedPrompt = `${basePrompt}\n${combinedPrompt}`;
                            } else {
                                combinedPrompt = `${combinedPrompt}\n${basePrompt}`;
                            }
                        }
                        
                        prompts.push(combinedPrompt);
                    }
                    break;

                case 'template':
                    const template = this.settings.TEMPLATE_PROMPT || '';
                    for (let i = 0; i < iterations; i++) {
                        let prompt = template;
                        const timestamp = new Date().toISOString();
                        
                        // Replace variables
                        prompt = prompt.replace(/\{iteration\}/g, i + 1);
                        prompt = prompt.replace(/\{total\}/g, iterations);
                        prompt = prompt.replace(/\{timestamp\}/g, timestamp);
                        
                        prompts.push(prompt);
                    }
                    break;
            }

            return prompts;
        }

        /**
         * Start automation
         */
        async startAutomation() {
            if (this.isRunning) {
                this.showNotification('Automation is already running', 'warning');
                return;
            }

            // Determine iterations
            let iterations;
            const mode = this.settings.PROMPT_MODE || 'multiple';
            
            if (mode === 'multiple' && !this.settings.OVERRIDE_ITERATIONS) {
                // Auto-detect from multiple prompts
                const multiplePrompts = this.settings.MULTIPLE_PROMPTS
                    ? this.settings.MULTIPLE_PROMPTS.split('---')
                        .map(p => p.trim())
                        .filter(p => p.length > 0)
                    : [];
                iterations = multiplePrompts.length;
            } else {
                // Use configured iterations
                iterations = this.settings.DEFAULT_ITERATIONS || 10;
            }

            if (iterations <= 0) {
                this.showNotification('No prompts found or invalid iteration count', 'error');
                return;
            }

            // Get all prompts based on mode
            const prompts = this.getAllPrompts(iterations);
            if (prompts.length === 0) {
                this.showNotification('No prompts found. Please configure prompts based on selected mode', 'error');
                return;
            }

            // Update state
            this.isRunning = true;
            this.shouldStop = false;
            this.currentIndex = 0;
            this.totalPrompts = prompts.length;

            // Update UI
            this.updateButtonState();
            this.updateStatus();

            Logger.info(`Starting automation with ${prompts.length} prompts`);
            Logger.info(`Settings: Delay=${this.settings.DELAY_SECONDS}s between prompts`);
            this.showNotification(`Starting automation with ${prompts.length} prompts (Delay: ${this.settings.DELAY_SECONDS}s)`, 'info');

            // Run all prompts sequentially
            try {
                await this.runAllPrompts(prompts);
                
                if (!this.shouldStop) {
                    this.showNotification('Automation completed successfully', 'success');
                    Logger.success('Automation completed successfully');
                }
            } catch (error) {
                Logger.error('Automation error:', error);
                this.showNotification(`Automation error: ${error.message}`, 'error');
            } finally {
                // Clean up state
                this.isRunning = false;
                this.shouldStop = false;
                this.currentIndex = 0;
                this.updateButtonState();
                this.updateStatus();
            }
        }

        /**
         * Stop automation
         */
        stopAutomation() {
            if (!this.isRunning) {
                return;
            }

            Logger.info('Stopping automation');
            this.shouldStop = true;
            this.showNotification('Stopping automation...', 'info');
        }

        /**
         * Parse prompts from text (supports both newlines and ---)
         * Logic:
         * - If text contains '---', split by '---' first, then split each part by newlines
         * - If text doesn't contain '---', split directly by newlines
         * - Each non-empty line becomes a separate prompt
         */
        parsePrompts(text) {
            if (!text || !text.trim()) {
                return [];
            }

            const prompts = [];
            
            // Check if text contains '---' separator
            if (text.includes('---')) {
                // Split by --- first
                const parts = text.split('---');
                
                for (const part of parts) {
                    const trimmed = part.trim();
                    if (trimmed.length > 0) {
                        // Split each part by newlines - each line becomes a separate prompt
                        const lines = trimmed.split('\n')
                            .map(l => l.trim())
                            .filter(l => l.length > 0);
                        
                        // Add each line as a separate prompt
                        prompts.push(...lines);
                    }
                }
            } else {
                // No '---' separator, split directly by newlines
                const lines = text.split('\n')
                    .map(l => l.trim())
                    .filter(l => l.length > 0);
                
                prompts.push(...lines);
            }

            Logger.debug(`Parsed ${prompts.length} prompts from text`);
            return prompts;
        }

        /**
         * Run all prompts sequentially
         */
        async runAllPrompts(prompts) {
            Logger.info(`ðŸš€ Starting prompt automation with ${prompts.length} prompts...`);
            
            for (let i = 0; i < prompts.length; i++) {
                // Check if we should stop
                if (this.shouldStop) {
                    Logger.info('Automation stopped by user');
                    break;
                }

                this.currentIndex = i + 1;
                this.updateStatus();
                
                await this.processPrompt(prompts[i], i);
                
                // Add delay between prompts (except for the last one)
                if (i < prompts.length - 1 && !this.shouldStop) {
                    const delaySeconds = this.settings.DELAY_SECONDS || 3;
                    const delayMs = delaySeconds * 1000;
                    Logger.info(`â±ï¸ Waiting ${delaySeconds} seconds before next prompt (delay between prompts)...`);
                    await this.delay(delayMs);
                    Logger.debug(`âœ… Delay completed, proceeding to next prompt`);
                }
            }
            
            Logger.info('ðŸŽ‰ All prompts processed');
        }

        /**
         * Process a single prompt
         */
        async processPrompt(prompt, index) {
            Logger.info(`âž¡ï¸ Processing prompt ${index + 1}/${this.totalPrompts}: "${prompt.substring(0, 50)}..."`);
            
            try {
                // Clear prompt area if enabled
                if (this.settings.AUTO_CLEAR_PROMPT) {
                    await this.clearPromptArea();
                    await this.delay(200);
                }

                // Type the prompt
                await this.typePrompt(prompt);
                
                // Small delay to let the UI settle
                await this.delay(500);
                
                // Click send button
                await this.clickSendButton();
                
                // Small delay to ensure the request is sent
                await this.delay(500);
                
                Logger.success(`âœ… Prompt ${index + 1} sent`);
            } catch (error) {
                Logger.error(`ðŸš¨ Error on prompt ${index + 1}:`, error.message);
                throw error;
            }
        }

        /**
         * Clear prompt area
         */
        async clearPromptArea() {
            const promptArea = this.findPromptArea();
            if (!promptArea) {
                Logger.warn('Prompt area not found for clearing');
                return;
            }

            try {
                // Clear contenteditable
                promptArea.textContent = '';
                promptArea.innerHTML = '<p class="x1oj8htv x2dq9o6 xxzylry x1mfz1tq xdj266r x14z9mp xat24cr x1lziwak xv54qhq" dir="auto"><br></p>';
                
                // Dispatch events
                promptArea.dispatchEvent(new InputEvent('input', { bubbles: true }));
                promptArea.dispatchEvent(new Event('change', { bubbles: true }));
                
                Logger.debug('Prompt area cleared');
            } catch (error) {
                Logger.error('Error clearing prompt area:', error);
            }
        }

        /**
         * Type prompt into contenteditable area
         */
        async typePrompt(prompt) {
            try {
                const promptArea = this.findPromptArea();
                if (!promptArea) {
                    throw new Error("Prompt area not found");
                }
                
                return await this.typeIntoContentEditable(promptArea, prompt);
            } catch (error) {
                throw new Error("âŒ Typing failed: " + error.message);
            }
        }

        /**
         * Find prompt area element
         */
        findPromptArea() {
            for (const selector of MetaAIMediaEnhancer.SELECTORS.PROMPT_AREA) {
                const element = document.querySelector(selector);
                if (element && element.offsetParent !== null) {
                    return element;
                }
            }
            return null;
        }

        /**
         * Type into a contenteditable element
         */
        async typeIntoContentEditable(element, text) {
            element.focus();
            
            // Clear existing content
            element.textContent = '';
            element.innerHTML = '<p class="x1oj8htv x2dq9o6 xxzylry x1mfz1tq xdj266r x14z9mp xat24cr x1lziwak xv54qhq" dir="auto"><br></p>';
            
            // Set text content
            const p = element.querySelector('p') || element;
            p.textContent = text;
            
            // Dispatch events to trigger React/Facebook's event handlers
            element.dispatchEvent(new InputEvent('input', { 
                bubbles: true, 
                cancelable: true,
                inputType: 'insertText',
                data: text
            }));
            
            element.dispatchEvent(new Event('change', { bubbles: true }));
            
            // Also try composition events for better compatibility (if available)
            if (typeof CompositionEvent !== 'undefined') {
                try {
                    element.dispatchEvent(new CompositionEvent('compositionstart', { bubbles: true }));
                    element.dispatchEvent(new CompositionEvent('compositionupdate', { bubbles: true, data: text }));
                    element.dispatchEvent(new CompositionEvent('compositionend', { bubbles: true, data: text }));
                } catch (e) {
                    Logger.debug('CompositionEvent not supported, skipping');
                }
            }
            
            Logger.debug(`âŒ¨ï¸ Typed: "${text.substring(0, 50)}..."`);
            
            // Small delay to ensure the text is set
            await this.delay(300);
        }

        /**
         * Click send button
         */
        async clickSendButton(retries = 10) {
            const selectors = MetaAIMediaEnhancer.SELECTORS.SEND_BUTTON;

            for (let attempt = 0; attempt < retries; attempt++) {
                for (const selector of selectors) {
                    const button = document.querySelector(selector);
                    if (button && button.offsetParent !== null) {
                        const isDisabled = button.getAttribute('aria-disabled') === 'true';
                        if (!isDisabled) {
                            const clickEvent = MouseEventUtils.createClickEvent({
                                bubbles: true,
                                cancelable: true,
                                programmatic: true
                            });
                            button.dispatchEvent(clickEvent);
                            Logger.debug(`ðŸ“¤ Clicked Send button using selector: ${selector}`);
                            await this.delay(200);
                            return;
                        }
                    }
                }

                Logger.debug(`â± Waiting for Send button to be ready... (attempt ${attempt + 1}/${retries})`);
                await this.delay(500);
            }

            // Log available buttons for debugging (language-agnostic)
            const allButtons = document.querySelectorAll('div[role="button"]');
            Logger.error(`âŒ Send button not found or disabled. Checked ${selectors.length} selectors. Found ${allButtons.length} role="button" elements:`,
                Array.from(allButtons).map(btn => ({
                    ariaLabel: btn.getAttribute('aria-label'),
                    ariaDisabled: btn.getAttribute('aria-disabled'),
                    visible: btn.offsetParent !== null,
                    classes: btn.className,
                    hasSendIcon: !!btn.querySelector('svg path[d^="M16.0279"]')
                }))
            );

            throw new Error("âŒ Send button not found or never became enabled");
        }

        /**
         * Update button state
         */
        updateButtonState() {
            if (this.toggleButton) {
                if (this.isRunning) {
                    this.toggleButton.setText('Stop Automation');
                    this.toggleButton.setTheme('danger');
                } else {
                    this.toggleButton.setText('Start Automation');
                    this.toggleButton.setTheme('primary');
                }
            }
        }

        /**
         * Update status display
         */
        updateStatus() {
            if (this.statusElement) {
                if (this.isRunning) {
                    this.statusElement.textContent = `Running: ${this.currentIndex}/${this.totalPrompts}`;
                    this.statusElement.style.background = '#e3f2fd';
                    this.statusElement.style.color = '#1976d2';
                } else {
                    this.statusElement.textContent = 'Ready to start';
                    this.statusElement.style.background = '#f5f5f5';
                    this.statusElement.style.color = '#666';
                }
            }
        }

        /**
         * Handle URL changes
         */
        handleUrlChange(newUrl, oldUrl) {
            Logger.debug(`URL changed from ${oldUrl} to ${newUrl}`);
            // Could reset state or handle navigation here if needed
        }

        /**
         * Handle settings changed event
         */
        handleSettingsChanged(data) {
            Logger.debug('Settings changed:', data);
        }

        /**
         * Show notification
         */
        showNotification(message, type = 'info') {
            if (!this.settings.SHOW_NOTIFICATIONS) {
                Logger.info(`[NOTIFICATION ${type.toUpperCase()}] ${message}`);
                return;
            }

            switch (type) {
                case 'success':
                    Notification.success(message, {
                        duration: 3000,
                        position: 'top-center',
                        showProgress: true
                    });
                    break;
                case 'warning':
                    Notification.warning(message, {
                        duration: 4000,
                        position: 'top-center',
                        showProgress: true
                    });
                    break;
                case 'error':
                    Notification.error(message, {
                        duration: 5000,
                        position: 'top-center',
                        showProgress: true
                    });
                    break;
                case 'info':
                default:
                    Notification.info(message, {
                        duration: 3000,
                        position: 'top-center',
                        showProgress: true
                    });
                    break;
            }
            
            Logger.info(`[NOTIFICATION ${type.toUpperCase()}] ${message}`);
        }
    }

    /**
     * Initialize the enhancer when the page is ready
     */
    function init() {
        Logger.info("Starting Meta AI Media Enhancer initialization");
        
        if (!window.location.hostname.includes('meta.ai') || !window.location.pathname.includes('/media')) {
            Logger.warn("Not on Meta AI Media page, script will not run");
            return;
        }

        new MetaAIMediaEnhancer();
    }

    // Start initialization
    init();

})();
