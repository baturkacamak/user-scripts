// ==UserScript==
// @name        Google AI Studio Enhancer
// @description Copy all AI chatbot responses and auto-click Run button for specified iterations
// @namespace   https://github.com/baturkacamak/userscripts
// @version     1.0.0
// @author      Batur Kacamak
// @license     MIT
// @homepage    https://github.com/baturkacamak/userscripts/tree/master/userscripts/google-ai-studio-enhancer#readme
// @homepageURL https://github.com/baturkacamak/userscripts/tree/master/userscripts/google-ai-studio-enhancer#readme
// @supportURL  https://github.com/baturkacamak/userscripts/issues
// @downloadURL https://github.com/baturkacamak/userscripts/raw/master/userscripts/google-ai-studio-enhancer/google-ai-studio-enhancer.user.js
// @updateURL   https://github.com/baturkacamak/userscripts/raw/master/userscripts/google-ai-studio-enhancer/google-ai-studio-enhancer.user.js
// @match       https://aistudio.google.com/*
// @icon        https://aistudio.google.com/static/favicon.ico
// @run-at      document-idle
// @grant       GM_setClipboard
// @grant       GM_getValue
// @grant       GM_setValue
// ==/UserScript==

// !!!!! ATTENTION !!!!!
// DO NOT EDIT THIS FILE DIRECTLY!
// This file is automatically generated from the source script.
// Any direct modifications will be overwritten during the next build.
// Please make your changes in the original source file.
//

(function () {
    'use strict';

    /**
     * Enhanced Logger - A feature-rich logging utility
     * Supports log levels, styling, grouping, caller info, filtering, persistence, exporting, and more
     */
    class Logger {
        static DEBUG = true;
        static PREFIX = "Userscript";
        static _customFormat = null;
        static _logHistory = [];
        static _filters = new Set();
        static _lastTimestamp = null;
        static _persist = false;
        static _mock = false;
        static _theme = {
            debug: "color: #3498db; font-weight: bold;",
            info: "color: #1abc9c; font-weight: bold;",
            warn: "color: #f39c12; font-weight: bold;",
            error: "color: #e74c3c; font-weight: bold;",
            success: "color: #2ecc71; font-weight: bold;",
            trace: "color: #8e44ad; font-weight: bold;",
            htmlTitle: "color: #9b59b6; font-weight: bold;",
            htmlContent: "color: #2c3e50;",
            toggle: "color: #f39c12; font-weight: bold;"
        };
        static _emojis = {
            debug: "\uD83D\uDC1B",
            info: "\u2139\uFE0F",
            warn: "\u26A0\uFE0F",
            error: "\u274C",
            success: "\u2705",
            trace: "\uD83D\uDCCC",
            html: "\uD83E\uDDE9",
            toggle: "\uD83C\uDF9B\uFE0F"
        };

        static setTimeFormat(locale = "en-US", use12Hour = false) {
            this._customFormat = {locale, hour12: use12Hour};
        }

        static _detectTimeFormat() {
            try {
                const testDate = new Date(Date.UTC(2020, 0, 1, 13, 0, 0));
                const locale = navigator.language || "tr-TR";
                const timeString = testDate.toLocaleTimeString(locale);
                const is12Hour = timeString.toLowerCase().includes("pm") || timeString.toLowerCase().includes("am");
                return {locale, hour12: is12Hour};
            } catch (e) {
                return {locale: "tr-TR", hour12: false};
            }
        }

        static _timestamp() {
            const now = new Date();

            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
            const year = now.getFullYear();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const milliseconds = String(now.getMilliseconds()).padStart(3, '0');

            const time = `${day}/${month}/${year}, ${hours}:${minutes}:${seconds}.${milliseconds}`;

            let diff = "";
            if (this._lastTimestamp) {
                const ms = now - this._lastTimestamp;
                diff = ` [+${(ms / 1000).toFixed(3)}s]`; // Keep 3 decimal places for ms in diff
            }
            this._lastTimestamp = now;
            return `${time}${diff}`;
        }

        static _getCaller() {
            const err = new Error();
            const stack = err.stack?.split("\n")[3];
            return stack ? stack.trim() : "(unknown)";
        }

        static _log(level, ...args) {
            if (!this.DEBUG && level === "debug") return;
            if (this._filters.size && !args.some(arg => this._filters.has(arg))) return;
            const emoji = this._emojis[level] || '';
            const style = this._theme[level] || '';
            const timestamp = this._timestamp();
            const caller = this._getCaller();

            const message = [
                `%c${timestamp} %c${emoji} [${this.PREFIX} ${level.toUpperCase()}]%c:`,
                "color: gray; font-style: italic;",
                style,
                "color: inherit;",
                ...args,
                `\nCaller: ${caller}`
            ];

            this._logHistory.push({timestamp, level, args});

            if (this._persist) localStorage.setItem("LoggerHistory", JSON.stringify(this._logHistory));
            if (!this._mock) console.log(...message);
        }

        static debug(...args) {
            this._log("debug", ...args);
        }

        static info(...args) {
            this._log("info", ...args);
        }

        static warn(...args) {
            this._log("warn", ...args);
        }

        static error(...args) {
            this._log("error", ...args);
        }

        static success(...args) {
            this._log("success", ...args);
        }

        static trace(...args) {
            this._log("trace", ...args);
            console.trace();
        }

        static logHtml(title, htmlContent) {
            const shortContent = htmlContent.substring(0, 1500) + "...";
            this._log("html", `[${title}]`, shortContent);
            if (!this._mock) {
                console.groupCollapsed(`%c\uD83E\uDDE9 HTML Details (${title})`, this._theme.htmlTitle);
                console.log("%cComplete HTML:", this._theme.htmlTitle);
                console.log(`%c${htmlContent}`, this._theme.htmlContent);
                console.groupEnd();
            }
        }

        static setPrefix(prefix) {
            this.PREFIX = prefix;
        }

        static setTheme(theme) {
            Object.assign(this._theme, theme);
        }

        static addFilter(tag) {
            this._filters.add(tag);
        }

        static clearFilters() {
            this._filters.clear();
        }

        static persistLogs(enable = true) {
            this._persist = enable;
        }

        static mock(enable = true) {
            this._mock = enable;
        }

        static group(label) {
            if (!this._mock) console.group(label);
        }

        static groupEnd() {
            if (!this._mock) console.groupEnd();
        }

        static step(msg) {
            this.info(`\u2705 ${msg}`);
        }

        static hello() {
            this.info("Hello, dev! \uD83D\uDC4B Ready to debug?");
        }

        static downloadLogs(filename = "logs.json") {
            const blob = new Blob([JSON.stringify(this._logHistory, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        static autoClear(intervalMs) {
            setInterval(() => {
                this._logHistory = [];
                if (this._persist) localStorage.removeItem("LoggerHistory");
            }, intervalMs);
        }
    }

    /**
     * HTMLUtils - Utilities for HTML manipulation
     * Provides functions for escaping HTML, encoding/decoding entities, etc.
     */
    class HTMLUtils {
        /**
         * Escape special HTML characters to prevent XSS
         * @param {string} str - The string to escape
         * @return {string} - The escaped string
         */
        static escapeHTML(str) {
            const escapeMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '\'': '&#39;',
                '"': '&quot;',
            };
            return str.replace(/[&<>'"]/g, (tag) => escapeMap[tag] || tag);
        }

        /**
         * Escape XML special characters
         * @param {string} str - The string to escape
         * @return {string} - The escaped string
         */
        static escapeXML(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        /**
         * Convert a plain text string to sanitized HTML
         * @param {string} text - The text to convert
         * @return {string} - HTML with line breaks and links
         */
        static textToHtml(text) {
            if (!text) return '';

            // First escape HTML
            let html = this.escapeHTML(text);

            // Convert line breaks to <br>
            html = html.replace(/\n/g, '<br>');

            // Convert URLs to links
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            html = html.replace(urlRegex, (url) => `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`);

            return html;
        }

        /**
         * * Wait for a specific element to appear in the DOM.
         *  * Continues checking using requestAnimationFrame until it appears,
         *  * a timeout is reached, or the maximum number of attempts is exceeded.
         *  *
         *  * @param {string} selector - CSS selector of the target element.
         *  * @param {number} [timeout=10000] - Maximum time in milliseconds to wait.
         *  * @param {Document|Element} [root=document] - DOM root to query from.
         *  * @param {number} [maxRetries=60] - Maximum number of requestAnimationFrame attempts.
         *  * @returns {Promise<Element>} Resolves with the found element or rejects on timeout.
         */
        static waitForElement(selector, timeout = 10000, root = document, maxRetries = 60) {
            return new Promise((resolve, reject) => {
                const startTime = Date.now();
                let attempts = 0;

                function checkElement() {
                    const element = root.querySelector(selector);
                    if (element) {
                        resolve(element);
                        return;
                    }

                    if ((Date.now() - startTime > timeout) || (attempts >= maxRetries)) {
                        reject(new Error(`Timeout waiting for element: ${selector}`));
                        return;
                    }

                    attempts++;
                    requestAnimationFrame(checkElement);
                }

                checkElement();
            });
        }

        static decodeHtmlEntities(encodedString) {
            if (!encodedString || typeof encodedString !== 'string') return encodedString;
            const textarea = document.createElement('textarea');
            textarea.innerHTML = encodedString;
            return textarea.value;
        }

        static extractMetaTags(html) {
            if (!html) return {};

            const metaTags = {};
            const regex = /<meta\s+(?:property|name)=["']([^"']+)["']\s+content=["']([^"']+)["']/gi;

            let match;
            while (match = regex.exec(html)) {
                if (match[1] && match[2]) {
                    metaTags[match[1]] = this.decodeHtmlEntities(match[2]);
                }
            }

            return metaTags;
        }
    }

    /**
     * StyleManager - Utility for CSS style management
     * Handles adding and removing styles, theme variables, etc.
     */
    class StyleManager {
        static styleElements = new Map();

        /**
         * Add CSS styles to the document
         * @param {string} css - CSS string to add
         * @param {string} id - Optional ID for the style element
         * @returns {HTMLStyleElement} - The created style element
         */
        static addStyles(css, id = null) {
            const style = document.createElement('style');
            style.textContent = css;

            if (id) {
                style.id = id;
                // Remove any existing style with the same ID
                if (this.styleElements.has(id)) {
                    this.removeStyles(id);
                }
                this.styleElements.set(id, style);
            }

            document.head.appendChild(style);
            return style;
        }

        /**
         * Remove styles by ID
         * @param {string} id - ID of the style element to remove
         * @returns {boolean} - True if styles were removed, false otherwise
         */
        static removeStyles(id) {
            if (!this.styleElements.has(id)) return false;

            const styleElement = this.styleElements.get(id);
            if (styleElement && styleElement.parentNode) {
                styleElement.parentNode.removeChild(styleElement);
            }

            this.styleElements.delete(id);
            return true;
        }

        /**
         * Check if styles with a given ID have already been added
         * @param {string} id - ID of the style element to check
         * @returns {boolean} - True if styles exist, false otherwise
         */
        static hasStyles(id) {
            return this.styleElements.has(id) || document.getElementById(id) !== null;
        }

        /**
         * Apply CSS variables for theming
         * @param {Object} variables - Object with variable names and values
         * @param {string} selector - CSS selector to apply variables to (default: :root)
         */
        static applyThemeVariables(variables, selector = ':root') {
            let css = `${selector} {\n`;

            Object.entries(variables).forEach(([name, value]) => {
                // Ensure variable names start with --
                const varName = name.startsWith('--') ? name : `--${name}`;
                css += `  ${varName}: ${value};\n`;
            });

            css += `}\n`;

            this.addStyles(css, 'theme-variables');
        }

        /**
         * Add styles to handle animations
         * @param {Object} animations - Key-value pairs of animation name and keyframes
         */
        static addAnimations(animations) {
            let css = '';

            Object.entries(animations).forEach(([name, keyframes]) => {
                css += `@keyframes ${name} {\n${keyframes}\n}\n\n`;
            });

            this.addStyles(css, 'animations');
        }
    }

    /**
     * Debouncer - A utility class for creating debounced and throttled functions
     *
     * Provides sophisticated debouncing and throttling with options for immediate/delayed
     * execution, cancellation, and flushing of pending operations.
     */
    class Debouncer {
      /**
         * Creates a debounced version of a function that delays invocation until after
         * a specified wait time has elapsed since the last time the debounced function was called.
         *
         * @param {Function} func - The function to debounce.
         * @param {number} wait - The number of milliseconds to delay.
         * @param {Object} [options] - The options object.
         * @param {boolean} [options.leading=false] - Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] - Specify invoking on the trailing edge of the timeout.
         * @return {Function} Returns the new debounced function.
         */
      static debounce(func, wait, options = {}) {
        const {leading = false, trailing = true} = options;
        let timeout;
        let lastArgs;
        let lastThis;
        let lastCallTime;
        let result;

        function invokeFunc() {
          const args = lastArgs;
          const thisArg = lastThis;

          lastArgs = lastThis = undefined;
          result = func.apply(thisArg, args);
          return result;
        }

        function startTimer(pendingFunc, wait) {
          return setTimeout(pendingFunc, wait);
        }

        function cancelTimer(id) {
          clearTimeout(id);
        }

        function trailingEdge() {
          timeout = undefined;

          // Only invoke if we have `lastArgs` which means `func` has been debounced at least once
          if (trailing && lastArgs) {
            return invokeFunc();
          }

          lastArgs = lastThis = undefined;
          return result;
        }

        function leadingEdge() {
          // Reset any `maxWait` timer
          timeout = startTimer(trailingEdge, wait);

          // Invoke the leading edge
          return leading ? invokeFunc() : result;
        }

        function cancel() {
          if (timeout !== undefined) {
            cancelTimer(timeout);
          }
          lastArgs = lastThis = lastCallTime = undefined;
          timeout = undefined;
        }

        function flush() {
          return timeout === undefined ? result : trailingEdge();
        }

        function debounced(...args) {
          const time = Date.now();
          const isInvoking = shouldInvoke(time);

          lastArgs = args;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timeout === undefined) {
              return leadingEdge();
            }
            if (isInvoking) {
              // Handle invocations in a tight loop
              timeout = startTimer(trailingEdge, wait);
              return invokeFunc();
            }
          }
          if (timeout === undefined) {
            timeout = startTimer(trailingEdge, wait);
          }
          return result;
        }

        function shouldInvoke(time) {
          const timeSinceLastCall = time - (lastCallTime || 0);

          // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit
          return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
                    (0 > timeSinceLastCall));
        }

        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      /**
         * Creates a throttled function that only invokes func at most once per
         * every wait milliseconds.
         *
         * @param {Function} func - The function to throttle.
         * @param {number} wait - The number of milliseconds to throttle invocations to.
         * @param {Object} [options] - The options object.
         * @param {boolean} [options.leading=true] - Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] - Specify invoking on the trailing edge of the timeout.
         * @return {Function} Returns the new throttled function.
         */
      static throttle(func, wait, options = {}) {
        return this.debounce(func, wait, {
          leading: false !== options.leading,
          trailing: false !== options.trailing,
        });
      }
    }

    /**
     * PubSub - A simple publish/subscribe pattern implementation
     * Enables components to communicate without direct references
     */
    class PubSub {
        static #events = {};

        /**
         * Subscribe to an event
         * @param {string} event - Event name
         * @param {Function} callback - Callback function
         * @return {string} Subscription ID
         */
        static subscribe(event, callback) {
            if (!this.#events[event]) {
                this.#events[event] = [];
            }

            const subscriptionId = `${event}_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
            this.#events[event].push({callback, subscriptionId});
            return subscriptionId;
        }

        /**
         * Unsubscribe from an event
         * @param {string} subscriptionId - Subscription ID
         * @return {boolean} Success state
         */
        static unsubscribe(subscriptionId) {
            for (const event in this.#events) {
                const index = this.#events[event].findIndex(sub => sub.subscriptionId === subscriptionId);
                if (index !== -1) {
                    this.#events[event].splice(index, 1);
                    return true;
                }
            }
            return false;
        }

        /**
         * Publish an event
         * @param {string} event - Event name
         * @param {any} data - Data to pass to subscribers
         */
        static publish(event, data) {
            if (!this.#events[event]) {
                return;
            }

            this.#events[event].forEach(sub => {
                sub.callback(data);
            });
        }

        /**
         * Clear all subscriptions
         * @param {string} [event] - Optional event name to clear only specific event
         */
        static clear(event) {
            if (event) {
                delete this.#events[event];
            } else {
                this.#events = {};
            }
        }
    }

    class DataCache {
      constructor(logger) {
        this.logger = logger;
      }

      get(key) {
        try {
          const value = localStorage.getItem(key);
          if (value !== null) {
            const { data, expires } = JSON.parse(value);
            if (expires === null || new Date(expires) > new Date()) {
              return data;
            }
            localStorage.removeItem(key);
            this.logger.log(`Cache expired and removed for key: ${key}`);
          }
        } catch (e) {
          this.logger.error(`Error getting cache for key ${key}:`, e);
          localStorage.removeItem(key); // Remove potentially corrupted data
        }
        return null;
      }

      set(key, value, expirationDays) {
        try {
          const expires = expirationDays ?
            new Date(Date.now() + expirationDays * 24 * 60 * 60 * 1000) :
            null;
          localStorage.setItem(key, JSON.stringify({ data: value, expires }));
          this.logger.log(`Cache set for key: ${key}, expires: ${expires}`);
        } catch (e) {
          this.logger.error(`Error setting cache for key ${key}:`, e);
        }
      }
    }

    /**
     * UserInteractionDetector - A utility class for detecting genuine user interactions
     *
     * Provides robust detection of user-initiated events vs programmatic ones
     * with multiple fallback mechanisms and integration with other utility classes.
     */

    class UserInteractionDetector {
      /**
         * Get a singleton instance - this allows sharing the detector across modules
         * @param {Object} [options] - Configuration options (only used for first initialization)
         * @return {UserInteractionDetector} Singleton instance
         * @static
         */
      static getInstance(options = {}) {
        if (!window.UserInteractionDetector) {
          window.UserInteractionDetector = {};
        }

        if (!window.UserInteractionDetector._instance) {
          window.UserInteractionDetector._instance = new UserInteractionDetector(options);
        }

        return window.UserInteractionDetector._instance;
      }
      /**
         * Create a new UserInteractionDetector
         * @param {Object} options - Configuration options
         * @param {number} [options.interactionWindow=150] - Time window in ms to consider events related to user interaction
         * @param {number} [options.interactionThrottle=50] - Minimum ms between interaction broadcasts
         * @param {boolean} [options.debug=false] - Enable debug logging
         * @param {string} [options.namespace='userscripts'] - Namespace for events
         * @param {boolean} [options.trackGlobalInteractions=true] - Whether to track interactions on document/window level
         * @param {boolean} [options.trackProgrammaticEvents=true] - Whether to track programmatic events like dispatchEvent
         */
      constructor(options = {}) {
        // Configuration
        this.interactionWindow = options.interactionWindow || 150; // Time window in ms
        this.interactionThrottle = options.interactionThrottle || 50; // Throttle in ms
        this.debug = options.debug || false;
        this.namespace = options.namespace || 'userscripts';
        this.trackGlobalInteractions = (false !== options.trackGlobalInteractions); // Default true
        this.trackProgrammaticEvents = (false !== options.trackProgrammaticEvents); // Default true

        // State tracking
        this._isInteracting = false;
        this._lastInteractionTime = 0;
        this._interactionTypes = new Set();
        this._lastEventTarget = null;
        this._lastEventType = null;
        this._interactionTimer = null;
        this._throttleTimer = null;
        this._overrideTimestamp = null;
        this._userInteractionCounter = 0;
        this._programmaticEventCounter = 0;
        this._patched = new Set();

        // Event tracking arrays
        this._recentEvents = [];
        this._trackedElements = new Map(); // element -> {events: [], handlers: []}

        // Initialize
        this._initTracking();

        // Log initialization
        if (this.debug) {
          Logger.debug('UserInteractionDetector initialized with options:', {
            interactionWindow: this.interactionWindow,
            interactionThrottle: this.interactionThrottle,
            namespace: this.namespace,
            trackGlobalInteractions: this.trackGlobalInteractions,
            trackProgrammaticEvents: this.trackProgrammaticEvents,
          });
        }
      }


      /**
         * Track a specific element for interaction events
         * You can use this for elements you want to specifically monitor
         * @param {HTMLElement} element - The element to track
         * @param {Array<string>} eventTypes - Event types to track
         * @param {Function} callback - Callback to invoke with interaction info
         * @return {Function} Unsubscribe function
         */
      trackElement(element, eventTypes = ['click', 'touchstart', 'keydown'], callback) {
        if (!element || !element.addEventListener) {
          this._logError('Invalid element provided to trackElement');
          return () => {
          }; // No-op unsubscribe
        }

        // Initialize tracking data for this element if needed
        if (!this._trackedElements.has(element)) {
          this._trackedElements.set(element, {
            events: [],
            handlers: [],
          });
        }

        const elementData = this._trackedElements.get(element);
        const handlers = [];

        // Create handler for each event type
        eventTypes.forEach((eventType) => {
          const handler = (e) => {
            const isUserInitiated = this.isUserEvent(e);
            const interactionData = {
              event: e,
              timestamp: Date.now(),
              isUserInitiated,
              globalInteracting: this._isInteracting,
              timeSinceLastInteraction: Date.now() - this._lastInteractionTime,
            };

            // Track this event
            elementData.events.unshift(interactionData);
            if (5 < elementData.events.length) {
              elementData.events.pop();
            }

            // Call the callback
            callback(interactionData);
          };

          // Attach the handler
          element.addEventListener(eventType, handler);
          handlers.push({eventType, handler});
          elementData.handlers.push({eventType, handler});
        });

        this._log(`Now tracking ${eventTypes.join(', ')} events on element:`, element);

        // Return unsubscribe function
        return () => {
          handlers.forEach(({eventType, handler}) => {
            element.removeEventListener(eventType, handler);

            // Remove from tracked handlers
            if (this._trackedElements.has(element)) {
              const data = this._trackedElements.get(element);
              data.handlers = data.handlers.filter((h) => h.handler !== handler);

              // Clean up if no more handlers
              if (0 === data.handlers.length) {
                this._trackedElements.delete(element);
              }
            }
          });

          this._log('Unsubscribed from element events');
        };
      }

      /**
         * Check if an event was initiated by a real user interaction
         * @param {Event} event - The event to check
         * @return {boolean} True if the event was likely initiated by a user
         */
      isUserEvent(event) {
        if (!event) return false;

        // Primary check: isTrusted property (most reliable)
        if (event.isTrusted) {
          return true;
        }

        // Secondary check: event occurred during known interaction window
        if (this._isInteracting) {
          const timeSinceInteraction = Date.now() - this._lastInteractionTime;
          if (timeSinceInteraction < this.interactionWindow) {
            this._log(`Event occurred ${timeSinceInteraction}ms after user interaction`);
            return true;
          }
        }

        // Tertiary check: was the event part of a trusted cascade?
        // (sometimes events trigger other events programmatically, but they're still part of user input)
        const cascadeWindow = 50; // ms to consider event cascades
        const recentTrustedEvents = this._recentEvents.filter((e) =>
          e.trusted && Date.now() - e.timestamp < cascadeWindow,
        );

        if (0 < recentTrustedEvents.length) {
          this._log(`Event may be part of trusted cascade (${recentTrustedEvents.length} recent trusted events)`);
          return true;
        }

        // Special check for specific event types that are always user-initiated
        const alwaysUserEvents = ['beforeinput', 'mousedown', 'touchstart', 'keydown'];
        if (alwaysUserEvents.includes(event.type) && !event._detectedByUserInteractionDetector) {
          this._log(`Event type ${event.type} is typically user-initiated`);
          return true;
        }

        return false;
      }

      /**
         * Check if an element's event was likely initiated by a real user
         * @param {HTMLElement} element - The element to check
         * @param {string} eventType - The type of event
         * @param {number} [timeWindow=500] - Time window to look back in ms
         * @return {boolean} True if there's evidence the user interacted with this element
         */
      didUserInteractWith(element, eventType, timeWindow = 500) {
        if (!element) return false;

        // First check if we're tracking this element
        if (this._trackedElements.has(element)) {
          const data = this._trackedElements.get(element);
          const recentEvents = data.events.filter((entry) =>
            entry.event.type === eventType &&
                    Date.now() - entry.timestamp < timeWindow &&
                    entry.isUserInitiated,
          );

          if (0 < recentEvents.length) {
            return true;
          }
        }

        // Fallback: check if this element was the last interaction target
        if (this._lastEventTarget === element &&
                this._lastEventType === eventType &&
                Date.now() - this._lastInteractionTime < timeWindow) {
          return true;
        }

        // Final fallback: check if element contains last interaction target
        if (this._lastEventTarget &&
                element.contains(this._lastEventTarget) &&
                Date.now() - this._lastInteractionTime < timeWindow) {
          return true;
        }

        return false;
      }

      /**
         * Check if the user is currently interacting with the page
         * @return {boolean} True if user interaction was detected within the interaction window
         */
      isInteracting() {
        return this._isInteracting;
      }

      /**
         * Get time (ms) since last user interaction
         * @return {number} Milliseconds since last interaction, or Infinity if no interaction yet
         */
      getTimeSinceLastInteraction() {
        if (0 === this._lastInteractionTime) return Infinity;
        return Date.now() - this._lastInteractionTime;
      }

      /**
         * Check if an interaction happened recently within the given time window
         * @param {number} withinMs - Time window in milliseconds
         * @return {boolean} True if interaction happened within the specified window
         */
      interactedWithin(withinMs) {
        return this.getTimeSinceLastInteraction() < withinMs;
      }
      /**
         * Get statistics about detected interactions
         * @return {Object} Interaction statistics
         */
      getStats() {
        return {
          isInteracting: this._isInteracting,
          lastInteractionTime: this._lastInteractionTime,
          timeSinceLastInteraction: this.getTimeSinceLastInteraction(),
          interactionTypes: Array.from(this._interactionTypes),
          userInteractionCount: this._userInteractionCounter,
          programmaticEventCount: this._programmaticEventCounter,
          trackedElements: this._trackedElements.size,
          recentEvents: this._recentEvents.length,
        };
      }
      /**
         * Reset all tracking state
         */
      reset() {
        this._resetInteractionState();
        this._lastInteractionTime = 0;
        this._userInteractionCounter = 0;
        this._programmaticEventCounter = 0;
        this._recentEvents = [];

        // Clear tracked elements
        this._trackedElements.forEach((data, element) => {
          data.handlers.forEach(({eventType, handler}) => {
            try {
              element.removeEventListener(eventType, handler);
            } catch (e) {
              // Element might be gone from DOM
            }
          });
        });
        this._trackedElements.clear();

        this._log('All tracking state reset');
      }
      /**
         * Clean up resources when detector is no longer needed
         */
      destroy() {
        this.reset();

        // Could unpatch event methods here, but it's generally safer
        // to leave them patched to avoid breaking other code

        this._log('Detector destroyed');
      }
      /**
         * Initialize event tracking
         * @private
         */
      _initTracking() {
        if (this.trackGlobalInteractions) {
          // Track global user interactions (capture phase to get them early)
          this._setupGlobalEventListeners();
        }

        if (this.trackProgrammaticEvents) {
          // Track programmatic events by patching EventTarget.prototype
          this._patchEventMethods();
        }
      }


      /**
         * Set up global event listeners to detect user interaction
         * @private
         */
      _setupGlobalEventListeners() {
        // Primary interaction events with capture to catch events early
        const interactionEvents = [
          'mousedown', 'mouseup', 'click', 'touchstart', 'touchend',
          'keydown', 'keyup', 'keypress', 'input', 'change', 'focus',
        ];

        const handleInteraction = this._handleGlobalInteraction.bind(this);

        interactionEvents.forEach((eventType) => {
          document.addEventListener(eventType, handleInteraction, {
            capture: true,
            passive: true, // For better performance
          });
        });

        // Special handling for scroll events (throttled)
        let scrollTimeout = null;
        const handleScroll = (e) => {
          if (!scrollTimeout) {
            scrollTimeout = setTimeout(() => {
              handleInteraction(e);
              scrollTimeout = null;
            }, 100); // Throttle scroll events
          }
        };

        window.addEventListener('scroll', handleScroll, {
          capture: true,
          passive: true,
        });

        // Track window focus/blur for tab switching context
        window.addEventListener('focus', () => {
          this._log('Window focused');
          this._overrideTimestamp = Date.now();
        });

        window.addEventListener('blur', () => {
          this._log('Window blurred - resetting interaction state');
          this._resetInteractionState();
        });

        this._log('Global event listeners registered');
      }


      /**
         * Handle a global interaction event
         * @param {Event} e - The event object
         * @private
         */
      _handleGlobalInteraction(e) {
        // Only process trusted events from the user
        if (!e.isTrusted) {
          this._log(`Ignoring untrusted event: ${e.type}`);
          return;
        }

        // Track this event in the recent events list
        this._trackEvent(e);

        // Update interaction state
        this._setInteracting(e);
      }


      /**
         * Reset interaction state
         * @private
         */
      _resetInteractionState() {
        this._isInteracting = false;
        this._interactionTypes.clear();
        this._lastEventTarget = null;
        this._lastEventType = null;
        clearTimeout(this._interactionTimer);
        this._interactionTimer = null;

        // Emit an event about interaction end
        PubSub.publish(`${this.namespace}:interaction:end`, {
          timestamp: Date.now(),
          duration: Date.now() - this._lastInteractionTime,
        });

        this._log('Interaction state reset');
      }


      /**
         * Set interaction state and schedule timeout
         * @param {Event} e - The triggering event
         * @private
         */
      _setInteracting(e) {
        const now = Date.now();
        const wasInteracting = this._isInteracting;

        // Update state
        this._isInteracting = true;
        this._lastInteractionTime = now;
        this._interactionTypes.add(e.type);
        this._lastEventTarget = e.target;
        this._lastEventType = e.type;
        this._userInteractionCounter++;

        // Clear any existing timeout and set a new one
        clearTimeout(this._interactionTimer);
        this._interactionTimer = setTimeout(() => {
          this._log(`Interaction window timeout after ${this.interactionWindow}ms`);
          this._resetInteractionState();
        }, this.interactionWindow);

        // Emit event (throttled)
        if (!wasInteracting || !this._throttleTimer) {
          if (this._throttleTimer) {
            clearTimeout(this._throttleTimer);
          }

          // Immediate first notification
          this._emitInteractionEvent(e);

          // Throttle subsequent notifications
          this._throttleTimer = setTimeout(() => {
            this._throttleTimer = null;
          }, this.interactionThrottle);
        }
      }


      /**
         * Emit interaction event via PubSub
         * @param {Event} e - The triggering event
         * @private
         */
      _emitInteractionEvent(e) {
        PubSub.publish(`${this.namespace}:interaction`, {
          timestamp: Date.now(),
          event: {
            type: e.type,
            target: e.target,
          },
          interactionTypes: Array.from(this._interactionTypes),
          interactionCount: this._userInteractionCounter,
        });

        this._log(`Emitted interaction event for ${e.type}`);
      }


      /**
         * Track an event in the recent events list
         * @param {Event} e - The event object
         * @private
         */
      _trackEvent(e) {
        const eventData = {
          type: e.type,
          timestamp: Date.now(),
          target: e.target,
          trusted: e.isTrusted,
        };

        // Add to recent events, keeping last 10
        this._recentEvents.unshift(eventData);
        if (10 < this._recentEvents.length) {
          this._recentEvents.pop();
        }
      }


      /**
         * Patch event methods to detect programmatic events
         * @private
         */
      _patchEventMethods() {
        // Don't patch twice
        if (this._patched.has('events')) return;

        // Save original methods
        const originalDispatchEvent = EventTarget.prototype.dispatchEvent;

        // Patch dispatchEvent
        EventTarget.prototype.dispatchEvent = function(event) {
          // Mark the event as detected by our utility
          event._detectedByUserInteractionDetector = true;

          // Track programmatic event
          if (window.UserInteractionDetector && window.UserInteractionDetector._instance) {
            window.UserInteractionDetector._instance._programmaticEventCounter++;

            window.UserInteractionDetector._instance._log(
                `Programmatic event detected: ${event.type} on ${this.tagName || 'EventTarget'}`,
            );
          }

          // Call original method
          return originalDispatchEvent.apply(this, arguments);
        };

        this._patched.add('events');
        this._log('Event methods patched to detect programmatic events');
      }


      /**
         * Private logging helper
         * @param {...any} args - Arguments to log
         * @private
         */
      _log(...args) {
        if (this.debug) {
          Logger.debug('[UserInteractionDetector]', ...args);
        }
      }

      /**
         * Private error logging helper
         * @param {...any} args - Arguments to log
         * @private
         */
      _logError(...args) {
        Logger.error('[UserInteractionDetector]', ...args);
      }
    }

    class UrlChangeWatcher {
      constructor(strategies = [], fireImmediately = true) {
        this.strategies = strategies;
        this.fireImmediately = fireImmediately;
        this.lastUrl = location.href;
        this.active = false;
      }

      start() {
        if (this.active) return;
        this.active = true;
        Logger.debug('UrlChangeWatcher (Strategy) started');

        this.strategies.forEach((strategy) =>
          strategy.start?.(this._handleChange.bind(this)),
        );

        if (this.fireImmediately) {
          this._handleChange(location.href, null, true);
        }
      }

      stop() {
        this.active = false;
        this.strategies.forEach((strategy) => strategy.stop?.());
        Logger.debug('UrlChangeWatcher (Strategy) stopped');
      }

      _handleChange(newUrl, oldUrl = this.lastUrl, force = false) {
        if (!force && newUrl === this.lastUrl) return;
        Logger.debug(`URL changed: ${oldUrl} → ${newUrl}`);

        this.lastUrl = newUrl;

        if (PubSub?.publish) {
          PubSub.publish('urlchange', {newUrl, oldUrl});
        }
      }
    }

    class BaseStrategy {
      constructor(callback) {
        this.callback = callback;
      }

      start() {
      }

      stop() {
      }
    }

    class PollingStrategy extends BaseStrategy {
      constructor(callback, interval = 500) {
        super(callback);
        this.interval = interval;
        this.lastUrl = location.href;
      }

      start() {
        Logger.debug('PollingStrategy started');
        this.timer = setInterval(() => {
          const current = location.href;
          if (current !== this.lastUrl) {
            Logger.debug(`Polling detected change: ${this.lastUrl} → ${current}`);
            this.callback(current, this.lastUrl);
            this.lastUrl = current;
          }
        }, this.interval);
      }

      stop() {
        clearInterval(this.timer);
        Logger.debug('PollingStrategy stopped');
      }
    }

    /**
     * Notification - A reusable UI component for toast notifications.
     * Creates customizable, temporary notifications that appear and disappear automatically.
     */

    /**
     * A reusable UI component for creating toast notifications that provide non-intrusive
     * feedback to users.
     */
    class Notification {
        /**
         * Storage for the notification container elements by position
         * @private
         */
        static _containers = {};
        /**
         * Storage for all active notifications
         * @private
         */
        static _activeNotifications = [];
        /**
         * Counter for generating unique notification IDs
         * @private
         */
        static _idCounter = 0;
        /**
         * Maximum number of notifications to show per container
         * @private
         */
        static _maxNotificationsPerContainer = 5;
        /**
         * Queue for notifications waiting to be shown
         * @private
         */
        static _queue = [];

        /**
         * Returns the unique base CSS class for the Notification component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for notifications.
         */
        static get BASE_NOTIFICATION_CLASS() {
            return 'userscripts-notification';
        }

        /**
         * Returns the CSS variable prefix used for theming the Notification component.
         * This prefix scopes all custom CSS variables related to the notification.
         *
         * @return {string} The CSS variable prefix.
         */
        static get CSS_VAR_PREFIX() {
            return '--userscripts-notification-';
        }

        /**
         * Initialize styles for all notifications.
         * These styles reference the CSS variables with our defined prefix.
         */
        static initStyles() {
            if (Notification.stylesInitialized) return;

            StyleManager.addStyles(`
      /* Container for all notifications */
      .${Notification.BASE_NOTIFICATION_CLASS}-container {
        position: fixed;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 9999;
        pointer-events: none; /* Allow clicking through the container */
        
        /* Default positioning at bottom center */
        bottom: var(${Notification.CSS_VAR_PREFIX}container-bottom, 16px);
        left: 50%;
        transform: translateX(-50%);
        
        /* Container width */
        width: var(${Notification.CSS_VAR_PREFIX}container-width, auto);
        max-width: var(${Notification.CSS_VAR_PREFIX}container-max-width, 350px);
      }
      
      /* Position variants */
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-center {
        top: var(${Notification.CSS_VAR_PREFIX}container-top, 16px);
        bottom: auto;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-left {
        top: var(${Notification.CSS_VAR_PREFIX}container-top, 16px);
        left: var(${Notification.CSS_VAR_PREFIX}container-left, 16px);
        bottom: auto;
        transform: none;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-right {
        top: var(${Notification.CSS_VAR_PREFIX}container-top, 16px);
        right: var(${Notification.CSS_VAR_PREFIX}container-right, 16px);
        left: auto;
        bottom: auto;
        transform: none;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-left {
        bottom: var(${Notification.CSS_VAR_PREFIX}container-bottom, 16px);
        left: var(${Notification.CSS_VAR_PREFIX}container-left, 16px);
        transform: none;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-right {
        bottom: var(${Notification.CSS_VAR_PREFIX}container-bottom, 16px);
        right: var(${Notification.CSS_VAR_PREFIX}container-right, 16px);
        left: auto;
        transform: none;
      }
      
      /* Individual notification toast */
      .${Notification.BASE_NOTIFICATION_CLASS} {
        position: relative;
        display: flex;
        align-items: center;
        padding: var(${Notification.CSS_VAR_PREFIX}padding, 12px 16px);
        border-radius: var(${Notification.CSS_VAR_PREFIX}border-radius, 6px);
        box-shadow: var(${Notification.CSS_VAR_PREFIX}shadow, 0 4px 12px rgba(0, 0, 0, 0.15));
        color: var(${Notification.CSS_VAR_PREFIX}color, #fff);
        font-family: var(${Notification.CSS_VAR_PREFIX}font-family, inherit);
        font-size: var(${Notification.CSS_VAR_PREFIX}font-size, 14px);
        line-height: var(${Notification.CSS_VAR_PREFIX}line-height, 1.5);
        opacity: 0;
        transform: translateY(100%);
        transition: transform 0.3s ease, opacity 0.3s ease;
        pointer-events: auto; /* Make the notification clickable */
        max-width: 100%;
        box-sizing: border-box;
        width: 100%;
        overflow: hidden;
        
        /* Progress bar at the bottom */
        &::after {
          content: '';
          position: absolute;
          bottom: 0;
          left: 0;
          height: var(${Notification.CSS_VAR_PREFIX}progress-height, 3px);
          background-color: var(${Notification.CSS_VAR_PREFIX}progress-color, rgba(255, 255, 255, 0.5));
          width: 100%;
          transform-origin: left;
          transform: scaleX(0);
        }
      }
      
      /* Visible notification */
      .${Notification.BASE_NOTIFICATION_CLASS}--visible {
        opacity: 1;
        transform: translateY(0);
      }
      
      /* Animation for progress bar */
      .${Notification.BASE_NOTIFICATION_CLASS}--with-progress::after {
        animation-name: ${Notification.BASE_NOTIFICATION_CLASS}-progress;
        animation-timing-function: linear;
        animation-fill-mode: forwards;
      }
      
      @keyframes ${Notification.BASE_NOTIFICATION_CLASS}-progress {
        from { transform: scaleX(1); }
        to { transform: scaleX(0); }
      }
      
      /* Close button */
      .${Notification.BASE_NOTIFICATION_CLASS}-close {
        background: none;
        border: none;
        color: inherit;
        opacity: 0.7;
        font-size: 18px;
        cursor: pointer;
        padding: 4px;
        margin-left: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: opacity 0.2s ease;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-close:hover {
        opacity: 1;
      }
      
      /* Icon area */
      .${Notification.BASE_NOTIFICATION_CLASS}-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 12px;
      }
      
      /* Content area */
      .${Notification.BASE_NOTIFICATION_CLASS}-content {
        flex-grow: 1;
        word-break: break-word;
      }
      
      /* Types styling */
      .${Notification.BASE_NOTIFICATION_CLASS}--info {
        background-color: var(${Notification.CSS_VAR_PREFIX}info-bg, #3498db);
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}--success {
        background-color: var(${Notification.CSS_VAR_PREFIX}success-bg, #2ecc71);
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}--warning {
        background-color: var(${Notification.CSS_VAR_PREFIX}warning-bg, #f39c12);
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}--error {
        background-color: var(${Notification.CSS_VAR_PREFIX}error-bg, #e74c3c);
      }
      
      /* Customizable style */
      .${Notification.BASE_NOTIFICATION_CLASS}--custom {
        background-color: var(${Notification.CSS_VAR_PREFIX}custom-bg, #7f8c8d);
      }
      
      /* Animation for top position variants */
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-center .${Notification.BASE_NOTIFICATION_CLASS},
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-left .${Notification.BASE_NOTIFICATION_CLASS},
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-right .${Notification.BASE_NOTIFICATION_CLASS} {
        transform: translateY(-100%);
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-center .${Notification.BASE_NOTIFICATION_CLASS}--visible,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-left .${Notification.BASE_NOTIFICATION_CLASS}--visible,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-right .${Notification.BASE_NOTIFICATION_CLASS}--visible {
        transform: translateY(0);
      }
      
      /* Give slightly different vertical spacing based on position */
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-center,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-left,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--top-right {
        flex-direction: column;
      }
      
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-center,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-left,
      .${Notification.BASE_NOTIFICATION_CLASS}-container--bottom-right {
        flex-direction: column-reverse;
      }
      
      /* For reduced motion preferences */
      @media (prefers-reduced-motion: reduce) {
        .${Notification.BASE_NOTIFICATION_CLASS} {
          transition: opacity 0.1s ease;
          transform: translateY(0);
        }
        
        .${Notification.BASE_NOTIFICATION_CLASS}--with-progress::after {
          animation: none;
        }
      }
    `, 'userscripts-notification-styles');

            Notification.stylesInitialized = true;
        }

        /**
         * Injects default color variables for the notification component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
        static useDefaultColors() {
            const styleId = 'userscripts-notification-default-colors';
            if (!document.getElementById(styleId)) {
                const style = document.createElement('style');
                style.id = styleId;
                // Use textContent instead of innerHTML for CSP compliance
                style.textContent = `
        :root {
          /* Container styling */
          ${Notification.CSS_VAR_PREFIX}container-width: auto;
          ${Notification.CSS_VAR_PREFIX}container-max-width: 350px;
          ${Notification.CSS_VAR_PREFIX}container-bottom: 16px;
          ${Notification.CSS_VAR_PREFIX}container-top: 16px;
          ${Notification.CSS_VAR_PREFIX}container-left: 16px;
          ${Notification.CSS_VAR_PREFIX}container-right: 16px;
          
          /* Toast styling */
          ${Notification.CSS_VAR_PREFIX}font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
          ${Notification.CSS_VAR_PREFIX}font-size: 14px;
          ${Notification.CSS_VAR_PREFIX}line-height: 1.5;
          ${Notification.CSS_VAR_PREFIX}padding: 12px 16px;
          ${Notification.CSS_VAR_PREFIX}border-radius: 6px;
          ${Notification.CSS_VAR_PREFIX}shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          ${Notification.CSS_VAR_PREFIX}color: #ffffff;
          
          /* Progress bar */
          ${Notification.CSS_VAR_PREFIX}progress-height: 3px;
          ${Notification.CSS_VAR_PREFIX}progress-color: rgba(255, 255, 255, 0.5);
          
          /* Toast types */
          ${Notification.CSS_VAR_PREFIX}info-bg: #3498db;
          ${Notification.CSS_VAR_PREFIX}success-bg: #2ecc71;
          ${Notification.CSS_VAR_PREFIX}warning-bg: #f39c12;
          ${Notification.CSS_VAR_PREFIX}error-bg: #e74c3c;
          ${Notification.CSS_VAR_PREFIX}custom-bg: #7f8c8d;
        }
      `;
                document.head.appendChild(style);
            }
        }

        /**
         * Creates and shows a notification.
         * @param {Object|string} options - Configuration options or message string
         * @param {string} [options.message] - The notification message
         * @param {string} [options.type='info'] - Notification type (info, success, warning, error, custom)
         * @param {number} [options.duration=3000] - How long to show the notification (ms)
         * @param {string} [options.position='bottom-center'] - Position (top-left, top-center, top-middle, top-right, bottom-left, bottom-center, bottom-middle, bottom-right)
         * @param {boolean} [options.showProgress=true] - Show progress bar
         * @param {boolean} [options.showClose=true] - Show close button
         * @param {Function} [options.onClick] - Callback when notification is clicked
         * @param {Function} [options.onClose] - Callback when notification closes
         * @param {string} [options.icon] - HTML for icon to display
         * @param {string} [options.className] - Additional CSS class
         * @param {boolean} [options.html=false] - Whether to interpret message as HTML
         * @param {Object} [options.style] - Custom inline styles for the notification
         * @return {string} ID of the created notification (can be used to close it)
         */
        static show(options) {
            // Initialize styles if not already done
            this.initStyles();

            // Allow passing just a message string
            if (typeof options === 'string') {
                options = {message: options};
            }

            // Set defaults
            const config = {
                message: '',
                type: 'info',
                duration: 3000,
                position: 'bottom-center',
                showProgress: true,
                showClose: true,
                onClick: null,
                onClose: null,
                icon: null,
                className: '',
                html: false,
                style: null,
                ...options
            };

            // Generate a unique ID for this notification
            const id = `${Notification.BASE_NOTIFICATION_CLASS}-${++this._idCounter}`;

            // Check if we're at the limit for the specified position
            const positionString = this._normalizePosition(config.position);
            const activeInPosition = this._activeNotifications.filter(n => n.position === positionString).length;

            // If we're at the limit, queue this notification
            if (activeInPosition >= this._maxNotificationsPerContainer) {
                this._queue.push({id, ...config});
                return id;
            }

            // Create and show the notification
            this._createNotification(id, config);
            return id;
        }

        /**
         * Convenience method to show an info notification
         * @param {string} message - The message to display
         * @param {Object} [options] - Additional options
         * @return {string} Notification ID
         */
        static info(message, options = {}) {
            return this.show({...options, message, type: 'info'});
        }

        /**
         * Convenience method to show a success notification
         * @param {string} message - The message to display
         * @param {Object} [options] - Additional options
         * @return {string} Notification ID
         */
        static success(message, options = {}) {
            return this.show({...options, message, type: 'success'});
        }

        /**
         * Convenience method to show a warning notification
         * @param {string} message - The message to display
         * @param {Object} [options] - Additional options
         * @return {string} Notification ID
         */
        static warning(message, options = {}) {
            return this.show({...options, message, type: 'warning'});
        }

        /**
         * Convenience method to show an error notification
         * @param {string} message - The message to display
         * @param {Object} [options] - Additional options
         * @return {string} Notification ID
         */
        static error(message, options = {}) {
            return this.show({...options, message, type: 'error'});
        }

        /**
         * Close a notification by ID
         * @param {string} id - The notification ID
         * @param {boolean} [animate=true] - Whether to animate the closing
         */
        static close(id, animate = true) {
            const element = document.getElementById(id);
            if (!element) {
                // Check if it's in the queue
                const queueIndex = this._queue.findIndex(n => n.id === id);
                if (queueIndex !== -1) {
                    this._queue.splice(queueIndex, 1);
                }
                return;
            }

            // Get the notification object
            const notificationIndex = this._activeNotifications.findIndex(n => n.id === id);
            if (notificationIndex === -1) return;

            const notification = this._activeNotifications[notificationIndex];

            // Remove from active notifications
            this._activeNotifications.splice(notificationIndex, 1);

            // If animated, fade out then remove
            if (animate) {
                element.classList.remove(`${Notification.BASE_NOTIFICATION_CLASS}--visible`);
                setTimeout(() => {
                    this._removeNotificationElement(element, notification);
                }, 300); // Match the transition time in CSS
            } else {
                this._removeNotificationElement(element, notification);
            }

            // Process the queue after removing
            this._processQueue(notification.position);
        }

        /**
         * Close all notifications
         * @param {string} [position] - Only close notifications in this position
         * @param {boolean} [animate=true] - Whether to animate the closing
         */
        static closeAll(position = null, animate = true) {
            // Clear the queue
            if (position) {
                const normalizedPosition = this._normalizePosition(position);
                this._queue = this._queue.filter(n => this._normalizePosition(n.position) !== normalizedPosition);
            } else {
                this._queue = [];
            }

            // Close active notifications
            const notificationsToClose = position
                ? this._activeNotifications.filter(n => n.position === this._normalizePosition(position))
                : [...this._activeNotifications];

            notificationsToClose.forEach(notification => {
                this.close(notification.id, animate);
            });
        }

        /**
         * Set the maximum number of notifications to show per container
         * @param {number} max - Maximum number of notifications
         */
        static setMaxNotifications(max) {
            if (typeof max === 'number' && max > 0) {
                this._maxNotificationsPerContainer = max;
            }
        }

        /**
         * Get a container element for a specific position, creating it if it doesn't exist
         * @param {string} position - The notification position
         * @return {HTMLElement} The container element
         * @private
         */
        static _getContainer(position) {
            const positionString = this._normalizePosition(position);

            if (this._containers[positionString]) {
                return this._containers[positionString];
            }

            // Create new container
            const container = document.createElement('div');
            container.className = `${Notification.BASE_NOTIFICATION_CLASS}-container ${Notification.BASE_NOTIFICATION_CLASS}-container--${positionString}`;
            document.body.appendChild(container);

            // Store for future use
            this._containers[positionString] = container;
            return container;
        }

        /**
         * Normalize position string to one of the supported values
         * @param {string} position - Position string
         * @return {string} Normalized position string
         * @private
         */
        static _normalizePosition(position) {
            const validPositions = [
                'top-center', 'top-left', 'top-right',
                'bottom-center', 'bottom-left', 'bottom-right'
            ];

            if (validPositions.includes(position)) {
                return position;
            }

            // Handle abbreviated positions
            if (position === 'top') return 'top-center';
            if (position === 'bottom') return 'bottom-center';
            
            // Handle alternative naming
            if (position === 'top-middle') return 'top-center';
            if (position === 'bottom-middle') return 'bottom-center';

            // Default
            return 'bottom-center';
        }

        /**
         * Create and show a notification
         * @param {string} id - The notification ID
         * @param {Object} config - Notification configuration
         * @private
         */
        static _createNotification(id, config) {
            const position = this._normalizePosition(config.position);
            const container = this._getContainer(position);

            // Create the notification element
            const element = document.createElement('div');
            element.id = id;
            element.className = `${Notification.BASE_NOTIFICATION_CLASS} ${Notification.BASE_NOTIFICATION_CLASS}--${config.type}`;

            if (config.showProgress && config.duration > 0) {
                element.classList.add(`${Notification.BASE_NOTIFICATION_CLASS}--with-progress`);
                // Set the animation duration for the progress bar
                element.style.setProperty('--progress-duration', `${config.duration}ms`);
            }

            if (config.className) {
                element.classList.add(config.className);
            }

            // Apply custom styles
            if (config.style && typeof config.style === 'object') {
                Object.assign(element.style, config.style);
            }

            // Create content structure using DOM methods instead of innerHTML
            
            // Add icon if provided
            if (config.icon) {
                const iconDiv = document.createElement('div');
                iconDiv.className = `${Notification.BASE_NOTIFICATION_CLASS}-icon`;
                iconDiv.textContent = config.icon; // Use textContent for icons (should be emoji/text)
                element.appendChild(iconDiv);
            }

            // Add message content
            const contentDiv = document.createElement('div');
            contentDiv.className = `${Notification.BASE_NOTIFICATION_CLASS}-content`;
            if (config.html) {
                // For HTML content, we'll just use text content for CSP compliance
                // This is a security decision - no HTML allowed in notifications
                contentDiv.textContent = config.message;
            } else {
                contentDiv.textContent = config.message;
            }
            element.appendChild(contentDiv);

            // Add close button if needed
            if (config.showClose) {
                const closeButton = document.createElement('button');
                closeButton.className = `${Notification.BASE_NOTIFICATION_CLASS}-close`;
                closeButton.setAttribute('aria-label', 'Close notification');
                closeButton.textContent = '×';
                element.appendChild(closeButton);
            }

            // Set up animations
            requestAnimationFrame(() => {
                container.appendChild(element);

                // Trigger layout/reflow before adding the visible class
                void element.offsetWidth;

                // Make visible
                element.classList.add(`${Notification.BASE_NOTIFICATION_CLASS}--visible`);

                // Set animation for progress bar if applicable
                const progressBar = element.querySelector(`.${Notification.BASE_NOTIFICATION_CLASS}--with-progress::after`);
                if (progressBar) {
                    progressBar.style.animationDuration = `${config.duration}ms`;
                }
            });

            // Add to active notifications
            this._activeNotifications.push({
                id,
                element,
                position,
                config
            });

            // Set up click handler
            if (config.onClick) {
                element.addEventListener('click', event => {
                    // Only trigger if not clicking the close button
                    if (!event.target.closest(`.${Notification.BASE_NOTIFICATION_CLASS}-close`)) {
                        config.onClick(event, id);
                    }
                });
            }

            // Set up close button handler
            const closeButton = element.querySelector(`.${Notification.BASE_NOTIFICATION_CLASS}-close`);
            if (closeButton) {
                closeButton.addEventListener('click', () => this.close(id, true));
            }

            // Set auto-close timeout if duration > 0
            if (config.duration > 0) {
                setTimeout(() => {
                    // Check if notification still exists before closing
                    if (document.getElementById(id)) {
                        this.close(id, true);
                    }
                }, config.duration);
            }
        }

        /**
         * Remove a notification element from the DOM
         * @param {HTMLElement} element - The notification element
         * @param {Object} notification - The notification object
         * @private
         */
        static _removeNotificationElement(element, notification) {
            if (!element) return;

            // Call onClose callback if provided
            if (notification && notification.config && notification.config.onClose) {
                try {
                    notification.config.onClose(notification.id);
                } catch (e) {
                    Logger.error(e, 'Error in notification onClose callback');
                }
            }

            // Remove the element
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }

            // Check if container is empty and remove it if so
            const container = this._containers[notification.position];
            if (container && !container.hasChildNodes()) {
                if (container.parentNode) {
                    container.parentNode.removeChild(container);
                }
                delete this._containers[notification.position];
            }
        }

        /**
         * Process the notification queue for a specific position
         * @param {string} position - Position to process
         * @private
         */
        static _processQueue(position) {
            const normalizedPosition = this._normalizePosition(position);

            // Check how many active notifications we have in this position
            const activeCount = this._activeNotifications.filter(n => n.position === normalizedPosition).length;

            // Check if we can show more
            if (activeCount >= this._maxNotificationsPerContainer) return;

            // Find the first queued notification for this position
            const queueIndex = this._queue.findIndex(n =>
                this._normalizePosition(n.position) === normalizedPosition
            );

            if (queueIndex !== -1) {
                // Remove from queue and show
                const nextNotification = this._queue.splice(queueIndex, 1)[0];
                this._createNotification(nextNotification.id, nextNotification);
            }
        }
    }

    // Static property to track if styles have been initialized
    Notification.stylesInitialized = false;

    /**
     * DOMObserver - Observes DOM changes and URL changes
     * Uses UrlChangeWatcher for URL change detection with configurable strategies
     */
    class DOMObserver {
      /**
         * Wait for elements matching a selector
         * @param {string} selector - CSS selector to wait for
         * @param {number} timeout - Timeout in milliseconds
         * @return {Promise<NodeList>} - Promise resolving to found elements
         */
      static waitForElements(selector, timeout = 10000) {
        return new Promise((resolve, reject) => {
          const startTime = Date.now();

          function checkElements() {
            const elements = document.querySelectorAll(selector);
            if (0 < elements.length) {
              resolve(elements);
              return;
            }

            if (Date.now() - startTime > timeout) {
              reject(new Error(`Timeout waiting for elements: ${selector}`));
              return;
            }

            requestAnimationFrame(checkElements);
          }

          checkElements();
        });
      }
      /**
         * Create a new DOMObserver
         * @param {Function} onMutation - Callback for handling mutations
         * @param {Array} urlChangeStrategies - Array of URL change detection strategies to use
         */
      constructor(onMutation, urlChangeStrategies = []) {
        this.observer = new MutationObserver(this.handleMutations.bind(this));
        this.lastUrl = location.href;
        this.onMutation = onMutation;

        // Initialize URL change watcher with provided strategies
        this.urlChangeWatcher = new UrlChangeWatcher(urlChangeStrategies, false); // false = don't fire immediately
      }


      /**
         * Start observing DOM changes and URL changes
         * @param {HTMLElement} target - Element to observe (defaults to document.body)
         * @param {Object} config - MutationObserver configuration (defaults to sensible values)
         */
      observe(target = document.body, config = {childList: true, subtree: true}) {
        this.observer.observe(target, config);

        // Start URL change watcher
        this.urlChangeWatcher.start();
      }

      /**
         * Stop observing DOM changes and URL changes
         */
      disconnect() {
        this.observer.disconnect();

        // Stop URL change watcher
        this.urlChangeWatcher.stop();
      }

      /**
         * Handle mutations
         * @param {MutationRecord[]} mutations - Array of mutation records
         * @private
         */
      handleMutations(mutations) {
        if (this.onMutation) {
          this.onMutation(mutations);
        }
      }
    }

    /**
     * AutoRunner - Generic automated task execution system
     * Provides configurable task iteration with delays, progress tracking, and stop conditions
     */
    class AutoRunner {
        static EVENTS = {
            STARTED: 'autorunner:started',
            STOPPED: 'autorunner:stopped', 
            ITERATION: 'autorunner:iteration',
            COMPLETED: 'autorunner:completed',
            ERROR: 'autorunner:error'
        };

        /**
         * @param {Object} options Configuration options
         * @param {Function} options.taskFunction - Function to execute each iteration (can be async)
         * @param {number} options.maxIterations - Maximum number of iterations
         * @param {number} options.delay - Delay between iterations in milliseconds
         * @param {Function} options.shouldContinue - Optional function to check if should continue
         * @param {Function} options.onProgress - Optional progress callback
         * @param {Function} options.onError - Optional error handler
         * @param {Object} options.pubsub - Optional PubSub instance for events
         * @param {Object} options.logger - Optional logger instance
         * @param {string} options.name - Optional name for this runner (for logging)
         */
        constructor(options) {
            this.taskFunction = options.taskFunction;
            this.maxIterations = options.maxIterations || 1;
            this.delay = options.delay || 1000;
            this.shouldContinue = options.shouldContinue || (() => true);
            this.onProgress = options.onProgress || (() => {});
            this.onError = options.onError || ((error) => Logger.error('AutoRunner error:', error));
            this.name = options.name || 'AutoRunner';
            
            // Optional user interaction detection
            this.enableInteractionDetection = options.enableInteractionDetection || false;
            this.userInteraction = this.enableInteractionDetection ? 
                UserInteractionDetector.getInstance({
                    namespace: `autorunner-${this.name}`,
                    debug: Logger.DEBUG
                }) : null;
                
            // Optional notifications
            this.enableNotifications = options.enableNotifications || false;

            this.isRunning = false;
            this.currentIteration = 0;
            this.startTime = null;
            this.results = [];
        }

        /**
         * Start the auto runner
         */
        async start() {
            if (this.isRunning) {
                Logger.warn(`[${this.name}] AutoRunner is already running`);
                return false;
            }

            this.isRunning = true;
            this.currentIteration = 0;
            this.startTime = Date.now();
            this.results = [];

            Logger.info(`[${this.name}] Starting for ${this.maxIterations} iterations`);
            
            // Show notification if enabled
            if (this.enableNotifications) {
                Notification.info(`Starting ${this.name} for ${this.maxIterations} iterations`, {
                    duration: 3000,
                    position: 'top-right'
                });
            }
            
            this.publishEvent(AutoRunner.EVENTS.STARTED, {
                maxIterations: this.maxIterations,
                name: this.name,
                timestamp: this.startTime
            });

            await this.runIteration();
            return true;
        }

        /**
         * Stop the auto runner
         */
        stop(reason = 'user requested') {
            if (!this.isRunning) {
                Logger.warn(`[${this.name}] AutoRunner is not currently running`);
                return false;
            }

            this.isRunning = false;
            const duration = Date.now() - this.startTime;

            Logger.info(`[${this.name}] stopped: ${reason} (completed ${this.currentIteration}/${this.maxIterations} iterations in ${duration}ms)`);
            this.publishEvent(AutoRunner.EVENTS.STOPPED, {
                reason,
                completedIterations: this.currentIteration,
                totalIterations: this.maxIterations,
                duration,
                results: this.results,
                name: this.name,
                timestamp: Date.now()
            });

            return true;
        }

        /**
         * Run a single iteration
         */
        async runIteration() {
            if (!this.isRunning) {
                return;
            }

            // Check if we've completed all iterations
            if (this.currentIteration >= this.maxIterations) {
                this.isRunning = false;
                const duration = Date.now() - this.startTime;

                Logger.info(`[${this.name}] completed all ${this.maxIterations} iterations in ${duration}ms`);
                
                // Show completion notification if enabled
                if (this.enableNotifications) {
                    Notification.success(`${this.name} completed all ${this.maxIterations} iterations in ${(duration/1000).toFixed(1)}s`, {
                        duration: 5000,
                        position: 'top-right'
                    });
                }
                
                this.publishEvent(AutoRunner.EVENTS.COMPLETED, {
                    completedIterations: this.currentIteration,
                    totalIterations: this.maxIterations,
                    duration,
                    results: this.results,
                    name: this.name,
                    timestamp: Date.now()
                });

                return;
            }

            // Check custom continue condition
            if (!this.shouldContinue(this.currentIteration, this.results)) {
                this.stop('custom condition failed');
                return;
            }

            this.currentIteration++;
            
            Logger.debug(`[${this.name}] Running iteration ${this.currentIteration}/${this.maxIterations}`);
            this.publishEvent(AutoRunner.EVENTS.ITERATION, {
                current: this.currentIteration,
                total: this.maxIterations,
                name: this.name,
                timestamp: Date.now()
            });

            try {
                // Execute the task function
                const result = await this.taskFunction(this.currentIteration, this.results);
                this.results.push(result);

                // Call progress callback
                this.onProgress(this.currentIteration, this.maxIterations, result, this.results);

                // Schedule next iteration if still running
                if (this.isRunning) {
                    setTimeout(() => {
                        this.runIteration();
                    }, this.delay);
                }

            } catch (error) {
                Logger.error(`[${this.name}] Error in iteration ${this.currentIteration}:`, error);
                this.publishEvent(AutoRunner.EVENTS.ERROR, {
                    error: error.message,
                    iteration: this.currentIteration,
                    name: this.name,
                    timestamp: Date.now()
                });

                this.onError(error, this.currentIteration);

                // Continue to next iteration after error (unless stopped)
                if (this.isRunning) {
                    setTimeout(() => {
                        this.runIteration();
                    }, this.delay);
                }
            }
        }

        /**
         * Get current status
         */
        getStatus() {
            return {
                isRunning: this.isRunning,
                currentIteration: this.currentIteration,
                maxIterations: this.maxIterations,
                progress: this.maxIterations > 0 ? (this.currentIteration / this.maxIterations) * 100 : 0,
                duration: this.startTime ? Date.now() - this.startTime : 0,
                results: this.results,
                name: this.name
            };
        }

        /**
         * Update configuration while running
         */
        updateConfig(options) {
            if (options.delay !== undefined) this.delay = options.delay;
            if (options.maxIterations !== undefined) this.maxIterations = options.maxIterations;
            if (options.shouldContinue !== undefined) this.shouldContinue = options.shouldContinue;
            
            Logger.debug(`[${this.name}] Configuration updated:`, options);
        }

        /**
         * Wait for element using HTMLUtils before starting task
         */
        async waitForElement(selector, timeout = 5000) {
            try {
                return await HTMLUtils.waitForElement(selector, timeout);
            } catch (error) {
                Logger.warn(`[${this.name}] Element not found: ${selector}`, error);
                return null;
            }
        }

        /**
         * Create debounced function using core Debouncer
         */
        createDebouncedTask(func, delay) {
            return Debouncer.debounce(func, delay);
        }

        /**
         * Publish event using core PubSub
         */
        publishEvent(eventName, data) {
            PubSub.publish(eventName, data);
        }

        /**
         * Check if user is currently interacting and pause if needed
         */
        async checkUserInteraction() {
            if (!this.userInteraction) return true;
            
            const isInteracting = this.userInteraction.isInteracting();
            if (isInteracting) {
                Logger.debug(`[${this.name}] User interaction detected, pausing iteration`);
                
                if (this.enableNotifications) {
                    Notification.warning('Auto-run paused - user interaction detected', {
                        duration: 2000,
                        position: 'top-right'
                    });
                }
                
                // Wait for user to stop interacting
                while (this.userInteraction.isInteracting() && this.isRunning) {
                    await this.delay(500);
                }
                
                // Additional pause after user stops interacting
                if (this.isRunning) {
                    await this.delay(1000);
                    Logger.debug(`[${this.name}] Resuming after user interaction ended`);
                }
            }
            
            return this.isRunning;
        }

        /**
         * Enhanced run iteration with interaction detection
         */
        async runIterationWithInteractionCheck() {
            // Check for user interaction before proceeding
            const shouldContinue = await this.checkUserInteraction();
            if (!shouldContinue) return;
            
            // Run normal iteration
            await this.runIteration();
        }

        /**
         * Static factory method for simple use cases
         */
        static async run(taskFunction, iterations, delay = 1000, options = {}) {
            const runner = new AutoRunner({
                taskFunction,
                maxIterations: iterations,
                delay,
                ...options
            });

            await runner.start();
            return runner;
        }
    }

    /**
     * ContentCollector - Generic content collection and cleaning system
     * Automatically detects and collects content from dynamic web pages
     */
    class ContentCollector {
        static EVENTS = {
            CONTENT_ADDED: 'contentcollector:content-added',
            CONTENT_CLEARED: 'contentcollector:content-cleared',
            COLLECTION_UPDATED: 'contentcollector:collection-updated'
        };

        /**
         * @param {Object} options Configuration options
         * @param {Array<string>} options.selectors - CSS selectors for content containers
         * @param {Function} options.contentExtractor - Function to extract text from elements
         * @param {Function} options.contentCleaner - Function to clean extracted content
         * @param {Function} options.contentValidator - Function to validate content before adding
         * @param {boolean} options.deduplicate - Whether to remove duplicates (default: true)
         * @param {Object} options.observer - DOMObserver instance for monitoring changes
         * @param {Object} options.pubsub - Optional PubSub instance for events
         * @param {Object} options.logger - Optional logger instance
         * @param {string} options.name - Optional name for this collector
         */
        constructor(options) {
            this.selectors = options.selectors || [];
            this.contentExtractor = options.contentExtractor || this.defaultContentExtractor.bind(this);
            this.contentCleaner = options.contentCleaner || this.defaultContentCleaner.bind(this);
            this.contentValidator = options.contentValidator || this.defaultContentValidator.bind(this);
            this.deduplicate = options.deduplicate !== false;
            this.name = options.name || 'ContentCollector';
            
            // Use core DOMObserver instead of custom observer
            this.observer = new DOMObserver((mutations) => {
                this.handleMutations(mutations);
            });
            
            // Optional notifications
            this.enableNotifications = options.enableNotifications || false;

            this.content = [];
            this.seenElements = new WeakSet();
            this.isMonitoring = false;
            
            // Use DataCache for persistent storage if enabled
            this.enablePersistence = options.enablePersistence || false;
            this.cache = this.enablePersistence ? new DataCache(Logger) : null;
            this.cacheKey = options.cacheKey || `content-collector-${this.name}`;
            
            // Use StyleManager for highlighting collected elements
            this.highlightCollected = options.highlightCollected || false;
            if (this.highlightCollected) {
                this.initializeHighlightStyles();
            }
        }

        /**
         * Start monitoring for new content
         */
        startMonitoring() {
            if (this.isMonitoring) {
                Logger.warn(`[${this.name}] Already monitoring for content`);
                return;
            }

            this.isMonitoring = true;
            Logger.info(`[${this.name}] Starting content monitoring with ${this.selectors.length} selectors`);

            // Collect existing content
            this.collectExistingContent();

            // Setup DOM observer if provided
            if (this.observer) {
                this.observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }
        }

        /**
         * Stop monitoring for new content
         */
        stopMonitoring() {
            if (!this.isMonitoring) {
                Logger.warn(`[${this.name}] Not currently monitoring`);
                return;
            }

            this.isMonitoring = false;
            Logger.info(`[${this.name}] Stopped content monitoring`);

            if (this.observer && typeof this.observer.disconnect === 'function') {
                this.observer.disconnect();
            }
        }

        /**
         * Collect existing content on page
         */
        collectExistingContent() {
            const initialCount = this.content.length;

            this.selectors.forEach(selector => {
                try {
                    document.querySelectorAll(selector).forEach(element => {
                        this.processElement(element);
                    });
                } catch (error) {
                    Logger.error(`[${this.name}] Error with selector "${selector}":`, error);
                }
            });

            const newCount = this.content.length - initialCount;
            Logger.info(`[${this.name}] Collected ${newCount} new content items (${this.content.length} total)`);

            // Show notification if enabled and content was found
            if (this.enableNotifications && newCount > 0) {
                Notification.success(`Collected ${newCount} new content items`, {
                    duration: 3000,
                    position: 'top-right'
                });
            }

            this.publishEvent(ContentCollector.EVENTS.COLLECTION_UPDATED, {
                newItems: newCount,
                totalItems: this.content.length,
                name: this.name
            });
        }

        /**
         * Process a single element for content extraction
         */
        async processElement(element) {
            // Skip if already processed
            if (this.seenElements.has(element)) {
                return;
            }

            this.seenElements.add(element);

            try {
                // Extract content using the configured extractor
                const rawContent = this.contentExtractor(element);
                if (!rawContent) {
                    return;
                }

                // Clean the content
                const cleanedContent = this.contentCleaner(rawContent);
                if (!cleanedContent) {
                    return;
                }

                // Validate the content
                if (!this.contentValidator(cleanedContent, this.content)) {
                    return;
                }

                // Check for duplicates if enabled
                if (this.deduplicate && this.content.includes(cleanedContent)) {
                    return;
                }

                // Add to collection
                this.content.push(cleanedContent);

                // Highlight the element if enabled
                this.highlightElement(element);

                // Save to cache if persistence is enabled
                if (this.enablePersistence) {
                    await this.saveToCache();
                }

                Logger.debug(`[${this.name}] Added content: ${cleanedContent.substring(0, 100)}...`);
                this.publishEvent(ContentCollector.EVENTS.CONTENT_ADDED, {
                    content: cleanedContent,
                    totalItems: this.content.length,
                    name: this.name
                });

            } catch (error) {
                Logger.error(`[${this.name}] Error processing element:`, error);
            }
        }

        /**
         * Handle DOM mutations for new content detection
         */
        handleMutations(mutations) {
            if (!this.isMonitoring) {
                return;
            }

            for (const mutation of mutations) {
                if (mutation.type === 'childList') {
                    for (const node of mutation.addedNodes) {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            this.scanForNewContent(node);
                        }
                    }
                }
            }
        }

        /**
         * Scan element for new content using configured selectors
         */
        scanForNewContent(element) {
            this.selectors.forEach(selector => {
                try {
                    // Check if the element itself matches
                    if (element.matches && element.matches(selector)) {
                        this.processElement(element);
                    }

                    // Check children
                    if (element.querySelectorAll) {
                        element.querySelectorAll(selector).forEach(el => {
                            this.processElement(el);
                        });
                    }
                } catch (error) {
                    Logger.error(`[${this.name}] Error scanning with selector "${selector}":`, error);
                }
            });
        }

        /**
         * Default content extractor - uses innerText
         */
        defaultContentExtractor(element) {
            return element.innerText?.trim() || '';
        }

        /**
         * Default content cleaner - removes common UI elements
         */
        defaultContentCleaner(text) {
            if (!text) return '';

            // Common UI elements to remove
            const uiElements = [
                'edit', 'more_vert', 'thumb_up', 'thumb_down', 'copy', 'share',
                'delete', 'refresh', 'restart', 'stop', 'play', 'pause',
                'expand_more', 'expand_less', 'close', 'menu', 'settings',
                'download', 'upload', 'save', 'favorite', 'star', 'bookmark'
            ];

            // Split into lines and clean
            let lines = text.split('\n')
                .map(line => line.trim())
                .filter(line => {
                    if (!line) return false;
                    
                    const lowerLine = line.toLowerCase();
                    if (uiElements.includes(lowerLine)) return false;
                    
                    if (/^[-=_\s]+$/.test(line)) return false;
                    if (line.length <= 3 && !/\w/.test(line)) return false;
                    
                    return true;
                });

            // Remove UI patterns at beginning and end
            while (lines.length > 0 && this.isUILine(lines[0])) {
                lines.shift();
            }
            while (lines.length > 0 && this.isUILine(lines[lines.length - 1])) {
                lines.pop();
            }

            return lines.join('\n').trim();
        }

        /**
         * Check if a line is likely a UI element
         */
        isUILine(line) {
            const cleaned = line.toLowerCase().trim();
            
            const uiPatterns = [
                /^(edit|copy|share|delete|save|download)$/,
                /^(thumb_up|thumb_down|more_vert)$/,
                /^[👍👎❤️⭐🔗📋✏️🗑️]+$/,
                /^[\s\-=_]{1,5}$/
            ];

            return uiPatterns.some(pattern => pattern.test(cleaned));
        }

        /**
         * Default content validator - checks minimum length
         */
        defaultContentValidator(content, existingContent) {
            return content && content.length > 10;
        }

        /**
         * Get all collected content
         */
        getContent() {
            return [...this.content];
        }

        /**
         * Get content formatted as string
         */
        getFormattedContent(separator = '\n\n---\n\n') {
            return this.content.join(separator);
        }

        /**
         * Clear all collected content
         */
        clearContent() {
            const clearedCount = this.content.length;
            this.content = [];
            this.seenElements = new WeakSet();

            Logger.info(`[${this.name}] Cleared ${clearedCount} content items`);
            this.publishEvent(ContentCollector.EVENTS.CONTENT_CLEARED, {
                clearedCount,
                name: this.name
            });
        }

        /**
         * Get collection statistics
         */
        getStats() {
            return {
                totalItems: this.content.length,
                isMonitoring: this.isMonitoring,
                selectors: this.selectors.length,
                name: this.name
            };
        }

        /**
         * Add custom selector
         */
        addSelector(selector) {
            if (!this.selectors.includes(selector)) {
                this.selectors.push(selector);
                Logger.debug(`[${this.name}] Added selector: ${selector}`);
            }
        }

        /**
         * Initialize highlight styles using StyleManager
         */
        initializeHighlightStyles() {
            StyleManager.addStyles(`
            .content-collector-highlighted {
                outline: 2px solid #4CAF50 !important;
                background-color: rgba(76, 175, 80, 0.1) !important;
                transition: all 0.3s ease !important;
            }
            .content-collector-highlighted::after {
                content: "✓ Collected";
                position: absolute;
                top: -20px;
                right: 0;
                background: #4CAF50;
                color: white;
                padding: 2px 6px;
                font-size: 10px;
                border-radius: 3px;
                z-index: 10000;
            }
        `, `content-collector-styles-${this.name}`);
        }

        /**
         * Load content from cache using DataCache
         */
        async loadFromCache() {
            if (!this.cache) return false;
            
            try {
                const cachedContent = this.cache.get(this.cacheKey);
                if (cachedContent && Array.isArray(cachedContent)) {
                    this.content = [...cachedContent];
                    Logger.info(`[${this.name}] Loaded ${this.content.length} items from cache`);
                    return true;
                }
            } catch (error) {
                Logger.error(`[${this.name}] Error loading from cache:`, error);
            }
            return false;
        }

        /**
         * Save content to cache using DataCache
         */
        async saveToCache() {
            if (!this.cache) return;
            
            try {
                this.cache.set(this.cacheKey, this.content, 7); // 7 days expiration
                Logger.debug(`[${this.name}] Saved ${this.content.length} items to cache`);
            } catch (error) {
                Logger.error(`[${this.name}] Error saving to cache:`, error);
            }
        }

        /**
         * Wait for elements using HTMLUtils
         */
        async waitForContent(timeout = 10000) {
            for (const selector of this.selectors) {
                try {
                    const element = await HTMLUtils.waitForElement(selector, timeout);
                    if (element) {
                        Logger.debug(`[${this.name}] Found content with selector: ${selector}`);
                        return element;
                    }
                } catch (error) {
                    Logger.debug(`[${this.name}] No content found for selector: ${selector}`);
                }
            }
            return null;
        }

        /**
         * Highlight collected element using StyleManager
         */
        highlightElement(element) {
            if (this.highlightCollected && element) {
                element.classList.add('content-collector-highlighted');
                // Remove highlight after 3 seconds
                setTimeout(() => {
                    element.classList.remove('content-collector-highlighted');
                }, 3000);
            }
        }

        /**
         * Remove selector
         */
        removeSelector(selector) {
            const index = this.selectors.indexOf(selector);
            if (index > -1) {
                this.selectors.splice(index, 1);
                Logger.debug(`[${this.name}] Removed selector: ${selector}`);
            }
        }

        /**
         * Publish event using core PubSub
         */
        publishEvent(eventName, data) {
            PubSub.publish(eventName, data);
        }


    }

    /**
     * FormStatePersistence - Generic form state persistence system
     * Automatically saves and restores form values using GM storage
     */
    class FormStatePersistence {
        static EVENTS = {
            STATE_SAVED: 'formstate:state-saved',
            STATE_LOADED: 'formstate:state-loaded',
            STATE_CLEARED: 'formstate:state-cleared',
            FIELD_CHANGED: 'formstate:field-changed'
        };

        /**
         * @param {Object} options Configuration options
         * @param {string} options.namespace - Namespace for storage keys
         * @param {Object} options.fields - Field configurations {fieldName: {selector, type, defaultValue, validator}}
         * @param {Function} options.getValue - Function to get values from GM storage
         * @param {Function} options.setValue - Function to set values in GM storage
         * @param {boolean} options.autoSave - Whether to auto-save on change (default: true)
         * @param {number} options.debounceDelay - Debounce delay for auto-save (default: 500ms)
         * @param {Object} options.pubsub - Optional PubSub instance for events
         * @param {Object} options.logger - Optional logger instance
         * @param {string} options.name - Optional name for this persistence manager
         */
        constructor(options) {
            this.namespace = options.namespace || 'form-state';
            this.fields = options.fields || {};
            this.getValue = options.getValue;
            this.setValue = options.setValue;
            this.autoSave = options.autoSave !== false;
            this.debounceDelay = options.debounceDelay || 500;
            this.name = options.name || 'FormStatePersistence';
            
            // Optional user interaction detection for distinguishing user vs auto-save
            this.enableInteractionDetection = options.enableInteractionDetection || false;
            this.userInteraction = this.enableInteractionDetection ? 
                UserInteractionDetector.getInstance({
                    namespace: `formstate-${this.name}`,
                    debug: Logger.DEBUG
                }) : null;
                
            // Optional notifications
            this.enableNotifications = options.enableNotifications || false;
            
            // Optional periodic save using PollingStrategy
            this.enablePeriodicSave = options.enablePeriodicSave || false;
            this.periodicSaveInterval = options.periodicSaveInterval || 30000; // 30 seconds
            this.pollingStrategy = null;

            this.fieldElements = new Map();
            this.fieldValues = new Map();
            this.saveTimeouts = new Map();
            this.isInitialized = false;
            
            // Use core Debouncer for save operations
            this.debouncedSave = Debouncer.debounce(this.performSave.bind(this), this.debounceDelay);
            
            // Use DataCache for backup storage
            this.enableBackup = options.enableBackup || false;
            this.backupCache = this.enableBackup ? new DataCache(Logger) : null;

            // Import Debouncer if available
            this.Debouncer = options.Debouncer;
        }

        /**
         * Initialize the form state persistence
         */
        async initialize() {
            if (this.isInitialized) {
                this.log('warn', 'Already initialized');
                return;
            }

            Logger.info(`[${this.name}] Initializing form state persistence with ${Object.keys(this.fields).length} fields`);

            // Find and cache field elements
            this.findFieldElements();

            // Load saved state
            await this.loadState();

            // Setup auto-save listeners
            if (this.autoSave) {
                this.setupAutoSave();
            }

            this.isInitialized = true;
            Logger.info(`[${this.name}] Form state persistence initialized`);
            
            // Start periodic save if enabled
            if (this.enablePeriodicSave) {
                this.pollingStrategy = new PollingStrategy(() => {
                    this.saveState();
                }, this.periodicSaveInterval);
                this.pollingStrategy.start();
            }
            
            // Show initialization notification if enabled
            if (this.enableNotifications) {
                Notification.success(`Form state persistence initialized for ${Object.keys(this.fields).length} fields`, {
                    duration: 3000,
                    position: 'bottom-right'
                });
            }
        }

        /**
         * Find and cache field elements
         */
        findFieldElements() {
            for (const [fieldName, config] of Object.entries(this.fields)) {
                try {
                    const element = document.querySelector(config.selector);
                    if (element) {
                        this.fieldElements.set(fieldName, element);
                        this.log('debug', `Found field element: ${fieldName}`);
                    } else {
                        this.log('warn', `Field element not found: ${fieldName} (${config.selector})`);
                    }
                } catch (error) {
                    Logger.error(`[${this.name}] Error finding field ${fieldName}:`, error);
                }
            }
        }

        /**
         * Load saved state from storage
         */
        async loadState() {
            if (!this.getValue) {
                this.log('warn', 'No getValue function provided, cannot load state');
                return;
            }

            let loadedCount = 0;

            for (const [fieldName, config] of Object.entries(this.fields)) {
                try {
                    const storageKey = this.getStorageKey(fieldName);
                    const savedValue = await this.getValue(storageKey, config.defaultValue);
                    
                    if (savedValue !== null && savedValue !== undefined) {
                        this.fieldValues.set(fieldName, savedValue);
                        await this.setFieldValue(fieldName, savedValue);
                        loadedCount++;
                        this.log('debug', `Loaded field ${fieldName}:`, savedValue);
                    }
                } catch (error) {
                    this.log('error', `Error loading field ${fieldName}:`, error);
                }
            }

            this.log('info', `Loaded ${loadedCount} field values from storage`);
            this.publishEvent(FormStatePersistence.EVENTS.STATE_LOADED, {
                loadedCount,
                totalFields: Object.keys(this.fields).length,
                name: this.name
            });
        }

        /**
         * Save current state to storage
         */
        async saveState() {
            if (!this.setValue) {
                this.log('warn', 'No setValue function provided, cannot save state');
                return;
            }

            let savedCount = 0;

            for (const [fieldName, config] of Object.entries(this.fields)) {
                try {
                    const currentValue = await this.getFieldValue(fieldName);
                    
                    if (currentValue !== null && currentValue !== undefined) {
                        // Validate value if validator provided
                        if (config.validator && !config.validator(currentValue)) {
                            this.log('warn', `Validation failed for field ${fieldName}, not saving`);
                            continue;
                        }

                        const storageKey = this.getStorageKey(fieldName);
                        await this.setValue(storageKey, currentValue);
                        this.fieldValues.set(fieldName, currentValue);
                        savedCount++;
                        this.log('debug', `Saved field ${fieldName}:`, currentValue);
                    }
                } catch (error) {
                    this.log('error', `Error saving field ${fieldName}:`, error);
                }
            }

            this.log('info', `Saved ${savedCount} field values to storage`);
            this.publishEvent(FormStatePersistence.EVENTS.STATE_SAVED, {
                savedCount,
                totalFields: Object.keys(this.fields).length,
                name: this.name
            });
        }

        /**
         * Get current value of a field
         */
        async getFieldValue(fieldName) {
            const element = this.fieldElements.get(fieldName);
            const config = this.fields[fieldName];
            
            if (!element || !config) {
                return null;
            }

            try {
                switch (config.type) {
                    case 'text':
                    case 'textarea':
                    case 'number':
                    case 'email':
                    case 'url':
                        return element.value;
                    
                    case 'checkbox':
                        return element.checked;
                    
                    case 'radio':
                        const radioGroup = document.querySelectorAll(`[name="${element.name}"]`);
                        for (const radio of radioGroup) {
                            if (radio.checked) {
                                return radio.value;
                            }
                        }
                        return null;
                    
                    case 'select':
                        return element.value;
                    
                    case 'select-multiple':
                        return Array.from(element.selectedOptions).map(option => option.value);
                    
                    case 'contenteditable':
                        return element.textContent || element.innerText;
                    
                    default:
                        return element.value;
                }
            } catch (error) {
                this.log('error', `Error getting value for field ${fieldName}:`, error);
                return null;
            }
        }

        /**
         * Set value of a field
         */
        async setFieldValue(fieldName, value) {
            const element = this.fieldElements.get(fieldName);
            const config = this.fields[fieldName];
            
            if (!element || !config) {
                return false;
            }

            try {
                switch (config.type) {
                    case 'text':
                    case 'textarea':
                    case 'number':
                    case 'email':
                    case 'url':
                        element.value = value;
                        element.dispatchEvent(new Event('input', { bubbles: true }));
                        element.dispatchEvent(new Event('change', { bubbles: true }));
                        break;
                    
                    case 'checkbox':
                        element.checked = Boolean(value);
                        element.dispatchEvent(new Event('change', { bubbles: true }));
                        break;
                    
                    case 'radio':
                        const radioGroup = document.querySelectorAll(`[name="${element.name}"]`);
                        for (const radio of radioGroup) {
                            if (radio.value === value) {
                                radio.checked = true;
                                radio.dispatchEvent(new Event('change', { bubbles: true }));
                                break;
                            }
                        }
                        break;
                    
                    case 'select':
                        element.value = value;
                        element.dispatchEvent(new Event('change', { bubbles: true }));
                        break;
                    
                    case 'select-multiple':
                        if (Array.isArray(value)) {
                            for (const option of element.options) {
                                option.selected = value.includes(option.value);
                            }
                            element.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                        break;
                    
                    case 'contenteditable':
                        element.textContent = value;
                        element.dispatchEvent(new Event('input', { bubbles: true }));
                        break;
                    
                    default:
                        element.value = value;
                        element.dispatchEvent(new Event('input', { bubbles: true }));
                        element.dispatchEvent(new Event('change', { bubbles: true }));
                }
                
                return true;
            } catch (error) {
                this.log('error', `Error setting value for field ${fieldName}:`, error);
                return false;
            }
        }

        /**
         * Setup auto-save listeners
         */
        setupAutoSave() {
            for (const [fieldName, config] of Object.entries(this.fields)) {
                const element = this.fieldElements.get(fieldName);
                if (!element) continue;

                const eventTypes = this.getFieldEventTypes(config.type);
                
                for (const eventType of eventTypes) {
                    element.addEventListener(eventType, () => {
                        this.scheduleFieldSave(fieldName);
                    });
                }
            }

            this.log('debug', 'Auto-save listeners setup complete');
        }

        /**
         * Get appropriate event types for field type
         */
        getFieldEventTypes(fieldType) {
            switch (fieldType) {
                case 'text':
                case 'textarea':
                case 'number':
                case 'email':
                case 'url':
                case 'contenteditable':
                    return ['input', 'blur'];
                
                case 'checkbox':
                case 'radio':
                case 'select':
                case 'select-multiple':
                    return ['change'];
                
                default:
                    return ['input', 'change'];
            }
        }

        /**
         * Schedule debounced save for a specific field using core Debouncer
         */
        scheduleFieldSave(fieldName) {
            // Use the debounced save function
            this.debouncedSave();
        }

        /**
         * Perform the actual save operation (used by debouncer)
         */
        async performSave() {
            await this.saveState();
            
            // Create backup if enabled
            if (this.enableBackup && this.backupCache) {
                const currentValues = this.getCurrentValues();
                this.backupCache.set(`${this.namespace}-backup`, currentValues, 30); // 30 days
            }
        }

        /**
         * Wait for form elements using HTMLUtils
         */
        async waitForFormElements(timeout = 5000) {
            const foundElements = new Map();
            
            for (const [fieldName, config] of Object.entries(this.fields)) {
                try {
                    const element = await HTMLUtils.waitForElement(config.selector, timeout);
                    if (element) {
                        foundElements.set(fieldName, element);
                        this.log('debug', `Found form element: ${fieldName}`);
                    }
                } catch (error) {
                    this.log('warn', `Form element not found: ${fieldName} (${config.selector})`);
                }
            }
            
            return foundElements;
        }

        /**
         * Restore from backup using DataCache
         */
        async restoreFromBackup() {
            if (!this.enableBackup || !this.backupCache) {
                return false;
            }
            
            try {
                const backup = this.backupCache.get(`${this.namespace}-backup`);
                if (backup) {
                    for (const [fieldName, value] of Object.entries(backup)) {
                        if (this.fields[fieldName]) {
                            await this.setFieldValue(fieldName, value);
                            this.fieldValues.set(fieldName, value);
                        }
                    }
                    this.log('info', 'Restored form data from backup');
                    return true;
                }
            } catch (error) {
                this.log('error', 'Error restoring from backup:', error);
            }
            
            return false;
        }

        /**
         * Save a specific field
         */
        async saveField(fieldName) {
            if (!this.setValue) {
                return;
            }

            try {
                const currentValue = await this.getFieldValue(fieldName);
                const config = this.fields[fieldName];
                
                if (currentValue !== null && currentValue !== undefined) {
                    // Validate value if validator provided
                    if (config.validator && !config.validator(currentValue)) {
                        this.log('warn', `Validation failed for field ${fieldName}, not saving`);
                        return;
                    }

                    const storageKey = this.getStorageKey(fieldName);
                    await this.setValue(storageKey, currentValue);
                    this.fieldValues.set(fieldName, currentValue);
                    
                    this.log('debug', `Auto-saved field ${fieldName}:`, currentValue);
                    this.publishEvent(FormStatePersistence.EVENTS.FIELD_CHANGED, {
                        fieldName,
                        value: currentValue,
                        name: this.name
                    });
                }
            } catch (error) {
                this.log('error', `Error auto-saving field ${fieldName}:`, error);
            }
        }

        /**
         * Clear saved state for all fields
         */
        async clearState() {
            if (!this.setValue) {
                this.log('warn', 'No setValue function provided, cannot clear state');
                return;
            }

            let clearedCount = 0;

            for (const fieldName of Object.keys(this.fields)) {
                try {
                    const storageKey = this.getStorageKey(fieldName);
                    await this.setValue(storageKey, null);
                    this.fieldValues.delete(fieldName);
                    clearedCount++;
                } catch (error) {
                    this.log('error', `Error clearing field ${fieldName}:`, error);
                }
            }

            this.log('info', `Cleared ${clearedCount} field values from storage`);
            this.publishEvent(FormStatePersistence.EVENTS.STATE_CLEARED, {
                clearedCount,
                name: this.name
            });
        }

        /**
         * Get storage key for a field
         */
        getStorageKey(fieldName) {
            return `${this.namespace}-${fieldName}`;
        }

        /**
         * Add a new field to persistence
         */
        addField(fieldName, config) {
            this.fields[fieldName] = config;
            
            // Find the element
            try {
                const element = document.querySelector(config.selector);
                if (element) {
                    this.fieldElements.set(fieldName, element);
                    
                    // Setup auto-save if enabled
                    if (this.autoSave) {
                        const eventTypes = this.getFieldEventTypes(config.type);
                        for (const eventType of eventTypes) {
                            element.addEventListener(eventType, () => {
                                this.scheduleFieldSave(fieldName);
                            });
                        }
                    }
                    
                    this.log('debug', `Added field: ${fieldName}`);
                }
            } catch (error) {
                this.log('error', `Error adding field ${fieldName}:`, error);
            }
        }

        /**
         * Remove a field from persistence
         */
        removeField(fieldName) {
            delete this.fields[fieldName];
            this.fieldElements.delete(fieldName);
            this.fieldValues.delete(fieldName);
            
            // Clear any pending save
            if (this.saveTimeouts.has(fieldName)) {
                clearTimeout(this.saveTimeouts.get(fieldName));
                this.saveTimeouts.delete(fieldName);
            }
            
            this.log('debug', `Removed field: ${fieldName}`);
        }

        /**
         * Get current field values
         */
        getCurrentValues() {
            const values = {};
            for (const fieldName of Object.keys(this.fields)) {
                values[fieldName] = this.fieldValues.get(fieldName);
            }
            return values;
        }

        /**
         * Publish event using core PubSub
         */
        publishEvent(eventName, data) {
            PubSub.publish(eventName, data);
        }



        /**
         * Cleanup resources
         */
        destroy() {
            // Clear all pending timeouts
            for (const timeoutId of this.saveTimeouts.values()) {
                clearTimeout(timeoutId);
            }
            this.saveTimeouts.clear();

            // Clear maps
            this.fieldElements.clear();
            this.fieldValues.clear();

            this.isInitialized = false;
            Logger.info(`[${this.name}] Form state persistence destroyed`);
        }
    }

    /**
     * GMFunctions - Provides fallback implementations for Greasemonkey/Tampermonkey functions
     * Ensures compatibility across different userscript managers and direct browser execution
     */

    class GMFunctions {
        /**
         * Check if we're running in development mode (outside a userscript manager)
         * @return {boolean} True if in development environment
         */
        static isDevelopmentMode() {
            // In production, GM_info should be defined by the userscript manager
            return 'undefined' === typeof GM_info;
        }

        /**
         * Initialize fallbacks for missing GM functions
         * @return {Object} Object containing references to all GM functions (either native or polyfilled)
         */
        static initialize() {
            const isDevMode = this.isDevelopmentMode();

            Logger.debug('GMFunctions initializing', isDevMode ? 'in development mode' : 'in production mode');

            if (isDevMode) {
                // Create fallbacks for common GM functions
                this.setupAddStyle();
                this.setupXmlHttpRequest();
                this.setupSetClipboard();
                this.setupDownload();
                this.setupGetValue();
                this.setupSetValue();

                Logger.info('GM function fallbacks have been created for development mode');
            } else {
                Logger.debug('Using native userscript manager GM functions');
            }

            // Return references to all functions (either native or polyfilled)
            return {
                GM_addStyle: window.GM_addStyle,
                GM_xmlhttpRequest: window.GM_xmlhttpRequest,
                GM_setClipboard: window.GM_setClipboard,
                GM_download: window.GM_download,
                GM_getValue: window.GM_getValue,
                GM_setValue: window.GM_setValue,
            };
        }

        /**
         * Set up GM_addStyle fallback
         */
        static setupAddStyle() {
            window.GM_addStyle = function (css) {
                Logger.debug('GM_addStyle fallback executing', css.substring(0, 50) + '...');
                const style = document.createElement('style');
                style.textContent = css;
                document.head.appendChild(style);
                return style;
            };
        }

        /**
         * Set up GM_xmlhttpRequest fallback
         */
        static setupXmlHttpRequest() {
            window.GM_xmlhttpRequest = function (details) {
                Logger.debug('GM_xmlhttpRequest fallback executing', {
                    method: details.method,
                    url: details.url
                });

                const xhr = new XMLHttpRequest();
                xhr.open(details.method, details.url);

                if (details.headers) {
                    Object.keys(details.headers).forEach((key) => {
                        xhr.setRequestHeader(key, details.headers[key]);
                    });
                }

                xhr.onload = function () {
                    if (details.onload) {
                        const response = {
                            responseText: xhr.responseText,
                            response: xhr.response,
                            status: xhr.status,
                            statusText: xhr.statusText,
                            readyState: xhr.readyState,
                        };

                        Logger.debug('GM_xmlhttpRequest completed', {
                            status: xhr.status,
                            url: details.url
                        });

                        details.onload(response);
                    }
                };

                xhr.onerror = function () {
                    Logger.error('GM_xmlhttpRequest error', {
                        url: details.url,
                        status: xhr.status
                    });

                    if (details.onerror) {
                        details.onerror(xhr);
                    }
                };

                xhr.send(details.data);
                return xhr;
            };
        }

        /**
         * Set up GM_setClipboard fallback
         */
        static setupSetClipboard() {
            window.GM_setClipboard = function (text) {
                Logger.debug('GM_setClipboard fallback executing', {
                    textLength: text.length
                });

                // Create a temporary textarea element
                const textarea = document.createElement('textarea');
                textarea.value = text;

                // Make the textarea not visible
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';

                document.body.appendChild(textarea);
                textarea.select();

                // Try to copy the text
                let success = false;
                try {
                    success = document.execCommand('copy');
                    Logger.info('Clipboard copy ' + (success ? 'successful' : 'unsuccessful'));
                } catch (err) {
                    Logger.error(err, 'Error copying to clipboard');
                }

                // Clean up
                document.body.removeChild(textarea);
                return success;
            };
        }

        /**
         * Set up GM_download fallback
         */
        static setupDownload() {
            window.GM_download = function (options) {
                // Wrapping in a Promise to allow for async-like behavior if needed by caller,
                // though current implementation is synchronous.
                return new Promise((resolve, reject) => {
                    try {
                        const {url, name, onload, onerror} = options;

                        Logger.debug('GM_download fallback executing', {
                            url: url.substring(0, 100),
                            filename: name
                        });

                        // Create download link
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = name || 'download';
                        downloadLink.style.display = 'none';

                        // Add to document, click, and remove
                        document.body.appendChild(downloadLink);
                        downloadLink.click();

                        // Clean up
                        setTimeout(() => {
                            document.body.removeChild(downloadLink);
                            if (onload) {
                                Logger.debug('GM_download completed successfully');
                                onload();
                            }
                            resolve(true); // Resolve promise on success
                        }, 100);

                    } catch (err) {
                        Logger.error(err, 'Error downloading file');
                        if (options.onerror) options.onerror(err);
                        reject(err); // Reject promise on error
                    }
                });
            };
        }

        /**
         * Set up GM_getValue fallback using localStorage, returning a Promise.
         */
        static setupGetValue() {
            window.GM_getValue = function (key, defaultValue) {
                return new Promise((resolve) => {
                    try {
                        const storageKey = `GM_${key}`;
                        Logger.debug('GM_getValue fallback: Attempting to get \'' + storageKey + '\'');
                        const value = localStorage.getItem(storageKey);
                        if (value !== null) {
                            try {
                                const parsedValue = JSON.parse(value);
                                Logger.debug('GM_getValue fallback: Found and parsed \'' + storageKey + '\', value:', parsedValue);
                                resolve(parsedValue);
                            } catch (e) {
                                Logger.debug('GM_getValue fallback: Found non-JSON \'' + storageKey + '\', value:', value);
                                resolve(value); // Return as string if not JSON
                            }
                        } else {
                            Logger.debug('GM_getValue fallback: Key \'' + storageKey + '\' not found, returning default:', defaultValue);
                            resolve(defaultValue);
                        }
                    } catch (error) {
                        Logger.error(error, 'Error getting value for key (GM_getValue fallback): ' + key);
                        resolve(defaultValue);
                    }
                });
            };
        }

        /**
         * Set up GM_setValue fallback using localStorage, returning a Promise.
         */
        static setupSetValue() {
            window.GM_setValue = function (key, value) {
                return new Promise((resolve, reject) => {
                    try {
                        const storageKey = `GM_${key}`;
                        Logger.debug('GM_setValue fallback: Attempting to set \'' + storageKey + '\' to:', value);
                        localStorage.setItem(storageKey, JSON.stringify(value));
                        resolve();
                    } catch (error) {
                        Logger.error(error, 'Error setting value for key (GM_setValue fallback): ' + key);
                        reject(error);
                    }
                });
            };
        }
    }

    // Initialize the fallbacks (this will populate window.GM_getValue etc.)
    // The initialize method also returns the map of functions.
    const gmFunctions = GMFunctions.initialize();

    // Export the functions for direct import, matching the names used in CountryFilter.js
    gmFunctions.GM_addStyle;
    gmFunctions.GM_xmlhttpRequest;
    const GM_setClipboard = gmFunctions.GM_setClipboard;
    gmFunctions.GM_download;
    const getValue = gmFunctions.GM_getValue; // Maps to getValue for import { getValue }
    const setValue = gmFunctions.GM_setValue; // Maps to setValue for import { setValue }

    // For potential direct class usage if ever needed, though current pattern is to use the initialized functions.
    // export default GMFunctions; // Not currently used this way

    /**
     * Button - A reusable UI component for buttons.
     * Creates customizable, accessible buttons with various states and callbacks.
     */

    /**
     * A reusable UI component for creating accessible, customizable buttons.
     */
    class Button {
      /**
         * Returns the unique base CSS class for the Button component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for buttons.
         */
      static get BASE_BUTTON_CLASS() {
        return 'userscripts-button';
      }
      /**
         * Returns the CSS variable prefix used for theming and styling the Button component.
         * This prefix scopes all custom CSS variables (e.g., colors, borders) related to the button.
         *
         * @return {string} The CSS variable prefix.
         */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-button-';
      }
      /**
         * Initialize styles for all buttons.
         * These styles reference the CSS variables with our defined prefix.
         */
      static initStyles() {
        if (Button.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts Button Component */
      .${Button.BASE_BUTTON_CLASS} {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-family: inherit;
        font-weight: 500;
        border-radius: 0.375rem;
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.15s ease-in-out;
        text-align: center;
        background-color: var(${Button.CSS_VAR_PREFIX}bg);
        color: var(${Button.CSS_VAR_PREFIX}color);
        border-color: var(${Button.CSS_VAR_PREFIX}border);
      }
      
      /* Button sizes */
      .${Button.BASE_BUTTON_CLASS}--small {
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        min-height: 1.75rem;
      }
      .${Button.BASE_BUTTON_CLASS}--medium {
        font-size: 0.875rem;
        padding: 0.5rem 1rem;
        min-height: 2.25rem;
      }
      .${Button.BASE_BUTTON_CLASS}--large {
        font-size: 1rem;
        padding: 0.75rem 1.5rem;
        min-height: 2.75rem;
      }
      
      /* Button themes using CSS variables */
      .${Button.BASE_BUTTON_CLASS}--default {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-default);
        color: var(${Button.CSS_VAR_PREFIX}color-default);
        border-color: var(${Button.CSS_VAR_PREFIX}border-default);
      }
      .${Button.BASE_BUTTON_CLASS}--default:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-default-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--primary {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-primary);
        color: var(${Button.CSS_VAR_PREFIX}color-primary);
        border-color: var(${Button.CSS_VAR_PREFIX}border-primary);
      }
      .${Button.BASE_BUTTON_CLASS}--primary:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-primary-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-primary-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--secondary {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-secondary);
        color: var(${Button.CSS_VAR_PREFIX}color-secondary);
        border-color: var(${Button.CSS_VAR_PREFIX}border-secondary);
      }
      .${Button.BASE_BUTTON_CLASS}--secondary:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-secondary-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-secondary-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--success {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-success);
        color: var(${Button.CSS_VAR_PREFIX}color-success);
        border-color: var(${Button.CSS_VAR_PREFIX}border-success);
      }
      .${Button.BASE_BUTTON_CLASS}--success:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-success-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-success-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--danger {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-danger);
        color: var(${Button.CSS_VAR_PREFIX}color-danger);
        border-color: var(${Button.CSS_VAR_PREFIX}border-danger);
      }
      .${Button.BASE_BUTTON_CLASS}--danger:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-danger-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-danger-hover);
      }
      
      /* Generic state styles */
      .${Button.BASE_BUTTON_CLASS}:disabled {
        opacity: 0.65;
        cursor: not-allowed;
        pointer-events: none;
      }
      .${Button.BASE_BUTTON_CLASS}:focus {
        outline: none;
        box-shadow: 0 0 0 3px var(${Button.CSS_VAR_PREFIX}focus-shadow);
      }
      
      /* Generic pseudo-class rules */
      .${Button.BASE_BUTTON_CLASS}:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-hover);
      }
      .${Button.BASE_BUTTON_CLASS}:active:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-active);
      }
      
      /* Button content */
      .${Button.BASE_BUTTON_CLASS}__icon {
        display: inline-flex;
        margin-right: 0.5rem;
      }
      .${Button.BASE_BUTTON_CLASS}__text {
        display: inline-block;
      }
    `, 'userscripts-button-styles');

        Button.stylesInitialized = true;
      }
      /**
         * Inject default color variables for the button component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
      static useDefaultColors() {
        const styleId = 'userscripts-button-default-colors';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          // Use textContent instead of innerHTML for CSP compliance
          style.textContent = `
        :root {
          ${Button.CSS_VAR_PREFIX}bg-default: #f3f4f6;
          ${Button.CSS_VAR_PREFIX}color-default: #374151;
          ${Button.CSS_VAR_PREFIX}border-default: #d1d5db;
          ${Button.CSS_VAR_PREFIX}bg-default-hover: #e5e7eb;
          
          ${Button.CSS_VAR_PREFIX}bg-primary: #3b82f6;
          ${Button.CSS_VAR_PREFIX}color-primary: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-primary: #3b82f6;
          ${Button.CSS_VAR_PREFIX}bg-primary-hover: #2563eb;
          ${Button.CSS_VAR_PREFIX}border-primary-hover: #2563eb;
          
          ${Button.CSS_VAR_PREFIX}bg-secondary: #6b7280;
          ${Button.CSS_VAR_PREFIX}color-secondary: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-secondary: #6b7280;
          ${Button.CSS_VAR_PREFIX}bg-secondary-hover: #4b5563;
          ${Button.CSS_VAR_PREFIX}border-secondary-hover: #4b5563;
          
          ${Button.CSS_VAR_PREFIX}bg-success: #10b981;
          ${Button.CSS_VAR_PREFIX}color-success: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-success: #10b981;
          ${Button.CSS_VAR_PREFIX}bg-success-hover: #059669;
          ${Button.CSS_VAR_PREFIX}border-success-hover: #059669;
          
          ${Button.CSS_VAR_PREFIX}bg-danger: #ef4444;
          ${Button.CSS_VAR_PREFIX}color-danger: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-danger: #ef4444;
          ${Button.CSS_VAR_PREFIX}bg-danger-hover: #dc2626;
          ${Button.CSS_VAR_PREFIX}border-danger-hover: #dc2626;
          
          ${Button.CSS_VAR_PREFIX}bg-hover: #e0e0e0;
          ${Button.CSS_VAR_PREFIX}bg-active: #d0d0d0;
          
          ${Button.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.3);
        }
      `;
          document.head.appendChild(style);
        }
      }
      /**
         * Create a new Button.
         * @param {Object} options - Configuration options.
         * @param {String} options.text - Button text.
         * @param {String} [options.type="button"] - Button type.
         * @param {String} [options.className] - Additional custom CSS class.
         * @param {Function} options.onClick - Click event handler.
         * @param {String} [options.id] - Button ID.
         * @param {HTMLElement} [options.container] - Container to append the button to.
         * @param {Object} [options.attributes={}] - Additional HTML attributes.
         * @param {String} [options.theme="default"] - Button theme.
         * @param {String} [options.size="medium"] - Button size.
         * @param {Boolean} [options.disabled=false] - Disabled state.
         * @param {String} [options.icon] - Optional icon HTML.
         * @param {String} [options.successText] - Success state text.
         * @param {Number} [options.successDuration=1500] - Success state duration (ms).
         */
      constructor(options) {
        this.text = options.text || '';
        this.type = options.type || 'button';
        this.customClassName = options.className || '';
        this.onClick = options.onClick;
        this.id = options.id;
        this.container = options.container;
        this.attributes = options.attributes || {};
        this.theme = options.theme;
        this.size = options.size || 'medium';
        this.disabled = options.disabled || false;
        this.icon = options.icon || null;
        this.successText = options.successText || null;
        this.successDuration = options.successDuration || 1500;
        this.originalText = this.text;

        // These properties will refer to the DOM elements.
        this.button = null;
        this.textElement = null;

        Button.initStyles();
        this.create();
      }


      /**
         * Create the button element and, if a container is provided, append it.
         * @return {HTMLButtonElement} The created button element.
         */
      create() {
        this.button = document.createElement('button');
        this.button.type = this.type;
        this.button.disabled = this.disabled;
        if (this.id) this.button.id = this.id;
        this.button._buttonInstance = this;
        this.updateButtonClasses();
        this.updateContent();
        if (this.onClick) this.button.addEventListener('click', (e) => this.handleClick(e));
        Object.entries(this.attributes).forEach(([key, value]) => {
          this.button.setAttribute(key, value);
        });
        if (this.container) this.container.appendChild(this.button);
        return this.button;
      }

      /**
         * Update the classes on the button element based on theme, size, and custom classes.
         */
      updateButtonClasses() {
        const classNames = [Button.BASE_BUTTON_CLASS];
        classNames.push(`${Button.BASE_BUTTON_CLASS}--${this.theme}`);
        classNames.push(`${Button.BASE_BUTTON_CLASS}--${this.size}`);
        if (this.customClassName) classNames.push(this.customClassName);
        this.button.className = classNames.join(' ');
      }

      /**
         * Update the button content (icon and text).
         */
      updateContent() {
        // Clear existing content using DOM methods instead of innerHTML
        while (this.button.firstChild) {
          this.button.removeChild(this.button.firstChild);
        }
        
        if (this.icon) {
          const iconSpan = document.createElement('span');
          iconSpan.className = `${Button.BASE_BUTTON_CLASS}__icon`;
          // Use textContent instead of innerHTML for CSP compliance (icons should be text/emoji)
          iconSpan.textContent = this.icon;
          this.button.appendChild(iconSpan);
        }
        this.textElement = document.createElement('span');
        this.textElement.className = `${Button.BASE_BUTTON_CLASS}__text`;
        this.textElement.textContent = this.text;
        this.button.appendChild(this.textElement);
      }

      /**
         * Handle click events on the button.
         * @param {Event} e - The click event.
         */
      handleClick(e) {
        if (this.disabled) return;
        const result = this.onClick(e);
        if (this.successText && false !== result) {
          this.showSuccessState();
        }
      }

      /**
         * Show a success state by temporarily changing the button's text and theme.
         */
      showSuccessState() {
        const originalText = this.text;
        const originalTheme = this.theme;
        this.setText(this.successText);
        this.setTheme('success');
        setTimeout(() => {
          this.setText(originalText);
          this.setTheme(originalTheme);
        }, this.successDuration);
      }

      /**
         * Set the button's text.
         * @param {String} text - The new text to display.
         */
      setText(text) {
        this.text = text;
        if (this.textElement) {
          this.textElement.textContent = text;
        } else {
          this.updateContent();
        }
      }

      /**
         * Reset the button's text to its original value.
         */
      resetText() {
        this.setText(this.originalText);
      }

      /**
         * Set an icon for the button.
         * @param {String} iconHtml - The HTML string for the icon.
         */
      setIcon(iconHtml) {
        this.icon = iconHtml;
        this.updateContent();
      }

      /**
         * Enable or disable the button.
         * @param {Boolean} disabled - Whether the button should be disabled.
         */
      setDisabled(disabled) {
        this.disabled = disabled;
        this.button.disabled = disabled;
      }

      /**
         * Toggle the disabled state of the button.
         * @return {Boolean} The new disabled state.
         */
      toggleDisabled() {
        this.setDisabled(!this.disabled);
        return this.disabled;
      }

      /**
         * Change the button's theme.
         * @param {String} theme - The new theme (e.g., "default", "primary", etc.).
         */
      setTheme(theme) {
        this.button.classList.remove(`${Button.BASE_BUTTON_CLASS}--${this.theme}`);
        this.theme = theme;
        this.button.classList.add(`${Button.BASE_BUTTON_CLASS}--${this.theme}`);
      }

      /**
         * Change the button's size.
         * @param {String} size - The new size (e.g., "small", "medium", "large").
         */
      setSize(size) {
        this.button.classList.remove(`${Button.BASE_BUTTON_CLASS}--${this.size}`);
        this.size = size;
        this.button.classList.add(`${Button.BASE_BUTTON_CLASS}--${this.size}`);
      }

      /**
         * Apply a custom CSS class to the button.
         * @param {String} className - The custom class name.
         */
      setCustomClass(className) {
        if (this.customClassName) {
          this.button.classList.remove(this.customClassName);
        }
        this.customClassName = className;
        if (className) {
          this.button.classList.add(className);
        }
      }
    }

    // Static property to track if styles have been initialized.
    Button.stylesInitialized = false;
    Button.initStyles();

    /**
     * Enhanced version of the ProgressBar core component with Eksi-style UI
     * This replaces the existing ProgressBar.js file in the core/ui directory
     */

    class ProgressBar {
      /**
         * Returns the unique base CSS class for the ProgressBar component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for progress bars.
         */
      static get BASE_PROGRESS_CLASS() {
        return 'userscripts-progress';
      }
      /**
         * Returns the CSS variable prefix used for theming the ProgressBar component.
         * This prefix scopes all custom CSS variables (e.g., colors) related to the progress bar.
         *
         * @return {string} The CSS variable prefix.
         */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-progress-';
      }
      /**
         * Initialize styles for all progress bars.
         * These styles reference the CSS variables with our defined prefix.
         */
      static initStyles() {
        if (ProgressBar.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts ProgressBar Component */
      .${ProgressBar.BASE_PROGRESS_CLASS} {
        width: 100%;
        margin: 10px 0;
        position: relative;
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-label {
        font-size: 0.875rem;
        margin-bottom: 4px;
        display: block;
        color: var(${ProgressBar.CSS_VAR_PREFIX}label-color, #555);
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-bar {
        height: 20px;
        background-color: var(${ProgressBar.CSS_VAR_PREFIX}bar-bg, #f3f3f3);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        height: 100%;
        width: 0%;
        border-radius: 10px;
        transition: width 0.5s ease;
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}fill-bg)), 
          var(${ProgressBar.CSS_VAR_PREFIX}fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}fill-bg))
        );
        position: relative;
        overflow: hidden;
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-fill::after {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.1) 25%,
          transparent 25%,
          transparent 50%,
          rgba(255, 255, 255, 0.1) 50%,
          rgba(255, 255, 255, 0.1) 75%,
          transparent 75%,
          transparent 100%
        );
        background-size: 30px 30px;
        animation: ${ProgressBar.BASE_PROGRESS_CLASS}-stripes 1s linear infinite;
      }
      
      @keyframes ${ProgressBar.BASE_PROGRESS_CLASS}-stripes {
        0% {
          background-position: 0 0;
        }
        100% {
          background-position: 30px 0;
        }
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-text {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 10px;
        font-size: 0.75rem;
        color: var(${ProgressBar.CSS_VAR_PREFIX}text-color, #333);
        font-weight: bold;
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
        z-index: 1;
      }
      
      /* Themes */
      .${ProgressBar.BASE_PROGRESS_CLASS}--default .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}default-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}default-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--primary .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--success .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}success-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}success-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--danger .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--warning .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-bg))
        );
      }
      
      /* Sizes */
      .${ProgressBar.BASE_PROGRESS_CLASS}--small .${ProgressBar.BASE_PROGRESS_CLASS}-bar {
        height: 8px;
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--large .${ProgressBar.BASE_PROGRESS_CLASS}-bar {
        height: 24px;
      }
    `, 'userscripts-progress-styles');
        ProgressBar.stylesInitialized = true;
      }
      /**
         * Injects default color variables for the ProgressBar component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
      static useDefaultColors() {
        const styleId = 'userscripts-progress-default-colors';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          style.innerHTML = `
        :root {
          /* Base colors */
          ${ProgressBar.CSS_VAR_PREFIX}label-color: #555;
          ${ProgressBar.CSS_VAR_PREFIX}bar-bg: #f3f3f3;
          ${ProgressBar.CSS_VAR_PREFIX}fill-bg: #6b7280;
          ${ProgressBar.CSS_VAR_PREFIX}text-color: #333;
          
          /* Theme colors with gradients */
          ${ProgressBar.CSS_VAR_PREFIX}default-fill-bg: #6b7280;
          ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-start: #6b7280;
          ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-end: #4b5563;
          
          ${ProgressBar.CSS_VAR_PREFIX}primary-fill-bg: #3b82f6;
          ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-start: #3b82f6;
          ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-end: #2563eb;
          
          ${ProgressBar.CSS_VAR_PREFIX}success-fill-bg: #10b981;
          ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-start: #10b981;
          ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-end: #059669;
          
          ${ProgressBar.CSS_VAR_PREFIX}danger-fill-bg: #ef4444;
          ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-start: #ef4444;
          ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-end: #dc2626;
          
          ${ProgressBar.CSS_VAR_PREFIX}warning-fill-bg: #f59e0b;
          ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-start: #f59e0b;
          ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-end: #d97706;
        }
      `;
          document.head.appendChild(style);
        }
      }
      /**
         * Create a new progress bar.
         * @param {Object} options - Configuration options.
         * @param {number} options.initialValue - Initial progress value (0-100).
         * @param {string} [options.className='userscripts-progress'] - CSS class for styling.
         * @param {HTMLElement} options.container - Container element to which the progress bar will be appended.
         * @param {boolean} [options.showText=true] - Whether to display the progress text.
         * @param {boolean} [options.showLabel=false] - Whether to display a label above the progress bar.
         * @param {string} [options.label=''] - Label text to display if showLabel is true.
         * @param {string} [options.theme='default'] - Theme for the progress bar (e.g., "default", "primary", "success").
         * @param {string} [options.size='normal'] - Size of the progress bar ('small', 'normal', 'large').
         */
      constructor(options) {
        this.value = options.initialValue || 0;
        this.className = options.className || ProgressBar.BASE_PROGRESS_CLASS;
        this.container = options.container;
        this.showText = options.showText !== undefined ? options.showText : true;
        this.showLabel = options.showLabel || false;
        this.label = options.label || '';
        this.theme = options.theme || 'default';
        this.size = options.size || 'normal';

        this.progressElement = null;
        this.progressBarElement = null;
        this.progressFillElement = null;
        this.progressTextElement = null;
        this.labelElement = null;

        ProgressBar.initStyles();
        this.create();
      }


      /**
         * Creates the progress bar elements and appends them to the container if provided.
         * @return {HTMLElement} The created progress bar container element.
         */
      create() {
        // Create the progress bar container
        this.progressElement = document.createElement('div');
        this.progressElement.className = `${this.className} ${this.className}--${this.theme}`;

        if ('normal' !== this.size) {
          this.progressElement.classList.add(`${this.className}--${this.size}`);
        }

        // Add a label if requested
        if (this.showLabel) {
          this.labelElement = document.createElement('span');
          this.labelElement.className = `${this.className}-label`;
          this.labelElement.textContent = this.label;
          this.progressElement.appendChild(this.labelElement);
        }

        // Create the progress bar and its fill
        this.progressBarElement = document.createElement('div');
        this.progressBarElement.className = `${this.className}-bar`;

        this.progressFillElement = document.createElement('div');
        this.progressFillElement.className = `${this.className}-fill`;
        this.progressFillElement.style.width = `${this.value}%`;

        this.progressBarElement.appendChild(this.progressFillElement);
        this.progressElement.appendChild(this.progressBarElement);

        // Add progress text as absolute positioned element
        if (this.showText) {
          this.progressTextElement = document.createElement('div');
          this.progressTextElement.className = `${this.className}-text`;
          this.progressTextElement.textContent = `${this.value}%`;
          this.progressBarElement.appendChild(this.progressTextElement);
        }

        // Append the entire progress element to the container, if one was provided
        if (this.container) {
          this.container.appendChild(this.progressElement);
        }
        return this.progressElement;
      }

      /**
         * Updates the progress value and (optionally) the display text.
         * @param {number} value - The new progress value (between 0 and 100).
         * @param {string} [text] - Optional custom text to display.
         * @return {number} The updated progress value.
         */
      setValue(value, text) {
        this.value = Math.min(100, Math.max(0, value));
        if (this.progressFillElement) {
          this.progressFillElement.style.width = `${this.value}%`;
        }
        if (this.showText && this.progressTextElement) {
          this.progressTextElement.textContent = text || `${this.value}%`;
        }
        return this.value;
      }

      /**
         * Changes the progress bar theme by updating the theme class.
         * @param {string} theme - The new theme (e.g., "default", "primary", "success", etc.).
         */
      setTheme(theme) {
        this.theme = theme;
        if (this.progressElement) {
          // Remove any existing theme class (assumed to be in the format `${this.className}--<theme>`)
          const classes = this.progressElement.className.split(' ');
          const nonThemeClasses = classes.filter((cls) =>
            !cls.startsWith(`${this.className}--`) ||
                    cls === `${this.className}--${this.size}`, // Keep size class
          );
          this.progressElement.className = `${nonThemeClasses.join(' ')} ${this.className}--${this.theme}`;
        }
      }

      /**
         * Changes the progress bar size.
         * @param {string} size - The new size ('small', 'normal', 'large').
         */
      setSize(size) {
        this.size = size;
        if (this.progressElement) {
          // Remove size classes
          this.progressElement.classList.remove(`${this.className}--small`);
          this.progressElement.classList.remove(`${this.className}--large`);

          // Add new size class if not normal
          if ('normal' !== size) {
            this.progressElement.classList.add(`${this.className}--${size}`);
          }
        }
      }

      /**
         * Sets the label text for the progress bar.
         * @param {string} label - The new label text.
         */
      setLabel(label) {
        this.label = label;
        if (this.labelElement) {
          this.labelElement.textContent = label;
        }
      }

      /**
         * Shows or hides the entire progress bar.
         * @param {boolean} visible - True to show, false to hide.
         */
      setVisible(visible) {
        if (this.progressElement) {
          this.progressElement.style.display = visible ? '' : 'none';
        }
      }

      /**
         * Destroys the progress bar and removes it from the DOM.
         */
      destroy() {
        if (this.progressElement && this.progressElement.parentNode) {
          this.progressElement.parentNode.removeChild(this.progressElement);
        }
        this.progressElement = null;
        this.progressBarElement = null;
        this.progressFillElement = null;
        this.progressTextElement = null;
        this.labelElement = null;
      }
    }

    // Static property to track if styles have been initialized.
    ProgressBar.stylesInitialized = false;

    // Initialize styles when imported.
    ProgressBar.initStyles();

    /**
     * Checkbox - A reusable UI component for checkboxes.
     * Creates customizable, accessible checkboxes with various states and callbacks.
     */

    /**
     * A reusable UI component for creating accessible, customizable checkboxes.
     */
    class Checkbox {
      /**
         * Returns the unique base CSS class for the Checkbox component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for checkboxes.
         */
      static get BASE_CHECKBOX_CLASS() {
        return 'userscripts-checkbox';
      }
      /**
         * Returns the CSS variable prefix used for theming and styling the Checkbox component.
         * This prefix scopes all custom CSS variables (e.g., colors, borders) related to the checkbox.
         *
         * @return {string} The CSS variable prefix.
         */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-checkbox-';
      }
      /**
         * Initialize styles for all checkboxes.
         * These styles reference the CSS variables with our defined prefix.
         */
      static initStyles() {
        if (Checkbox.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts Checkbox Component */
      .${Checkbox.BASE_CHECKBOX_CLASS}-container {
        display: inline-flex;
        align-items: center;
        position: relative;
        cursor: pointer;
        user-select: none;
        font-family: inherit;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled {
        opacity: 0.65;
        cursor: not-allowed;
      }
      
      /* Hide native checkbox */
      .${Checkbox.BASE_CHECKBOX_CLASS}-native {
        position: absolute;
        opacity: 0;
        height: 0;
        width: 0;
      }
      
      /* Custom checkbox appearance */
      .${Checkbox.BASE_CHECKBOX_CLASS} {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 0.25rem;
        border: 2px solid var(${Checkbox.CSS_VAR_PREFIX}border-color);
        background-color: var(${Checkbox.CSS_VAR_PREFIX}bg);
        transition: all 0.2s ease;
        position: relative;
      }
      
      /* Check mark (initially hidden) */
      .${Checkbox.BASE_CHECKBOX_CLASS}::after {
        content: '';
        position: absolute;
        opacity: 0;
        transform: rotate(45deg) scale(0);
        width: 0.3125rem;
        height: 0.625rem;
        border-right: 2px solid var(${Checkbox.CSS_VAR_PREFIX}checkmark-color);
        border-bottom: 2px solid var(${Checkbox.CSS_VAR_PREFIX}checkmark-color);
        transition: all 0.2s ease;
      }
      
      /* When checkbox is checked */
      .${Checkbox.BASE_CHECKBOX_CLASS}--checked {
        background-color: var(${Checkbox.CSS_VAR_PREFIX}checked-bg);
        border-color: var(${Checkbox.CSS_VAR_PREFIX}checked-border);
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--checked::after {
        opacity: 1;
        transform: rotate(45deg) scale(1);
      }
      
      /* Indeterminate state */
      .${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate::after {
        opacity: 1;
        transform: rotate(0) scale(1);
        width: 0.625rem;
        height: 0.125rem;
        border-right: none;
        border-bottom: 2px solid var(${Checkbox.CSS_VAR_PREFIX}checkmark-color);
      }
      
      /* On hover */
      .${Checkbox.BASE_CHECKBOX_CLASS}-container:hover .${Checkbox.BASE_CHECKBOX_CLASS}:not(.${Checkbox.BASE_CHECKBOX_CLASS}--checked):not(.${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate) {
        border-color: var(${Checkbox.CSS_VAR_PREFIX}hover-border);
        background-color: var(${Checkbox.CSS_VAR_PREFIX}hover-bg);
      }
      
      /* On focus */
      .${Checkbox.BASE_CHECKBOX_CLASS}-container:focus-within .${Checkbox.BASE_CHECKBOX_CLASS} {
        box-shadow: 0 0 0 3px var(${Checkbox.CSS_VAR_PREFIX}focus-shadow);
      }
      
      /* Label styles */
      .${Checkbox.BASE_CHECKBOX_CLASS}-label {
        margin-left: 0.5rem;
        font-size: 0.875rem;
      }
      
      /* Checkbox sizes */
      .${Checkbox.BASE_CHECKBOX_CLASS}--small {
        width: 1rem;
        height: 1rem;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--small::after {
        width: 0.25rem;
        height: 0.5rem;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--large {
        width: 1.5rem;
        height: 1.5rem;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--large::after {
        width: 0.375rem;
        height: 0.75rem;
      }
    `, 'userscripts-checkbox-styles');

        Checkbox.stylesInitialized = true;
      }
      /**
         * Inject default color variables for the checkbox component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
      static useDefaultColors() {
        const styleId = 'userscripts-checkbox-default-colors';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          style.innerHTML = `
        :root {
          /* Default state */
          ${Checkbox.CSS_VAR_PREFIX}bg: #ffffff;
          ${Checkbox.CSS_VAR_PREFIX}border-color: #d1d5db;
          ${Checkbox.CSS_VAR_PREFIX}hover-bg: #f3f4f6;
          ${Checkbox.CSS_VAR_PREFIX}hover-border: #9ca3af;
          
          /* Checked state */
          ${Checkbox.CSS_VAR_PREFIX}checked-bg: #3b82f6;
          ${Checkbox.CSS_VAR_PREFIX}checked-border: #3b82f6;
          ${Checkbox.CSS_VAR_PREFIX}checkmark-color: #ffffff;
          
          /* Focus state */
          ${Checkbox.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.3);
        }
      `;
          document.head.appendChild(style);
        }
      }
      /**
         * Create a new Checkbox.
         * @param {Object} options - Configuration options.
         * @param {String} [options.label] - Checkbox label text.
         * @param {Boolean} [options.checked=false] - Initial checked state.
         * @param {Boolean} [options.indeterminate=false] - Initial indeterminate state.
         * @param {String} [options.id] - Checkbox ID.
         * @param {String} [options.name] - Input name attribute.
         * @param {Function} [options.onChange] - Change event handler.
         * @param {HTMLElement} [options.container] - Container to append the checkbox to.
         * @param {String} [options.className] - Additional custom CSS class.
         * @param {Boolean} [options.disabled=false] - Disabled state.
         * @param {String} [options.size="medium"] - Checkbox size.
         * @param {Object} [options.attributes={}] - Additional HTML attributes.
         */
      constructor(options = {}) {
        this.label = options.label || '';
        this.checked = options.checked || false;
        this.indeterminate = options.indeterminate || false;
        this.id = options.id;
        this.name = options.name;
        this.onChange = options.onChange;
        this.container = options.container;
        this.customClassName = options.className || '';
        this.disabled = options.disabled || false;
        this.size = options.size || 'medium';
        this.attributes = options.attributes || {};

        // DOM elements references
        this.checkboxContainer = null;
        this.customCheckbox = null;
        this.nativeCheckbox = null;
        this.labelElement = null;

        Checkbox.initStyles();
        this.create();
      }


      /**
         * Create the checkbox UI and, if a container is provided, append it.
         * @return {HTMLElement} The created checkbox container element.
         */
      create() {
        // Create container
        this.checkboxContainer = document.createElement('label');
        this.checkboxContainer.className = `${Checkbox.BASE_CHECKBOX_CLASS}-container`;
        if (this.customClassName) {
          this.checkboxContainer.classList.add(this.customClassName);
        }
        if (this.disabled) {
          this.checkboxContainer.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled`);
        }

        // Create hidden native checkbox for accessibility
        this.nativeCheckbox = document.createElement('input');
        this.nativeCheckbox.type = 'checkbox';
        this.nativeCheckbox.className = `${Checkbox.BASE_CHECKBOX_CLASS}-native`;
        this.nativeCheckbox.checked = this.checked;
        this.nativeCheckbox.indeterminate = this.indeterminate;
        this.nativeCheckbox.disabled = this.disabled;

        if (this.id) this.nativeCheckbox.id = this.id;
        if (this.name) this.nativeCheckbox.name = this.name;

        Object.entries(this.attributes).forEach(([key, value]) => {
          this.nativeCheckbox.setAttribute(key, value);
        });

        // Create custom checkbox visual
        this.customCheckbox = document.createElement('span');
        this.customCheckbox.className = `${Checkbox.BASE_CHECKBOX_CLASS} ${Checkbox.BASE_CHECKBOX_CLASS}--${this.size}`;
        if (this.checked) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        } else if (this.indeterminate) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        }

        // Create label if provided
        if (this.label) {
          this.labelElement = document.createElement('span');
          this.labelElement.className = `${Checkbox.BASE_CHECKBOX_CLASS}-label`;
          this.labelElement.textContent = this.label;
        }

        // Set up event listeners
        this.nativeCheckbox.addEventListener('change', (e) => this.handleChange(e));
        this.nativeCheckbox.addEventListener('focus', () => this.handleFocus());
        this.nativeCheckbox.addEventListener('blur', () => this.handleBlur());

        // Assemble the component
        this.checkboxContainer.appendChild(this.nativeCheckbox);
        this.checkboxContainer.appendChild(this.customCheckbox);
        if (this.labelElement) {
          this.checkboxContainer.appendChild(this.labelElement);
        }

        // Add to container if provided
        if (this.container) {
          this.container.appendChild(this.checkboxContainer);
        }

        // Store reference to instance on DOM element for potential external access
        this.checkboxContainer._checkboxInstance = this;

        return this.checkboxContainer;
      }

      /**
         * Handle change events.
         * @param {Event} e - The change event.
         */
      handleChange(e) {
        this.checked = this.nativeCheckbox.checked;
        this.indeterminate = this.nativeCheckbox.indeterminate;

        if (this.checked) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        } else if (this.indeterminate) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        } else {
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        }

        if (this.onChange) {
          this.onChange(e);
        }
      }

      /**
         * Handle focus events.
         */
      handleFocus() {
        // Additional focus behaviors can be added here if needed
      }

      /**
         * Handle blur events.
         */
      handleBlur() {
        // Additional blur behaviors can be added here if needed
      }

      /**
         * Set the checked state.
         * @param {Boolean} checked - The new checked state.
         */
      setChecked(checked) {
        this.checked = checked;
        this.nativeCheckbox.checked = checked;

        if (checked) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
          this.indeterminate = false;
          this.nativeCheckbox.indeterminate = false;
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        } else {
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        }
      }

      /**
         * Set the indeterminate state.
         * @param {Boolean} indeterminate - The new indeterminate state.
         */
      setIndeterminate(indeterminate) {
        this.indeterminate = indeterminate;
        this.nativeCheckbox.indeterminate = indeterminate;

        if (indeterminate) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        } else {
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        }
      }

      /**
         * Toggle the checked state.
         * @return {Boolean} The new checked state.
         */
      toggle() {
        this.setChecked(!this.checked);
        return this.checked;
      }

      /**
         * Set the disabled state.
         * @param {Boolean} disabled - The new disabled state.
         */
      setDisabled(disabled) {
        this.disabled = disabled;
        this.nativeCheckbox.disabled = disabled;

        if (disabled) {
          this.checkboxContainer.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled`);
        } else {
          this.checkboxContainer.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled`);
        }
      }

      /**
         * Set the label text.
         * @param {String} text - The new label text.
         */
      setLabel(text) {
        this.label = text;

        if (!this.labelElement) {
          this.labelElement = document.createElement('span');
          this.labelElement.className = `${Checkbox.BASE_CHECKBOX_CLASS}-label`;
          this.checkboxContainer.appendChild(this.labelElement);
        }

        this.labelElement.textContent = text;
      }

      /**
         * Change the checkbox size.
         * @param {String} size - The new size (e.g., "small", "medium", "large").
         */
      setSize(size) {
        this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--${this.size}`);
        this.size = size;
        this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--${this.size}`);
      }

      /**
         * Apply a custom CSS class to the checkbox container.
         * @param {String} className - The custom class name.
         */
      setCustomClass(className) {
        if (this.customClassName) {
          this.checkboxContainer.classList.remove(this.customClassName);
        }
        this.customClassName = className;
        if (className) {
          this.checkboxContainer.classList.add(className);
        }
      }

      /**
         * Get the current checked state.
         * @return {Boolean} The current checked state.
         */
      isChecked() {
        return this.checked;
      }

      /**
         * Get the current indeterminate state.
         * @return {Boolean} The current indeterminate state.
         */
      isIndeterminate() {
        return this.indeterminate;
      }

      /**
         * Get the current disabled state.
         * @return {Boolean} The current disabled state.
         */
      isDisabled() {
        return this.disabled;
      }
    }

    // Static property to track if styles have been initialized.
    Checkbox.stylesInitialized = false;
    Checkbox.initStyles();

    /**
     * SidebarPanel - A reusable UI component for creating a sidebar panel with a trigger button
     * Similar to Wallapop's help button that shifts the site content
     */

    /**
     * A reusable component that creates a toggle button and sidebar panel
     */
    class SidebarPanel {
        // Panel states
        static PANEL_STATES = {
            OPENED: 'opened',
            CLOSED: 'closed'
        };

        // Panel positions
        static PANEL_POSITIONS = {
            RIGHT: 'right',
            LEFT: 'left'
        };

        // Panel transitions
        static PANEL_TRANSITIONS = {
            SLIDE: 'slide',
            PUSH: 'push'
        };

        // GM storage keys
        static STORAGE_KEYS = {
            PANEL_STATE: 'sidebar-panel-state',
            PANEL_SETTINGS: 'sidebar-panel-settings'
        };

        // PubSub events
        static EVENTS = {
            PANEL_OPEN: 'sidebar-panel-open',
            PANEL_CLOSE: 'sidebar-panel-close',
            PANEL_TOGGLE: 'sidebar-panel-toggle',
            PANEL_INITIALIZED: 'sidebar-panel-initialized'
        };

        /**
         * Create a new SidebarPanel.
         * @param {Object} options - Configuration options.
         * @param {String} options.title - Panel title.
         * @param {String} [options.id="sidebar-panel"] - Unique ID for the panel.
         * @param {String} [options.position="right"] - Position of the panel ("right" or "left").
         * @param {String} [options.transition="slide"] - Transition effect ("slide" or "push").
         * @param {String} [options.buttonIcon="?"] - HTML content for the toggle button.
         * @param {Boolean} [options.showButton=true] - Whether to show the toggle button.
         * @param {String} [options.namespace="userscripts"] - Namespace for CSS classes.
         * @param {Function} [options.onOpen=null] - Callback when panel opens.
         * @param {Function} [options.onClose=null] - Callback when panel closes.
         * @param {Boolean} [options.overlay=true] - Whether to show an overlay behind the panel.
         * @param {Object} [options.content={}] - Content configuration.
         * @param {String|HTMLElement} [options.content.html=null] - HTML content for the panel.
         * @param {Function} [options.content.generator=null] - Function that returns content.
         * @param {Boolean} [options.rememberState=true] - Whether to remember the panel state.
         * @param {Object} [options.style={}] - Custom style options.
         * @param {String} [options.style.width="320px"] - Panel width.
         * @param {String} [options.style.buttonSize="48px"] - Button size.
         * @param {String} [options.style.buttonColor="#fff"] - Button text color.
         * @param {String} [options.style.buttonBg="#625df5"] - Button background color.
         * @param {String} [options.style.panelBg="#fff"] - Panel background color.
         */
        constructor(options = {}) {
            // Process and store options with defaults
            this.options = {
                title: options.title || 'Panel',
                id: options.id || 'sidebar-panel',
                position: options.position || SidebarPanel.PANEL_POSITIONS.RIGHT,
                transition: options.transition || SidebarPanel.PANEL_TRANSITIONS.SLIDE,
                buttonIcon: options.buttonIcon || '?',
                showButton: options.showButton !== false,
                namespace: options.namespace || 'userscripts',
                onOpen: options.onOpen || null,
                onClose: options.onClose || null,
                overlay: options.overlay !== false,
                content: options.content || {},
                rememberState: options.rememberState !== false,
                style: options.style || {}
            };

            // Setup base class names based on namespace
            this.baseClass = `${this.options.namespace}-sidebar-panel`;
            this.cssVarPrefix = `--${this.options.namespace}-sidebar-panel-`;

            // Elements references
            this.container = null;
            this.panel = null;
            this.button = null;
            this.closeButton = null;
            this.content = null;
            this.header = null;
            this.footer = null;
            this.overlay = null;

            // Panel state
            this.state = this.getSavedState() || SidebarPanel.PANEL_STATES.CLOSED;

            // Storage key for this specific panel instance
            this.storageKey = `${SidebarPanel.STORAGE_KEYS.PANEL_STATE}-${this.options.id}`;

            // Initialize the component
            this.init();
        }

        /**
         * Initialize the styles for the SidebarPanel
         * @param {String} namespace - Optional namespace to prevent CSS collisions
         */
        static initStyles(namespace = 'userscripts') {
            const baseClass = `${namespace}-sidebar-panel`;
            const cssVarPrefix = `--${namespace}-sidebar-panel-`;

            StyleManager.addStyles(`
            /* Base styles for the sidebar panel */
            .${baseClass}-container {
                position: fixed;
                top: 0;
                height: 100%;
                z-index: 9998;
                transition: transform 0.3s ease-in-out;
            }
            
            .${baseClass}-container--right {
                right: 0;
                transform: translateX(100%);
            }
            
            .${baseClass}-container--left {
                left: 0;
                transform: translateX(-100%);
            }
            
            .${baseClass}-container--opened {
                transform: translateX(0);
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            }
            
            .${baseClass} {
                width: var(${cssVarPrefix}width, 320px);
                height: 100%;
                background-color: var(${cssVarPrefix}bg, #fff);
                display: flex;
                flex-direction: column;
                overflow: hidden;
                position: relative;
            }
            
            .${baseClass}-header {
                padding: 16px;
                background-color: var(${cssVarPrefix}header-bg, #f5f5f5);
                border-bottom: 1px solid var(${cssVarPrefix}border-color, #eee);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .${baseClass}-title {
                font-weight: bold;
                font-size: 18px;
                color: var(${cssVarPrefix}title-color, #333);
                margin: 0;
            }
            
            .${baseClass}-close {
                background: none;
                border: none;
                cursor: pointer;
                font-size: 24px;
                line-height: 24px;
                padding: 0;
                width: 24px;
                height: 24px;
                color: var(${cssVarPrefix}close-color, #777);
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .${baseClass}-close:hover {
                color: var(${cssVarPrefix}close-color-hover, #333);
            }
            
            .${baseClass}-content {
                flex: 1;
                overflow-y: auto;
                padding: 16px;
            }
            
            .${baseClass}-footer {
                padding: 16px;
                background-color: var(${cssVarPrefix}footer-bg, #f5f5f5);
                border-top: 1px solid var(${cssVarPrefix}border-color, #eee);
            }
            
            /* Toggle button styles */
            .${baseClass}-toggle {
                position: fixed;
                width: var(${cssVarPrefix}button-size, 48px);
                height: var(${cssVarPrefix}button-size, 48px);
                border-radius: 50%;
                background-color: var(${cssVarPrefix}button-bg, #625df5);
                color: var(${cssVarPrefix}button-color, #fff);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                z-index: 9999;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                border: none;
                outline: none;
                transition: background-color 0.2s ease, transform 0.2s ease;
            }
            
            .${baseClass}-toggle:hover {
                background-color: var(${cssVarPrefix}button-bg-hover, #514dc6);
                transform: scale(1.05);
            }
            
            .${baseClass}-toggle--right {
                right: 20px;
                bottom: 20px;
            }
            
            .${baseClass}-toggle--left {
                left: 20px;
                bottom: 20px;
            }
            
            /* For push transition effect */
            body.${baseClass}-push-active--right {
                transition: margin-left 0.3s ease-in-out;
            }
            
            body.${baseClass}-push-active--right.${baseClass}-push--opened {
                margin-left: calc(-1 * var(${cssVarPrefix}width, 320px));
            }
            
            body.${baseClass}-push-active--left {
                transition: margin-right 0.3s ease-in-out;
            }
            
            body.${baseClass}-push-active--left.${baseClass}-push--opened {
                margin-right: calc(-1 * var(${cssVarPrefix}width, 320px));
            }
            
            /* Overlay for mobile views */
            .${baseClass}-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 9997;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.3s ease;
                pointer-events: none;
            }
            
            .${baseClass}-overlay--visible {
                opacity: 1;
                visibility: visible;
                pointer-events: auto;
            }
            
            /* Responsive styles */
            @media (max-width: 768px) {
                .${baseClass} {
                    width: 85vw;
                }
            }
        `, `${namespace}-sidebar-panel-styles`);
        }

        /**
         * Initialize the panel and button
         */
        init() {
            // Initialize styles if not already done
            SidebarPanel.initStyles(this.options.namespace);

            // Create custom CSS variables for this instance
            this.applyCustomStyles();

            // Create the panel elements
            this.createPanel();

            // Create toggle button if needed
            if (this.options.showButton) {
                this.createToggleButton();
            }

            // Create overlay if needed
            if (this.options.overlay) {
                this.createOverlay();
            }

            // Set up events
            this.setupEvents();

            // Apply saved state if we're remembering state
            if (this.options.rememberState) {
                if (this.state === SidebarPanel.PANEL_STATES.OPENED) {
                    this.open(false); // Open without animation for initial state
                }
            }

            // Publish initialization event
            PubSub.publish(SidebarPanel.EVENTS.PANEL_INITIALIZED, {
                id: this.options.id,
                panel: this
            });

            Logger.debug(`SidebarPanel initialized: ${this.options.id}`);
        }

        /**
         * Apply custom styles from options
         */
        applyCustomStyles() {
            const customStyles = {};

            // Process style options
            if (this.options.style.width) {
                customStyles[`${this.cssVarPrefix}width`] = this.options.style.width;
            }
            if (this.options.style.buttonSize) {
                customStyles[`${this.cssVarPrefix}button-size`] = this.options.style.buttonSize;
            }
            if (this.options.style.buttonColor) {
                customStyles[`${this.cssVarPrefix}button-color`] = this.options.style.buttonColor;
            }
            if (this.options.style.buttonBg) {
                customStyles[`${this.cssVarPrefix}button-bg`] = this.options.style.buttonBg;
            }
            if (this.options.style.buttonBgHover) {
                customStyles[`${this.cssVarPrefix}button-bg-hover`] = this.options.style.buttonBgHover;
            }
            if (this.options.style.panelBg) {
                customStyles[`${this.cssVarPrefix}bg`] = this.options.style.panelBg;
            }

            // Apply the CSS variables using StyleManager
            if (Object.keys(customStyles).length > 0) {
                const styleId = `${this.baseClass}-custom-${this.options.id}`;
                let cssText = `:root {\n`;

                for (const [key, value] of Object.entries(customStyles)) {
                    cssText += `  ${key}: ${value};\n`;
                }

                cssText += `}\n`;
                StyleManager.addStyles(cssText, styleId);
            }
        }

        /**
         * Create the panel element
         */
        createPanel() {
            // Create panel container
            this.container = document.createElement('div');
            this.container.id = `${this.baseClass}-${this.options.id}`;
            this.container.className = `${this.baseClass}-container ${this.baseClass}-container--${this.options.position}`;

            // Create panel
            this.panel = document.createElement('div');
            this.panel.className = this.baseClass;

            // Create panel header
            this.header = document.createElement('div');
            this.header.className = `${this.baseClass}-header`;

            // Create title
            const title = document.createElement('h2');
            title.className = `${this.baseClass}-title`;
            title.textContent = this.options.title;
            this.header.appendChild(title);

            // Create close button
            this.closeButton = document.createElement('button');
            this.closeButton.type = 'button';
            this.closeButton.className = `${this.baseClass}-close`;
            this.closeButton.textContent = '×';
            this.closeButton.setAttribute('aria-label', 'Close');
            this.header.appendChild(this.closeButton);

            // Create content container
            this.content = document.createElement('div');
            this.content.className = `${this.baseClass}-content`;

            // Add initial content if provided
            if (this.options.content.html) {
                if (typeof this.options.content.html === 'string') {
                    // For string content, create a text node instead of using innerHTML
                    this.content.textContent = this.options.content.html;
                } else if (this.options.content.html instanceof HTMLElement) {
                    this.content.appendChild(this.options.content.html);
                }
            } else if (this.options.content.generator && typeof this.options.content.generator === 'function') {
                const generatedContent = this.options.content.generator();
                if (typeof generatedContent === 'string') {
                    // For string content, create a text node instead of using innerHTML
                    this.content.textContent = generatedContent;
                } else if (generatedContent instanceof HTMLElement) {
                    this.content.appendChild(generatedContent);
                }
            }

            // Create footer (optional)
            if (this.options.footer) {
                this.footer = document.createElement('div');
                this.footer.className = `${this.baseClass}-footer`;

                if (typeof this.options.footer === 'string') {
                    // For string content, create a text node instead of using innerHTML
                    this.footer.textContent = this.options.footer;
                } else if (this.options.footer instanceof HTMLElement) {
                    this.footer.appendChild(this.options.footer);
                }
            }

            // Assemble the panel
            this.panel.appendChild(this.header);
            this.panel.appendChild(this.content);
            if (this.footer) {
                this.panel.appendChild(this.footer);
            }
            this.container.appendChild(this.panel);

            // Add to document
            document.body.appendChild(this.container);
        }

        /**
         * Create toggle button
         */
        createToggleButton() {
            this.button = document.createElement('button');
            this.button.type = 'button';
            this.button.className = `${this.baseClass}-toggle ${this.baseClass}-toggle--${this.options.position}`;
            this.button.textContent = this.options.buttonIcon;
            this.button.setAttribute('aria-label', `Open ${this.options.title}`);

            // Add to document
            document.body.appendChild(this.button);
        }

        /**
         * Create overlay element
         */
        createOverlay() {
            this.overlay = document.createElement('div');
            this.overlay.className = `${this.baseClass}-overlay`;
            document.body.appendChild(this.overlay);
        }

        /**
         * Set up event listeners
         */
        setupEvents() {
            // Toggle button click
            if (this.button) {
                this.button.addEventListener('click', () => this.toggle());
            }

            // Close button click
            if (this.closeButton) {
                this.closeButton.addEventListener('click', () => this.close());
            }

            // Overlay click
            if (this.overlay) {
                this.overlay.addEventListener('click', () => this.close());
            }

            // Listen for PubSub events
            this.subscriptions = [
                PubSub.subscribe(`${SidebarPanel.EVENTS.PANEL_OPEN}-${this.options.id}`, () => this.open()),
                PubSub.subscribe(`${SidebarPanel.EVENTS.PANEL_CLOSE}-${this.options.id}`, () => this.close()),
                PubSub.subscribe(`${SidebarPanel.EVENTS.PANEL_TOGGLE}-${this.options.id}`, () => this.toggle())
            ];

            // ESC key to close
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.state === SidebarPanel.PANEL_STATES.OPENED) {
                    this.close();
                }
            });
        }

        /**
         * Toggle panel state
         */
        toggle() {
            if (this.state === SidebarPanel.PANEL_STATES.CLOSED) {
                this.open();
            } else {
                this.close();
            }
        }

        /**
         * Open the panel
         * @param {Boolean} animate - Whether to animate the opening
         */
        open(animate = true) {
            if (this.state === SidebarPanel.PANEL_STATES.OPENED) return;

            this.state = SidebarPanel.PANEL_STATES.OPENED;

            // Update panel class
            if (!animate) {
                this.container.style.transition = 'none';
                requestAnimationFrame(() => {
                    this.container.style.transition = '';
                });
            }

            this.container.classList.add(`${this.baseClass}-container--opened`);

            // Handle push transition
            if (this.options.transition === SidebarPanel.PANEL_TRANSITIONS.PUSH) {
                document.body.classList.add(`${this.baseClass}-push-active--${this.options.position}`);
                document.body.classList.add(`${this.baseClass}-push--opened`);
            }

            // Show overlay
            if (this.overlay) {
                this.overlay.classList.add(`${this.baseClass}-overlay--visible`);
            }

            // Save state
            if (this.options.rememberState) {
                this.saveState();
            }

            // Call onOpen callback if provided
            if (typeof this.options.onOpen === 'function') {
                this.options.onOpen();
            }

            // Publish event
            PubSub.publish(SidebarPanel.EVENTS.PANEL_OPEN, {
                id: this.options.id,
                panel: this
            });

            Logger.debug(`SidebarPanel opened: ${this.options.id}`);
        }

        /**
         * Close the panel
         */
        close() {
            if (this.state === SidebarPanel.PANEL_STATES.CLOSED) return;

            this.state = SidebarPanel.PANEL_STATES.CLOSED;

            // Update panel class
            this.container.classList.remove(`${this.baseClass}-container--opened`);

            // Handle push transition
            if (this.options.transition === SidebarPanel.PANEL_TRANSITIONS.PUSH) {
                document.body.classList.remove(`${this.baseClass}-push--opened`);
                // We keep the active class for transition
                setTimeout(() => {
                    if (this.state === SidebarPanel.PANEL_STATES.CLOSED) {
                        document.body.classList.remove(`${this.baseClass}-push-active--${this.options.position}`);
                    }
                }, 300); // Match transition duration
            }

            // Hide overlay
            if (this.overlay) {
                this.overlay.classList.remove(`${this.baseClass}-overlay--visible`);
            }

            // Save state
            if (this.options.rememberState) {
                this.saveState();
            }

            // Call onClose callback if provided
            if (typeof this.options.onClose === 'function') {
                this.options.onClose();
            }

            // Publish event
            PubSub.publish(SidebarPanel.EVENTS.PANEL_CLOSE, {
                id: this.options.id,
                panel: this
            });

            Logger.debug(`SidebarPanel closed: ${this.options.id}`);
        }

        /**
         * Get saved panel state from GM storage
         * @return {String|null} Panel state or null if not found
         */
        async getSavedState() {
            if (!this.options.rememberState) return null;

            try {
                // Use directly imported getValue
                const savedState = await getValue(this.storageKey, SidebarPanel.PANEL_STATES.CLOSED);
                // Validate state
                if (Object.values(SidebarPanel.PANEL_STATES).includes(savedState)) {
                    Logger.debug('Retrieved saved panel state:', savedState, 'for key:', this.storageKey);
                    return savedState;
                }
                Logger.warn('Invalid saved panel state retrieved:', savedState, 'for key:', this.storageKey);
            } catch (error) {
                Logger.error('Error retrieving saved panel state:', error, 'for key:', this.storageKey);
            }
            return SidebarPanel.PANEL_STATES.CLOSED; // Default to closed on error or invalid
        }

        /**
         * Save the current panel state (opened/closed) if rememberState is enabled.
         */
        async saveState() {
            if (!this.options.rememberState) return;

            try {
                // Use directly imported setValue
                await setValue(this.storageKey, this.state);
                Logger.debug('Saved panel state:', this.state, 'for key:', this.storageKey);
            } catch (error) {
                Logger.error('Error saving panel state:', error, 'for key:', this.storageKey);
            }
        }

        /**
         * Set panel content
         * @param {String|HTMLElement} content - HTML string or element to set as content
         */
        setContent(content) {
            if (!this.content) return;

            // Clear existing content
            while (this.content.firstChild) {
                this.content.removeChild(this.content.firstChild);
            }

            // Add new content
            if (typeof content === 'string') {
                // For string content, create a text node instead of using innerHTML
                this.content.textContent = content;
            } else if (content instanceof HTMLElement) {
                this.content.appendChild(content);
            }
        }

        /**
         * Set panel title
         * @param {String} title - New title text
         */
        setTitle(title) {
            const titleElement = this.header ? this.header.querySelector(`.${this.baseClass}-title`) : null;
            if (titleElement) {
                titleElement.textContent = title;
                this.options.title = title;
            }
        }

        /**
         * Set button icon
         * @param {String} iconHtml - Text content for icon (no HTML allowed for CSP compliance)
         */
        setButtonIcon(iconHtml) {
            if (this.button) {
                this.button.textContent = iconHtml;
                this.options.buttonIcon = iconHtml;
            }
        }

        /**
         * Destroy the panel and clean up
         */
        destroy() {
            // Remove DOM elements
            if (this.container && this.container.parentNode) {
                this.container.parentNode.removeChild(this.container);
            }

            if (this.button && this.button.parentNode) {
                this.button.parentNode.removeChild(this.button);
            }

            if (this.overlay && this.overlay.parentNode) {
                this.overlay.parentNode.removeChild(this.overlay);
            }

            // Remove body classes
            document.body.classList.remove(`${this.baseClass}-push-active--${this.options.position}`);
            document.body.classList.remove(`${this.baseClass}-push--opened`);

            // Unsubscribe from PubSub events
            if (this.subscriptions) {
                this.subscriptions.forEach(subscriptionId => {
                    PubSub.unsubscribe(subscriptionId);
                });
            }

            Logger.debug(`SidebarPanel destroyed: ${this.options.id}`);
        }
    }

    /**
     * Input - A reusable input field component with theming and validation
     * Provides consistent styling and behavior across userscripts
     */

    class Input {
        static BASE_INPUT_CLASS = 'userscript-input';
        static THEMES = {
            default: 'default',
            primary: 'primary',
            success: 'success',
            warning: 'warning',
            danger: 'danger'
        };
        static SIZES = {
            small: 'small',
            medium: 'medium',
            large: 'large'
        };

        /**
         * Initialize default styles for Input components
         */
        static initStyles() {
            if (StyleManager.hasStyles('input-component')) {
                return;
            }

            const styles = `
            .${Input.BASE_INPUT_CLASS} {
                position: relative;
                display: inline-block;
                width: 100%;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }

            .${Input.BASE_INPUT_CLASS}-field {
                width: 100%;
                padding: 8px 12px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                font-size: 14px;
                box-sizing: border-box;
                transition: all 0.2s ease;
                background: #fff;
                color: #222;
                outline: none;
            }

            .${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #4285f4;
                box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
            }

            .${Input.BASE_INPUT_CLASS}-field:disabled {
                background: #f0f0f0;
                color: #888;
                cursor: not-allowed;
            }

            .${Input.BASE_INPUT_CLASS}-field::placeholder {
                color: #222;
                opacity: 0.7;
            }

            /* Themes */
            .${Input.BASE_INPUT_CLASS}--primary .${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #4285f4;
                box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
            }

            .${Input.BASE_INPUT_CLASS}--success .${Input.BASE_INPUT_CLASS}-field {
                border-color: #28a745;
            }

            .${Input.BASE_INPUT_CLASS}--success .${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #28a745;
                box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2);
            }

            .${Input.BASE_INPUT_CLASS}--warning .${Input.BASE_INPUT_CLASS}-field {
                border-color: #ffc107;
            }

            .${Input.BASE_INPUT_CLASS}--warning .${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #ffc107;
                box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.2);
            }

            .${Input.BASE_INPUT_CLASS}--danger .${Input.BASE_INPUT_CLASS}-field {
                border-color: #dc3545;
            }

            .${Input.BASE_INPUT_CLASS}--danger .${Input.BASE_INPUT_CLASS}-field:focus {
                border-color: #dc3545;
                box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.2);
            }

            /* Sizes */
            .${Input.BASE_INPUT_CLASS}--small .${Input.BASE_INPUT_CLASS}-field {
                padding: 6px 10px;
                font-size: 12px;
            }

            .${Input.BASE_INPUT_CLASS}--large .${Input.BASE_INPUT_CLASS}-field {
                padding: 12px 16px;
                font-size: 16px;
            }

            /* Label */
            .${Input.BASE_INPUT_CLASS}-label {
                display: block;
                margin-bottom: 4px;
                font-size: 13px;
                font-weight: 500;
                color: #333;
            }

            /* Error message */
            .${Input.BASE_INPUT_CLASS}-error {
                display: block;
                margin-top: 4px;
                font-size: 12px;
                color: #dc3545;
            }

            /* Helper text */
            .${Input.BASE_INPUT_CLASS}-helper {
                display: block;
                margin-top: 4px;
                font-size: 12px;
                color: #666;
            }
        `;

            StyleManager.addStyles(styles, 'input-component');
        }

        /**
         * Use default color scheme
         */
        static useDefaultColors() {
            // Colors are already defined in initStyles
            // This method exists for API consistency with other components
        }

        /**
         * Create a new Input instance
         * @param {Object} options - Configuration options
         * @param {string} [options.type='text'] - Input type (text, number, email, password, etc.)
         * @param {string} [options.value=''] - Initial value
         * @param {string} [options.placeholder=''] - Placeholder text
         * @param {string} [options.label=''] - Label text
         * @param {string} [options.helperText=''] - Helper text
         * @param {string} [options.theme='default'] - Theme (default, primary, success, warning, danger)
         * @param {string} [options.size='medium'] - Size (small, medium, large)
         * @param {boolean} [options.disabled=false] - Whether input is disabled
         * @param {boolean} [options.required=false] - Whether input is required
         * @param {string} [options.min] - Minimum value (for number inputs)
         * @param {string} [options.max] - Maximum value (for number inputs)
         * @param {string} [options.step] - Step value (for number inputs)
         * @param {Function} [options.onInput] - Input event handler
         * @param {Function} [options.onChange] - Change event handler
         * @param {Function} [options.onFocus] - Focus event handler
         * @param {Function} [options.onBlur] - Blur event handler
         * @param {Function} [options.validator] - Custom validation function
         * @param {HTMLElement} [options.container] - Container to append to
         * @param {string} [options.className] - Additional CSS class
         */
        constructor(options = {}) {
            this.options = {
                type: 'text',
                value: '',
                placeholder: '',
                label: '',
                helperText: '',
                theme: Input.THEMES.default,
                size: Input.SIZES.medium,
                disabled: false,
                required: false,
                onInput: null,
                onChange: null,
                onFocus: null,
                onBlur: null,
                validator: null,
                container: null,
                className: '',
                ...options
            };

            this.isValid = true;
            this.errorMessage = '';

            this.createElement();
            this.setupEventListeners();

            if (this.options.container) {
                this.options.container.appendChild(this.element);
            }
        }

        /**
         * Create the input element structure
         */
        createElement() {
            // Main container
            this.element = document.createElement('div');
            this.element.className = this.buildClassName();

            // Label
            if (this.options.label) {
                this.labelElement = document.createElement('label');
                this.labelElement.className = `${Input.BASE_INPUT_CLASS}-label`;
                this.labelElement.textContent = this.options.label;
                if (this.options.required) {
                    this.labelElement.textContent += ' *';
                }
                this.element.appendChild(this.labelElement);
            }

            // Input field
            this.inputElement = document.createElement('input');
            this.inputElement.type = this.options.type;
            this.inputElement.className = `${Input.BASE_INPUT_CLASS}-field`;
            this.inputElement.value = this.options.value;
            this.inputElement.placeholder = this.options.placeholder;
            this.inputElement.disabled = this.options.disabled;
            this.inputElement.required = this.options.required;

            // Set number-specific attributes
            if (this.options.type === 'number') {
                if (this.options.min !== undefined) {
                    this.inputElement.min = this.options.min;
                }
                if (this.options.max !== undefined) {
                    this.inputElement.max = this.options.max;
                }
                if (this.options.step !== undefined) {
                    this.inputElement.step = this.options.step;
                }
            }

            this.element.appendChild(this.inputElement);

            // Helper text
            if (this.options.helperText) {
                this.helperElement = document.createElement('span');
                this.helperElement.className = `${Input.BASE_INPUT_CLASS}-helper`;
                this.helperElement.textContent = this.options.helperText;
                this.element.appendChild(this.helperElement);
            }

            // Error message container (initially hidden)
            this.errorElement = document.createElement('span');
            this.errorElement.className = `${Input.BASE_INPUT_CLASS}-error`;
            this.errorElement.style.display = 'none';
            this.element.appendChild(this.errorElement);
        }

        /**
         * Setup event listeners
         */
        setupEventListeners() {
            if (this.options.onInput) {
                this.inputElement.addEventListener('input', (e) => {
                    this.validate();
                    this.options.onInput(e, this);
                });
            } else {
                this.inputElement.addEventListener('input', () => {
                    this.validate();
                });
            }

            if (this.options.onChange) {
                this.inputElement.addEventListener('change', (e) => {
                    this.validate();
                    this.options.onChange(e, this);
                });
            }

            if (this.options.onFocus) {
                this.inputElement.addEventListener('focus', (e) => {
                    this.options.onFocus(e, this);
                });
            }

            if (this.options.onBlur) {
                this.inputElement.addEventListener('blur', (e) => {
                    this.validate();
                    this.options.onBlur(e, this);
                });
            }
        }

        /**
         * Build CSS class name
         */
        buildClassName() {
            const classes = [Input.BASE_INPUT_CLASS];
            
            if (this.options.theme && this.options.theme !== Input.THEMES.default) {
                classes.push(`${Input.BASE_INPUT_CLASS}--${this.options.theme}`);
            }
            
            if (this.options.size && this.options.size !== Input.SIZES.medium) {
                classes.push(`${Input.BASE_INPUT_CLASS}--${this.options.size}`);
            }
            
            if (this.options.className) {
                classes.push(this.options.className);
            }
            
            return classes.join(' ');
        }

        /**
         * Validate input value
         */
        validate() {
            this.isValid = true;
            this.errorMessage = '';

            // Required validation
            if (this.options.required && !this.inputElement.value.trim()) {
                this.isValid = false;
                this.errorMessage = 'This field is required';
            }

            // Custom validation
            if (this.isValid && this.options.validator) {
                const validationResult = this.options.validator(this.inputElement.value, this);
                if (validationResult !== true) {
                    this.isValid = false;
                    this.errorMessage = validationResult || 'Invalid value';
                }
            }

            // Update error display
            this.updateErrorDisplay();
            return this.isValid;
        }

        /**
         * Update error message display
         */
        updateErrorDisplay() {
            if (!this.isValid && this.errorMessage) {
                this.errorElement.textContent = this.errorMessage;
                this.errorElement.style.display = 'block';
                this.setTheme(Input.THEMES.danger);
            } else {
                this.errorElement.style.display = 'none';
                this.setTheme(this.options.theme);
            }
        }

        /**
         * Get current value
         */
        getValue() {
            return this.inputElement.value;
        }

        /**
         * Set value
         */
        setValue(value) {
            this.inputElement.value = value;
            this.validate();
        }

        /**
         * Set theme
         */
        setTheme(theme) {
            // Remove existing theme classes
            Object.values(Input.THEMES).forEach(t => {
                if (t !== Input.THEMES.default) {
                    this.element.classList.remove(`${Input.BASE_INPUT_CLASS}--${t}`);
                }
            });

            // Add new theme class
            if (theme && theme !== Input.THEMES.default) {
                this.element.classList.add(`${Input.BASE_INPUT_CLASS}--${theme}`);
            }
        }

        /**
         * Set disabled state
         */
        setDisabled(disabled) {
            this.options.disabled = disabled;
            this.inputElement.disabled = disabled;
        }

        /**
         * Focus the input
         */
        focus() {
            this.inputElement.focus();
        }

        /**
         * Blur the input
         */
        blur() {
            this.inputElement.blur();
        }

        /**
         * Get the DOM element
         */
        getElement() {
            return this.element;
        }

        /**
         * Destroy the input and clean up
         */
        destroy() {
            if (this.element && this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
        }
    }

    /**
     * TextArea - A reusable textarea component with theming and validation
     * Provides consistent styling and behavior across userscripts
     */

    class TextArea {
        static BASE_TEXTAREA_CLASS = 'userscript-textarea';
        static THEMES = {
            default: 'default',
            primary: 'primary',
            success: 'success',
            warning: 'warning',
            danger: 'danger'
        };
        static SIZES = {
            small: 'small',
            medium: 'medium',
            large: 'large'
        };

        /**
         * Initialize default styles for TextArea components
         */
        static initStyles() {
            if (StyleManager.hasStyles('textarea-component')) {
                return;
            }

            const styles = `
            .${TextArea.BASE_TEXTAREA_CLASS} {
                position: relative;
                display: inline-block;
                width: 100%;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }

            .${TextArea.BASE_TEXTAREA_CLASS}-field {
                width: 100%;
                padding: 8px 12px;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                font-size: 14px;
                box-sizing: border-box;
                transition: all 0.2s ease;
                background: #fff;
                color: #222;
                outline: none;
                resize: vertical;
                font-family: inherit;
                line-height: 1.4;
                min-height: 80px;
            }

            .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #4285f4;
                box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
            }

            .${TextArea.BASE_TEXTAREA_CLASS}-field:disabled {
                background: #f0f0f0;
                color: #888;
                cursor: not-allowed;
                resize: none;
            }

            .${TextArea.BASE_TEXTAREA_CLASS}-field::placeholder {
                color: #222;
                opacity: 0.7;
            }

            /* Themes */
            .${TextArea.BASE_TEXTAREA_CLASS}--primary .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #4285f4;
                box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2);
            }

            .${TextArea.BASE_TEXTAREA_CLASS}--success .${TextArea.BASE_TEXTAREA_CLASS}-field {
                border-color: #28a745;
            }

            .${TextArea.BASE_TEXTAREA_CLASS}--success .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #28a745;
                box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2);
            }

            .${TextArea.BASE_TEXTAREA_CLASS}--warning .${TextArea.BASE_TEXTAREA_CLASS}-field {
                border-color: #ffc107;
            }

            .${TextArea.BASE_TEXTAREA_CLASS}--warning .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #ffc107;
                box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.2);
            }

            .${TextArea.BASE_TEXTAREA_CLASS}--danger .${TextArea.BASE_TEXTAREA_CLASS}-field {
                border-color: #dc3545;
            }

            .${TextArea.BASE_TEXTAREA_CLASS}--danger .${TextArea.BASE_TEXTAREA_CLASS}-field:focus {
                border-color: #dc3545;
                box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.2);
            }

            /* Sizes */
            .${TextArea.BASE_TEXTAREA_CLASS}--small .${TextArea.BASE_TEXTAREA_CLASS}-field {
                padding: 6px 10px;
                font-size: 12px;
                min-height: 60px;
            }

            .${TextArea.BASE_TEXTAREA_CLASS}--large .${TextArea.BASE_TEXTAREA_CLASS}-field {
                padding: 12px 16px;
                font-size: 16px;
                min-height: 120px;
            }

            /* Label */
            .${TextArea.BASE_TEXTAREA_CLASS}-label {
                display: block;
                margin-bottom: 4px;
                font-size: 13px;
                font-weight: 500;
                color: #333;
            }

            /* Error message */
            .${TextArea.BASE_TEXTAREA_CLASS}-error {
                display: block;
                margin-top: 4px;
                font-size: 12px;
                color: #dc3545;
            }

            /* Helper text */
            .${TextArea.BASE_TEXTAREA_CLASS}-helper {
                display: block;
                margin-top: 4px;
                font-size: 12px;
                color: #666;
            }

            /* Character counter */
            .${TextArea.BASE_TEXTAREA_CLASS}-counter {
                display: block;
                margin-top: 4px;
                font-size: 11px;
                color: #999;
                text-align: right;
            }

            .${TextArea.BASE_TEXTAREA_CLASS}-counter--limit-reached {
                color: #dc3545;
            }
        `;

            StyleManager.addStyles(styles, 'textarea-component');
        }

        /**
         * Use default color scheme
         */
        static useDefaultColors() {
            // Colors are already defined in initStyles
            // This method exists for API consistency with other components
        }

        /**
         * Create a new TextArea instance
         * @param {Object} options - Configuration options
         * @param {string} [options.value=''] - Initial value
         * @param {string} [options.placeholder=''] - Placeholder text
         * @param {string} [options.label=''] - Label text
         * @param {string} [options.helperText=''] - Helper text
         * @param {string} [options.theme='default'] - Theme (default, primary, success, warning, danger)
         * @param {string} [options.size='medium'] - Size (small, medium, large)
         * @param {boolean} [options.disabled=false] - Whether textarea is disabled
         * @param {boolean} [options.required=false] - Whether textarea is required
         * @param {number} [options.rows] - Number of rows
         * @param {number} [options.cols] - Number of columns
         * @param {number} [options.maxLength] - Maximum character length
         * @param {boolean} [options.showCounter=false] - Show character counter
         * @param {boolean} [options.autoResize=false] - Auto-resize to content
         * @param {Function} [options.onInput] - Input event handler
         * @param {Function} [options.onChange] - Change event handler
         * @param {Function} [options.onFocus] - Focus event handler
         * @param {Function} [options.onBlur] - Blur event handler
         * @param {Function} [options.validator] - Custom validation function
         * @param {HTMLElement} [options.container] - Container to append to
         * @param {string} [options.className] - Additional CSS class
         */
        constructor(options = {}) {
            this.options = {
                value: '',
                placeholder: '',
                label: '',
                helperText: '',
                theme: TextArea.THEMES.default,
                size: TextArea.SIZES.medium,
                disabled: false,
                required: false,
                rows: null,
                cols: null,
                maxLength: null,
                showCounter: false,
                autoResize: false,
                onInput: null,
                onChange: null,
                onFocus: null,
                onBlur: null,
                validator: null,
                container: null,
                className: '',
                ...options
            };

            this.isValid = true;
            this.errorMessage = '';

            this.createElement();
            this.setupEventListeners();

            if (this.options.container) {
                this.options.container.appendChild(this.element);
            }
        }

        /**
         * Create the textarea element structure
         */
        createElement() {
            // Main container
            this.element = document.createElement('div');
            this.element.className = this.buildClassName();

            // Label
            if (this.options.label) {
                this.labelElement = document.createElement('label');
                this.labelElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-label`;
                this.labelElement.textContent = this.options.label;
                if (this.options.required) {
                    this.labelElement.textContent += ' *';
                }
                this.element.appendChild(this.labelElement);
            }

            // TextArea field
            this.textareaElement = document.createElement('textarea');
            this.textareaElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-field`;
            this.textareaElement.value = this.options.value;
            this.textareaElement.placeholder = this.options.placeholder;
            this.textareaElement.disabled = this.options.disabled;
            this.textareaElement.required = this.options.required;

            // Set rows and cols if specified
            if (this.options.rows) {
                this.textareaElement.rows = this.options.rows;
            }
            if (this.options.cols) {
                this.textareaElement.cols = this.options.cols;
            }
            if (this.options.maxLength) {
                this.textareaElement.maxLength = this.options.maxLength;
            }

            this.element.appendChild(this.textareaElement);

            // Helper text
            if (this.options.helperText) {
                this.helperElement = document.createElement('span');
                this.helperElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-helper`;
                this.helperElement.textContent = this.options.helperText;
                this.element.appendChild(this.helperElement);
            }

            // Character counter
            if (this.options.showCounter || this.options.maxLength) {
                this.counterElement = document.createElement('span');
                this.counterElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-counter`;
                this.updateCounter();
                this.element.appendChild(this.counterElement);
            }

            // Error message container (initially hidden)
            this.errorElement = document.createElement('span');
            this.errorElement.className = `${TextArea.BASE_TEXTAREA_CLASS}-error`;
            this.errorElement.style.display = 'none';
            this.element.appendChild(this.errorElement);
        }

        /**
         * Setup event listeners
         */
        setupEventListeners() {
            if (this.options.onInput) {
                this.textareaElement.addEventListener('input', (e) => {
                    this.handleInput();
                    this.options.onInput(e, this);
                });
            } else {
                this.textareaElement.addEventListener('input', () => {
                    this.handleInput();
                });
            }

            if (this.options.onChange) {
                this.textareaElement.addEventListener('change', (e) => {
                    this.validate();
                    this.options.onChange(e, this);
                });
            }

            if (this.options.onFocus) {
                this.textareaElement.addEventListener('focus', (e) => {
                    this.options.onFocus(e, this);
                });
            }

            if (this.options.onBlur) {
                this.textareaElement.addEventListener('blur', (e) => {
                    this.validate();
                    this.options.onBlur(e, this);
                });
            }

            // Auto-resize functionality
            if (this.options.autoResize) {
                this.textareaElement.addEventListener('input', () => {
                    this.autoResize();
                });
            }
        }

        /**
         * Handle input events
         */
        handleInput() {
            this.updateCounter();
            this.validate();
            
            if (this.options.autoResize) {
                this.autoResize();
            }
        }

        /**
         * Auto-resize textarea to content
         */
        autoResize() {
            this.textareaElement.style.height = 'auto';
            this.textareaElement.style.height = this.textareaElement.scrollHeight + 'px';
        }

        /**
         * Update character counter
         */
        updateCounter() {
            if (!this.counterElement) return;

            const currentLength = this.textareaElement.value.length;
            let counterText = `${currentLength}`;

            if (this.options.maxLength) {
                counterText += ` / ${this.options.maxLength}`;
                
                // Update counter styling based on limit
                if (currentLength >= this.options.maxLength) {
                    this.counterElement.classList.add(`${TextArea.BASE_TEXTAREA_CLASS}-counter--limit-reached`);
                } else {
                    this.counterElement.classList.remove(`${TextArea.BASE_TEXTAREA_CLASS}-counter--limit-reached`);
                }
            }

            this.counterElement.textContent = counterText;
        }

        /**
         * Build CSS class name
         */
        buildClassName() {
            const classes = [TextArea.BASE_TEXTAREA_CLASS];
            
            if (this.options.theme && this.options.theme !== TextArea.THEMES.default) {
                classes.push(`${TextArea.BASE_TEXTAREA_CLASS}--${this.options.theme}`);
            }
            
            if (this.options.size && this.options.size !== TextArea.SIZES.medium) {
                classes.push(`${TextArea.BASE_TEXTAREA_CLASS}--${this.options.size}`);
            }
            
            if (this.options.className) {
                classes.push(this.options.className);
            }
            
            return classes.join(' ');
        }

        /**
         * Validate textarea value
         */
        validate() {
            this.isValid = true;
            this.errorMessage = '';

            // Required validation
            if (this.options.required && !this.textareaElement.value.trim()) {
                this.isValid = false;
                this.errorMessage = 'This field is required';
            }

            // Max length validation
            if (this.isValid && this.options.maxLength && this.textareaElement.value.length > this.options.maxLength) {
                this.isValid = false;
                this.errorMessage = `Text must not exceed ${this.options.maxLength} characters`;
            }

            // Custom validation
            if (this.isValid && this.options.validator) {
                const validationResult = this.options.validator(this.textareaElement.value, this);
                if (validationResult !== true) {
                    this.isValid = false;
                    this.errorMessage = validationResult || 'Invalid value';
                }
            }

            // Update error display
            this.updateErrorDisplay();
            return this.isValid;
        }

        /**
         * Update error message display
         */
        updateErrorDisplay() {
            if (!this.isValid && this.errorMessage) {
                this.errorElement.textContent = this.errorMessage;
                this.errorElement.style.display = 'block';
                this.setTheme(TextArea.THEMES.danger);
            } else {
                this.errorElement.style.display = 'none';
                this.setTheme(this.options.theme);
            }
        }

        /**
         * Get current value
         */
        getValue() {
            return this.textareaElement.value;
        }

        /**
         * Set value
         */
        setValue(value) {
            this.textareaElement.value = value;
            this.updateCounter();
            this.validate();
            
            if (this.options.autoResize) {
                this.autoResize();
            }
        }

        /**
         * Set theme
         */
        setTheme(theme) {
            // Remove existing theme classes
            Object.values(TextArea.THEMES).forEach(t => {
                if (t !== TextArea.THEMES.default) {
                    this.element.classList.remove(`${TextArea.BASE_TEXTAREA_CLASS}--${t}`);
                }
            });

            // Add new theme class
            if (theme && theme !== TextArea.THEMES.default) {
                this.element.classList.add(`${TextArea.BASE_TEXTAREA_CLASS}--${theme}`);
            }
        }

        /**
         * Set disabled state
         */
        setDisabled(disabled) {
            this.options.disabled = disabled;
            this.textareaElement.disabled = disabled;
        }

        /**
         * Focus the textarea
         */
        focus() {
            this.textareaElement.focus();
        }

        /**
         * Blur the textarea
         */
        blur() {
            this.textareaElement.blur();
        }

        /**
         * Get the DOM element
         */
        getElement() {
            return this.element;
        }

        /**
         * Destroy the textarea and clean up
         */
        destroy() {
            if (this.element && this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
        }
    }

    // Import core components

    // Configure logger
    Logger.setPrefix("Google AI Studio Enhancer");
    Logger.DEBUG = true;

    /**
     * Google AI Studio Enhancer
     * Provides response copying and auto-run functionality for Google AI Studio
     * Uses DOM methods to bypass Trusted Types policy
     */
    class AIStudioEnhancer {
        // Configuration
        static SELECTORS = {
            // Common selectors for AI responses
            RESPONSE_CONTAINERS: [
                // Google AI Studio specific (most accurate)
                '.chat-turn-container.model.render',
                '.chat-turn-container.model',
                // General selectors
                '[data-test-id="response-text"]',
                '.model-response',
                '.response-content',
                '[role="text"]',
                '.markdown-content',
                'div[data-message-author-role="model"]',
                'div[data-message-role="model"]',
                '[data-message-author-role="assistant"]',
                // More specific selectors for Google AI Studio
                '[data-testid="conversation-turn-content"]',
                '.conversation-turn-content',
                '[data-testid="model-response"]'
            ],
            // Common selectors for run buttons
            RUN_BUTTONS: [
                // Google AI Studio specific (most accurate)
                'button.run-button[aria-label="Run"]:not(.disabled):not([disabled])',
                'button.run-button[aria-label="Run"]',
                '.run-button:not(.disabled):not([disabled])',
                // General selectors
                'button[aria-label*="Run"]',
                'button[title*="Run"]',
                '[data-test-id="run-button"]',
                '.run-button',
                'button[data-testid*="run"]',
                'button[aria-label*="Send"]',
                'button[title*="Send"]',
                'button[data-testid*="send"]',
                // More specific for Google AI Studio
                'button[data-testid="send-button"]',
                'button[aria-label*="send message"]'
            ],
            // Common selectors for prompt input
            PROMPT_INPUTS: [
                // Google AI Studio specific (most accurate)
                'textarea.textarea.gmat-body-medium[placeholder*="Start typing a prompt"]',
                'textarea.textarea.gmat-body-medium',
                'textarea[aria-label*="Start typing a prompt"]',
                // General selectors
                'textarea[placeholder*="Enter a prompt"]',
                'textarea[placeholder*="Type a message"]',
                'textarea[placeholder*="Ask"]',
                'textarea[aria-label*="prompt"]',
                'textarea[aria-label*="message"]',
                'div[contenteditable="true"]',
                'textarea[data-testid*="prompt"]',
                'textarea[data-testid*="input"]',
                // More specific for Google AI Studio
                'textarea.input-field',
                'textarea[placeholder*="Enter your prompt"]',
                '.prompt-textarea textarea',
                '[data-testid="prompt-textarea"]'
            ],
            // Loading indicators
            LOADING_INDICATORS: [
                // Google AI Studio specific (most accurate)
                'button.run-button.stoppable',
                '.stoppable-spinner',
                'button.run-button[type="button"]',
                // General selectors
                '.loading',
                '.spinner',
                '[data-test-id="loading"]',
                '.generating',
                '.thinking',
                '[aria-label*="loading"]',
                '[aria-label*="thinking"]',
                // Google AI Studio specific
                '[data-testid="loading"]',
                '.mdc-linear-progress'
            ]
        };

        static SETTINGS_KEYS = {
            DEFAULT_ITERATIONS: 'gaise-default-iterations',
            AUTO_RUN_DELAY: 'gaise-auto-run-delay',
            SHOW_NOTIFICATIONS: 'gaise-show-notifications',
            PANEL_POSITION: 'gaise-panel-position',
            AUTO_RUN_PROMPT: 'gaise-auto-run-prompt'
        };

        static DEFAULT_SETTINGS = {
            DEFAULT_ITERATIONS: 10,
            AUTO_RUN_DELAY: 2000,
            SHOW_NOTIFICATIONS: true,
            PANEL_POSITION: { x: 20, y: 20 },
            AUTO_RUN_PROMPT: ''
        };

        // Event names for PubSub communication
        static EVENTS = {
            RESPONSE_ADDED: 'ai-studio:response-added',
            RESPONSES_COPIED: 'ai-studio:responses-copied',
            CHAT_CHANGED: 'ai-studio:chat-changed',
            AUTO_RUN_STARTED: 'ai-studio:auto-run-started',
            AUTO_RUN_STOPPED: 'ai-studio:auto-run-stopped',
            AUTO_RUN_ITERATION: 'ai-studio:auto-run-iteration',
            SETTINGS_CHANGED: 'ai-studio:settings-changed',
            UI_UPDATE_REQUIRED: 'ai-studio:ui-update-required'
        };

        /**
         * Initialize the enhancer
         */
        constructor() {
            this.responses = [];
            this.isAutoRunning = false;
            this.currentIteration = 0;
            this.maxIterations = 0;
            this.responseObserver = null;
            this.chatObserver = null;
            this.settings = { ...AIStudioEnhancer.DEFAULT_SETTINGS };
            this.sidebarPanel = null;
            this.currentChatId = null;
            this.copyButton = null;
            this.toggleButton = null;
            this.isInitialLoad = true;
            
            // Store subscription IDs for cleanup
            this.subscriptionIds = [];
            
            // Initialize cache for persistent response storage
            this.responseCache = new DataCache(Logger);
            
            // Initialize user interaction detector for distinguishing real vs programmatic events
            this.userInteraction = UserInteractionDetector.getInstance({
                debug: Logger.DEBUG,
                namespace: 'ai-studio-enhancer',
                interactionWindow: 200, // 200ms window for related events
                interactionThrottle: 100 // 100ms throttle for performance
            });

            // Initialize ContentCollector for sophisticated response collection
            this.contentCollector = new ContentCollector({
                name: 'AI-Studio-Responses',
                selectors: AIStudioEnhancer.SELECTORS.RESPONSE_CONTAINERS,
                contentExtractor: this.extractResponseText.bind(this),
                contentCleaner: this.cleanResponseText.bind(this),
                contentValidator: (content, existing) => content && content.length > 10,
                deduplicate: true,
                enableNotifications: false, // We'll handle notifications ourselves
                enablePersistence: true,
                cacheKey: () => this.getChatCacheKey(),
                highlightCollected: false
            });

            // Initialize AutoRunner for sophisticated auto-run functionality
            this.autoRunner = null; // Will be created when needed

            // Initialize FormStatePersistence for automatic form state saving
            this.formPersistence = new FormStatePersistence({
                namespace: 'ai-studio-enhancer',
                getValue: getValue,
                setValue: setValue,
                enableNotifications: false,
                enableInteractionDetection: true,
                fields: {
                    autoRunPrompt: {
                        selector: '.auto-run-prompt-textarea textarea',
                        type: 'text',
                        defaultValue: ''
                    },
                    autoRunIterations: {
                        selector: '.auto-run-iterations-input input',
                        type: 'number',
                        defaultValue: 10,
                        validator: (value) => {
                            const num = parseInt(value, 10);
                            return !isNaN(num) && num >= 1 && num <= 100;
                        }
                    }
                }
            });

            Logger.info("Initializing Google AI Studio Enhancer");

            // Setup PubSub event handlers
            this.setupEventHandlers();

            // Initialize URL change watcher for chat monitoring
            this.urlWatcher = new UrlChangeWatcher([
                new PollingStrategy(this.handleUrlChange.bind(this), 1000)
            ], false); // false = don't fire immediately

            // Load saved settings
            this.loadSettings().then(() => {
                // Initialize components
                this.init();
            });
            
            // Setup cleanup on page unload
            window.addEventListener('beforeunload', () => {
                this.cleanup();
            });
        }

        /**
         * Setup PubSub event handlers for event-driven communication
         */
        setupEventHandlers() {
            // Handle response additions
            this.subscriptionIds.push(
                PubSub.subscribe(AIStudioEnhancer.EVENTS.RESPONSE_ADDED, (data) => {
                    this.handleResponseAdded(data);
                })
            );

            // Handle chat changes
            this.subscriptionIds.push(
                PubSub.subscribe(AIStudioEnhancer.EVENTS.CHAT_CHANGED, (data) => {
                    this.handleChatChangedEvent(data);
                })
            );

            // Handle UI updates
            this.subscriptionIds.push(
                PubSub.subscribe(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, (data) => {
                    this.handleUIUpdate(data);
                })
            );

            // Handle auto-run events
            this.subscriptionIds.push(
                PubSub.subscribe(AIStudioEnhancer.EVENTS.AUTO_RUN_STARTED, (data) => {
                    this.handleAutoRunStarted(data);
                })
            );

            this.subscriptionIds.push(
                PubSub.subscribe(AIStudioEnhancer.EVENTS.AUTO_RUN_STOPPED, (data) => {
                    this.handleAutoRunStopped(data);
                })
            );

            this.subscriptionIds.push(
                PubSub.subscribe(AIStudioEnhancer.EVENTS.AUTO_RUN_ITERATION, (data) => {
                    this.handleAutoRunIteration(data);
                })
            );

            Logger.debug("PubSub event handlers setup complete");
        }

        /**
         * Cleanup PubSub subscriptions and other resources
         */
        cleanup() {
            // Clean up PubSub subscriptions
            this.subscriptionIds.forEach(id => {
                PubSub.unsubscribe(id);
            });
            this.subscriptionIds = [];
            
            // Clean up UserInteractionDetector if it was created by this instance
            if (this.userInteraction) {
                // Note: We don't destroy the singleton instance since other scripts might be using it
                // Just reset our specific tracking if needed
                Logger.debug("UserInteractionDetector cleanup - instance preserved for other users");
            }
            
            // Clean up tracked run buttons
            document.querySelectorAll('[data-ai-studio-enhancer-tracked]').forEach(button => {
                if (button._aiStudioEnhancerCleanup) {
                    button._aiStudioEnhancerCleanup.forEach(unsubscribe => {
                        try {
                            unsubscribe();
                        } catch (error) {
                            Logger.warn('Error during run button cleanup:', error);
                        }
                    });
                    delete button._aiStudioEnhancerCleanup;
                    delete button._aiStudioEnhancerTracked;
                }
            });
            
            // Clean up stats update interval
            if (this.statsUpdateInterval) {
                clearInterval(this.statsUpdateInterval);
                this.statsUpdateInterval = null;
            }
            
            // Clean up form components
            if (this.promptTextArea) {
                this.promptTextArea.destroy();
                this.promptTextArea = null;
            }
            
            if (this.iterationsInput) {
                this.iterationsInput.destroy();
                this.iterationsInput = null;
            }

            // Clean up new core components
            if (this.contentCollector) {
                this.contentCollector.stopMonitoring();
                this.contentCollector = null;
            }

            if (this.autoRunner) {
                this.autoRunner.stop('cleanup');
                this.autoRunner = null;
            }

            if (this.formPersistence) {
                this.formPersistence.destroy();
                this.formPersistence = null;
            }
            
            Logger.debug("All subscriptions and resources cleaned up");
        }

        /**
         * Generate cache key for current chat
         */
        getChatCacheKey() {
            const chatId = this.currentChatId || 'default';
            return `ai-studio-responses-${chatId}`;
        }

        /**
         * Load responses from cache for current chat
         */
        loadResponsesFromCache() {
            const cacheKey = this.getChatCacheKey();
            const cachedResponses = this.responseCache.get(cacheKey);
            
            if (cachedResponses && Array.isArray(cachedResponses)) {
                this.responses = [...cachedResponses];
                Logger.debug(`Loaded ${this.responses.length} responses from cache for chat: ${this.currentChatId}`);
                
                // Update UI to reflect cached responses
                PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, { 
                    type: 'chat-changed',
                    chatId: this.currentChatId 
                });
                
                return true;
            }
            
            Logger.debug(`No cached responses found for chat: ${this.currentChatId}`);
            return false;
        }

        /**
         * Save responses to cache for current chat
         */
        saveResponsesToCache() {
            const cacheKey = this.getChatCacheKey();
            
            // Save responses with 7 days expiration
            this.responseCache.set(cacheKey, this.responses, 7);
            
            Logger.debug(`Saved ${this.responses.length} responses to cache for chat: ${this.currentChatId}`);
        }

        /**
         * Clear cache for current chat
         */
        clearChatCache() {
            const cacheKey = this.getChatCacheKey();
            this.responseCache.set(cacheKey, [], 7); // Set empty array instead of removing
            Logger.debug(`Cleared cache for chat: ${this.currentChatId}`);
        }

        /**
         * Clear all cached responses
         */
        clearAllCache() {
            // This would require knowing all chat IDs, which is complex
            // For now, we'll just clear the current chat
            this.clearChatCache();
            Logger.info("Cache cleared for current chat");
        }

        /**
         * Clear current chat cache and update UI
         */
        clearCurrentChatCache() {
            this.clearChatCache();
            
            // Also clear current responses in memory and ContentCollector
            this.responses = [];
            if (this.contentCollector) {
                this.contentCollector.clearContent();
            }
            
            // Update UI
            PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, { 
                type: 'chat-changed',
                chatId: this.currentChatId 
            });
            
            this.showNotification('Cache cleared for current chat', 'success');
            Logger.info("Current chat cache cleared via UI");
        }

        /**
         * Update interaction statistics display
         */
        updateInteractionStats() {
            if (!this.interactionStatsElement || !this.userInteraction) {
                return;
            }

            const stats = this.userInteraction.getStats();
            const timeSince = stats.timeSinceLastInteraction === Infinity ? 'Never' : `${Math.round(stats.timeSinceLastInteraction / 1000)}s ago`;

            const statsText = [
                `Currently Interacting: ${stats.isInteracting ? '✅ Yes' : '❌ No'}`,
                `Last Interaction: ${timeSince}`,
                `User Interactions: ${stats.userInteractionCount}`,
                `Programmatic Events: ${stats.programmaticEventCount}`,
                `Tracked Elements: ${stats.trackedElements}`,
                `Recent Events: ${stats.recentEvents}`
            ].join('\n');

            this.interactionStatsElement.textContent = statsText;
        }

        /**
         * Handle copy button click with user interaction detection
         */
        handleCopyButtonClick(event) {
            const isUserInitiated = this.userInteraction.isUserEvent(event);
            
            Logger.debug('Copy button clicked', {
                isUserInitiated,
                eventType: event?.type,
                isTrusted: event?.isTrusted,
                isInteracting: this.userInteraction.isInteracting(),
                timeSinceLastInteraction: this.userInteraction.getTimeSinceLastInteraction()
            });

            if (isUserInitiated) {
                // Real user click - show notification and copy
                this.copyAllResponsesManual();
                
                // Publish event for analytics/logging
                PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, {
                    type: 'user-action',
                    action: 'copy-responses',
                    userInitiated: true
                });
            } else {
                // Programmatic click - copy silently without notification
                Logger.info('Programmatic copy button click detected - copying silently');
                this.copyAllResponsesSilent();
                
                // Publish event for analytics/logging
                PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, {
                    type: 'programmatic-action',
                    action: 'copy-responses',
                    userInitiated: false
                });
            }
        }

        /**
         * Handle toggle button click with user interaction detection
         */
        handleToggleButtonClick(event) {
            const isUserInitiated = this.userInteraction.isUserEvent(event);
            
            Logger.warn('Toggle button clicked! Current auto-run state:', this.isAutoRunning, {
                isUserInitiated,
                eventType: event?.type,
                isTrusted: event?.isTrusted,
                isInteracting: this.userInteraction.isInteracting(),
                timeSinceLastInteraction: this.userInteraction.getTimeSinceLastInteraction(),
                stackTrace: new Error().stack
            });

            if (isUserInitiated) {
                // Real user click - proceed with normal toggle behavior
                Logger.warn('User-initiated toggle detected');
                this.toggleAutoRun();
                
                // Publish event for analytics/logging
                PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, {
                    type: 'user-action',
                    action: 'toggle-auto-run',
                    userInitiated: true,
                    newState: this.isAutoRunning
                });
            } else {
                // Programmatic click - log but potentially ignore or handle differently
                Logger.warn('Programmatic toggle button click detected - IGNORING to prevent unwanted stops');
                
                // DON'T call toggleAutoRun for programmatic clicks
                // this.toggleAutoRun();
                
                // Publish event for analytics/logging
                PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, {
                    type: 'programmatic-action',
                    action: 'toggle-auto-run-ignored',
                    userInitiated: false,
                    currentState: this.isAutoRunning
                });
            }
        }

        /**
         * Handle clear cache button click with user interaction detection
         */
        handleClearCacheClick(event) {
            const isUserInitiated = this.userInteraction.isUserEvent(event);
            
            Logger.debug('Clear cache button clicked', {
                isUserInitiated,
                eventType: event?.type,
                isTrusted: event?.isTrusted,
                isInteracting: this.userInteraction.isInteracting(),
                timeSinceLastInteraction: this.userInteraction.getTimeSinceLastInteraction()
            });

            if (isUserInitiated) {
                // Real user click - proceed with cache clearing
                this.clearCurrentChatCache();
                
                // Publish event for analytics/logging
                PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, {
                    type: 'user-action',
                    action: 'clear-cache',
                    userInitiated: true
                });
            } else {
                // Programmatic click - be more cautious with destructive actions
                Logger.warn('Programmatic clear cache click detected - requiring user confirmation');
                
                // For destructive actions, we might want to require real user interaction
                // For now, we'll allow it but with extra logging
                this.clearCurrentChatCache();
                
                // Publish event for analytics/logging
                PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, {
                    type: 'programmatic-action',
                    action: 'clear-cache',
                    userInitiated: false
                });
            }
        }

        /**
         * Handle response addition events
         */
        handleResponseAdded(data) {
            // Update UI counter
            this.updateResponseCount();
            
            // Save to cache
            this.saveResponsesToCache();
            
            Logger.debug(`Response added event handled - Total: ${data.total}, Initial Load: ${data.isInitialLoad}`);
        }

        /**
         * Handle chat change events
         */
        handleChatChangedEvent(data) {
            Logger.info(`Chat changed event: ${data.oldChatId} → ${data.newChatId}`);
            
            // Try to load responses from cache for the new chat first
            const loadedFromCache = this.loadResponsesFromCache();
            
            if (!loadedFromCache) {
                // Clear responses if no cache found
                this.responses = [];
                
                // Publish UI update event
                PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, { 
                    type: 'chat-changed',
                    chatId: data.newChatId 
                });
            }
            
            // Set initial load mode for the new chat
            this.isInitialLoad = true;
            
            // Collect responses from the new chat after a short delay
            setTimeout(() => {
                this.collectExistingResponses();
                setTimeout(() => {
                    this.isInitialLoad = false;
                    Logger.debug("New chat initial load completed");
                }, 1000);
            }, 1000);
            
            if (loadedFromCache) {
                this.showNotification(`Switched to chat - loaded ${this.responses.length} cached responses`, 'info');
            } else {
                this.showNotification('Switched to new chat - responses cleared', 'info');
            }
        }

        /**
         * Handle UI update events
         */
        handleUIUpdate(data) {
            switch (data.type) {
                case 'chat-changed':
                    this.updateResponseCount();
                    break;
                case 'auto-run-status':
                    this.updateAutoRunStatus();
                    break;
                case 'button-state':
                    this.updateButtonState();
                    break;
                default:
                    Logger.debug('Unknown UI update type:', data.type);
            }
        }

        /**
         * Handle auto-run started events
         */
        handleAutoRunStarted(data) {
            Logger.info(`Auto-run started event: ${data.iterations} iterations`);
            this.showNotification(`Starting auto runner for ${data.iterations} iterations`, 'info');
            
            // Update UI
            PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, { 
                type: 'button-state' 
            });
            PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, { 
                type: 'auto-run-status' 
            });
        }

        /**
         * Handle auto-run stopped events
         */
        handleAutoRunStopped(data) {
            Logger.info(`Auto-run stopped event: ${data.reason || 'user requested'}`);
            this.showNotification(`Auto runner stopped and reset`, 'info');
            
            // Update UI
            PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, { 
                type: 'button-state' 
            });
            PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, { 
                type: 'auto-run-status' 
            });
        }

        /**
         * Handle auto-run iteration events
         */
        handleAutoRunIteration(data) {
            Logger.info(`Auto-run iteration event: ${data.current}/${data.total}`);
            
            // Update UI
            PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, { 
                type: 'auto-run-status' 
            });
        }

        /**
         * Load saved settings from GM storage
         */
        async loadSettings() {
            try {
                for (const [settingName, storageKey] of Object.entries(AIStudioEnhancer.SETTINGS_KEYS)) {
                    const savedValue = await getValue(storageKey, null);
                    if (savedValue !== null) {
                        this.settings[settingName] = savedValue;
                    }
                }
                Logger.debug("Settings loaded", this.settings);
            } catch (error) {
                Logger.error("Error loading settings:", error);
            }
        }

        /**
         * Save settings to GM storage
         */
        async saveSettings() {
            try {
                for (const [settingName, storageKey] of Object.entries(AIStudioEnhancer.SETTINGS_KEYS)) {
                    await setValue(storageKey, this.settings[settingName]);
                }
                Logger.debug("Settings saved", this.settings);
            } catch (error) {
                Logger.error("Error saving settings:", error);
            }
        }

        /**
         * Initialize the enhancer
         */
        async init() {
            // Wait for page to be ready
            await this.waitForPageReady();

            // Initialize styles
            SidebarPanel.initStyles();
            Button.initStyles();
            Button.useDefaultColors();
            Notification.initStyles();
            Notification.useDefaultColors();
            Input.initStyles();
            TextArea.initStyles();
            
            // Add custom styles for full-width buttons and form inputs
            StyleManager.addStyles(`
            .copy-responses-button,
            .auto-run-toggle-button {
                width: 100% !important;
            }
            
            .auto-run-prompt-textarea,
            .auto-run-iterations-input {
                margin-bottom: 12px;
            }
        `, 'ai-studio-enhancer-custom-styles');

            // Create the UI panel using SidebarPanel component
            this.createSidebarPanel();

            // Setup chat monitoring to detect chat switches
            this.setupChatMonitoring();

            // Initialize ContentCollector for response monitoring
            this.initializeContentCollector();

            // Initialize FormStatePersistence for automatic form state saving
            this.initializeFormPersistence();

            // Setup user interaction tracking for run buttons
            this.setupRunButtonInteractionTracking();

            // Mark initial load as complete after a delay to allow for all responses to be collected
            setTimeout(() => {
                this.isInitialLoad = false;
                Logger.debug("Initial load completed, notifications now enabled for new responses");
            }, 2000);

            Logger.success("Google AI Studio Enhancer initialized successfully!");
        }

        /**
         * Wait for the page to be ready
         */
        async waitForPageReady() {
            // Wait for document to be complete
            if (document.readyState !== 'complete') {
                await new Promise(resolve => {
                    window.addEventListener('load', resolve, { once: true });
                });
            }
            
            // Wait for main content areas to be available
            try {
                // Wait for key Google AI Studio elements to be present
                await HTMLUtils.waitForElement('body', 5000);
                
                // Give additional time for dynamic content to load
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                Logger.debug('Page ready - main elements found');
            } catch (error) {
                Logger.warn('Some page elements not found, but continuing:', error.message);
            }
        }

        /**
         * Create the main UI panel using SidebarPanel component
         */
        createSidebarPanel() {
            this.sidebarPanel = new SidebarPanel({
                title: '🤖 AI Studio Enhancer',
                id: 'ai-studio-enhancer-panel',
                position: 'right',
                transition: 'slide',
                buttonIcon: '🤖',
                content: {
                    generator: () => this.createPanelContent()
                },
                style: {
                    width: '380px',
                    buttonSize: '48px',
                    buttonColor: '#fff',
                    buttonBg: '#4285f4',
                    panelBg: '#fff'
                },
                rememberState: true
            });

            Logger.debug("SidebarPanel created");
        }

        /**
         * Create the content for the sidebar panel
         */
        createPanelContent() {
            const content = document.createElement('div');
            content.style.cssText = `
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
        `;

            // Create sections
            this.createResponseSection(content);
            this.createAutoRunSection(content);
            this.createSettingsSection(content);

            return content;
        }

        /**
         * Create the response management section
         */
        createResponseSection(container) {
            const section = document.createElement('div');
            section.style.marginBottom = '20px';

            // Section title
            const title = document.createElement('h3');
            title.textContent = '📋 Response Management';
            title.style.cssText = 'margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #333;';

            // Response counter
            this.responseCountElement = document.createElement('div');
            this.responseCountElement.textContent = `Current chat responses: ${this.responses.length}`;
            this.responseCountElement.style.cssText = 'margin-bottom: 10px; color: #666; font-size: 12px;';

            // Copy button using Button component
            this.copyButton = new Button({
                text: 'Copy All Responses',
                theme: 'primary',
                size: 'medium',
                onClick: (event) => this.handleCopyButtonClick(event),
                successText: '✅ Copied!',
                successDuration: 1000,
                className: 'copy-responses-button',
                container: section
            });

            section.appendChild(title);
            section.appendChild(this.responseCountElement);
            // Note: copyButton is automatically appended to section via container option

            container.appendChild(section);
        }

        /**
         * Create the auto-run section
         */
        createAutoRunSection(container) {
            const section = document.createElement('div');
            section.style.marginBottom = '20px';

            // Section title
            const title = document.createElement('h3');
            title.textContent = '🔄 Auto Runner';
            title.style.cssText = 'margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #333;';

            // Prompt input using TextArea component
            this.promptTextArea = new TextArea({
                value: this.settings.AUTO_RUN_PROMPT,
                placeholder: 'Enter prompt to auto-run (optional)',
                rows: 3,
                theme: 'primary',
                size: 'medium',
                className: 'auto-run-prompt-textarea',
                onInput: (event, textArea) => {
                    this.settings.AUTO_RUN_PROMPT = textArea.getValue();
                    this.saveSettings();
                },
                container: section
            });

            // Iterations input using Input component
            this.iterationsInput = new Input({
                type: 'number',
                value: this.settings.DEFAULT_ITERATIONS.toString(),
                placeholder: 'Number of iterations',
                min: '1',
                max: '100',
                theme: 'primary',
                size: 'medium',
                className: 'auto-run-iterations-input',
                validator: (value) => {
                    const num = parseInt(value, 10);
                    if (isNaN(num) || num < 1) {
                        return 'Please enter a number greater than 0';
                    }
                    if (num > 100) {
                        return 'Maximum 100 iterations allowed';
                    }
                    return true;
                },
                onChange: (event, input) => {
                    const value = parseInt(input.getValue(), 10);
                    if (!isNaN(value) && value > 0) {
                        this.settings.DEFAULT_ITERATIONS = value;
                        this.saveSettings();
                    }
                },
                container: section
            });

            // Button container
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'margin-bottom: 10px;';

            // Single toggle button for start/stop using Button component
            this.toggleButton = new Button({
                text: 'Start Auto Run',
                theme: 'primary',
                size: 'medium',
                onClick: (event) => this.handleToggleButtonClick(event),
                className: 'auto-run-toggle-button',
                container: buttonContainer
            });

            // Status display
            this.statusElement = document.createElement('div');
            this.statusElement.textContent = 'Ready to start';
            this.statusElement.style.cssText = 'font-size: 12px; color: #666; text-align: center;';

            section.appendChild(title);
            // promptTextArea and iterationsInput are automatically appended via container option
            section.appendChild(buttonContainer);
            section.appendChild(this.statusElement);

            container.appendChild(section);
        }

        /**
         * Create the settings section
         */
        createSettingsSection(container) {
            const section = document.createElement('div');

            // Section title
            const title = document.createElement('h3');
            title.textContent = '⚙️ Settings';
            title.style.cssText = 'margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: #333;';

            // Cache management subsection
            const cacheSubsection = document.createElement('div');
            cacheSubsection.style.marginBottom = '16px';

            const cacheTitle = document.createElement('h4');
            cacheTitle.textContent = '💾 Cache Management';
            cacheTitle.style.cssText = 'margin: 0 0 8px 0; font-size: 13px; font-weight: 500; color: #555;';

            // Cache info
            const cacheInfo = document.createElement('div');
            cacheInfo.textContent = 'Responses are automatically saved per chat';
            cacheInfo.style.cssText = `
            color: #666;
            font-size: 12px;
            margin-bottom: 8px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
        `;

            // Clear cache button
            new Button({
                text: 'Clear Current Chat Cache',
                theme: 'danger',
                size: 'small',
                onClick: (event) => this.handleClearCacheClick(event),
                successText: '✅ Cleared!',
                successDuration: 1500,
                container: cacheSubsection
            });

            cacheSubsection.appendChild(cacheTitle);
            cacheSubsection.appendChild(cacheInfo);
            // clearCacheButton is automatically appended via container option

            // User interaction subsection
            const interactionSubsection = document.createElement('div');
            interactionSubsection.style.marginBottom = '16px';

            const interactionTitle = document.createElement('h4');
            interactionTitle.textContent = '👆 User Interaction Detection';
            interactionTitle.style.cssText = 'margin: 0 0 8px 0; font-size: 13px; font-weight: 500; color: #555;';

            // Interaction stats
            this.interactionStatsElement = document.createElement('div');
            this.updateInteractionStats();
            this.interactionStatsElement.style.cssText = `
            color: #666;
            font-size: 11px;
            margin-bottom: 8px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-line;
        `;

            // Auto-update stats every 2 seconds
            this.statsUpdateInterval = setInterval(() => {
                this.updateInteractionStats();
            }, 2000);

            interactionSubsection.appendChild(interactionTitle);
            interactionSubsection.appendChild(this.interactionStatsElement);

            section.appendChild(title);
            section.appendChild(cacheSubsection);
            section.appendChild(interactionSubsection);

            container.appendChild(section);
        }

        /**
         * Handle URL changes detected by UrlChangeWatcher
         */
        handleUrlChange(newUrl, oldUrl) {
            const newChatId = this.extractChatId(newUrl);
            if (newChatId !== this.currentChatId) {
                Logger.info(`Chat changed from ${this.currentChatId} to ${newChatId} (URL: ${oldUrl} → ${newUrl})`);
                this.currentChatId = newChatId;
                this.onChatChanged();
            }
        }

        /**
         * Initialize ContentCollector for sophisticated response monitoring
         */
        async initializeContentCollector() {
            // Setup event subscriptions for ContentCollector
            this.subscriptionIds.push(
                PubSub.subscribe(ContentCollector.EVENTS.CONTENT_ADDED, (data) => {
                    // Update our local responses array to maintain compatibility
                    this.responses = this.contentCollector.getContent();
                    
                    // Handle the new content addition
                    this.handleResponseAdded({
                        text: data.content,
                        total: data.totalItems,
                        isInitialLoad: this.isInitialLoad
                    });
                })
            );

            this.subscriptionIds.push(
                PubSub.subscribe(ContentCollector.EVENTS.COLLECTION_UPDATED, (data) => {
                    // Update response count in UI
                    this.updateResponseCount();
                    Logger.debug(`ContentCollector updated: ${data.newItems} new, ${data.totalItems} total`);
                })
            );

            // Start monitoring for responses
            this.contentCollector.startMonitoring();
            
            // Update our responses array from ContentCollector
            this.responses = this.contentCollector.getContent();
            
            Logger.info("ContentCollector initialized and monitoring started");
        }

        /**
         * Initialize FormStatePersistence for automatic form state saving
         */
        async initializeFormPersistence() {
            // Wait for form elements to be available
            setTimeout(async () => {
                try {
                    await this.formPersistence.initialize();
                    Logger.info("FormStatePersistence initialized successfully");
                } catch (error) {
                    Logger.warn("FormStatePersistence initialization failed:", error);
                }
            }, 1000); // Delay to ensure form elements are created
        }

        /**
         * Setup chat monitoring to detect when user switches between chats
         */
        setupChatMonitoring() {
            // Initialize current chat ID
            this.currentChatId = this.extractChatId(window.location.href);
            
            // Start URL change monitoring
            this.urlWatcher.start();

            // Also monitor DOM changes that might indicate chat switches
            this.chatObserver = new DOMObserver((mutations) => {
                this.handleChatDOMChanges(mutations);
            });

            this.chatObserver.observe(document.body, {
                childList: true,
                subtree: true
            });

            Logger.debug("Chat monitoring setup complete");
        }

        /**
         * Extract chat ID from URL or content
         */
        extractChatId(url) {
            // Try to extract chat ID from URL patterns
            const urlPatterns = [
                /\/chat\/([^\/\?]+)/,
                /\/conversation\/([^\/\?]+)/,
                /\/prompt\/([^\/\?]+)/,
                /\/c\/([^\/\?]+)/
            ];

            for (const pattern of urlPatterns) {
                const match = url.match(pattern);
                if (match) {
                    return match[1];
                }
            }

            // Fallback: use the full pathname as identifier
            return window.location.pathname;
        }

        /**
         * Handle chat DOM changes that might indicate a chat switch
         */
        handleChatDOMChanges(mutations) {
            for (const mutation of mutations) {
                if (mutation.type === 'childList') {
                    // Look for elements that might indicate a new chat
                    for (const node of mutation.addedNodes) {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            // Check if this looks like a new conversation container
                            if (node.querySelector && 
                                (node.querySelector('[data-testid*="conversation"]') ||
                                 node.querySelector('.conversation') ||
                                 node.querySelector('.chat-container'))) {
                                // Slight delay to ensure the chat has fully loaded
                                setTimeout(() => {
                                    const newChatId = this.extractChatId(window.location.href);
                                    if (newChatId !== this.currentChatId) {
                                        Logger.info(`Chat changed via DOM to ${newChatId}`);
                                        this.currentChatId = newChatId;
                                        this.onChatChanged();
                                    }
                                }, 500);
                                break;
                            }
                        }
                    }
                }
            }
        }

        /**
         * Handle chat change event
         */
        onChatChanged() {
            Logger.info('Chat changed - clearing responses and collecting new ones');
            
            // Publish chat change event instead of handling directly
            PubSub.publish(AIStudioEnhancer.EVENTS.CHAT_CHANGED, {
                oldChatId: this.previousChatId || null,
                newChatId: this.currentChatId
            });
            
            // Store previous chat ID for next change
            this.previousChatId = this.currentChatId;
        }



        /**
         * Setup user interaction tracking for run buttons
         */
        setupRunButtonInteractionTracking() {
            // Track run button interactions using a MutationObserver to detect when buttons appear
            const runButtonObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.ELEMENT_NODE) {
                                // Look for run buttons in the added nodes
                                this.trackRunButtonsInElement(node);
                            }
                        });
                    }
                });
            });

            runButtonObserver.observe(document.body, {
                childList: true,
                subtree: true
            });

            // Track existing run buttons
            this.trackExistingRunButtons();

            Logger.debug("Run button interaction tracking setup complete");
        }

        /**
         * Track existing run buttons on the page
         */
        trackExistingRunButtons() {
            AIStudioEnhancer.SELECTORS.RUN_BUTTONS.forEach(selector => {
                document.querySelectorAll(selector).forEach(button => {
                    this.trackRunButton(button);
                });
            });
        }

        /**
         * Track run buttons within a specific element
         */
        trackRunButtonsInElement(element) {
            // Check if the element itself is a run button
            if (element.matches) {
                AIStudioEnhancer.SELECTORS.RUN_BUTTONS.forEach(selector => {
                    if (element.matches(selector)) {
                        this.trackRunButton(element);
                    }
                });
            }

            // Check for run buttons within the element
            if (element.querySelectorAll) {
                AIStudioEnhancer.SELECTORS.RUN_BUTTONS.forEach(selector => {
                    element.querySelectorAll(selector).forEach(button => {
                        this.trackRunButton(button);
                    });
                });
            }
        }

        /**
         * Track interactions with a specific run button
         */
        trackRunButton(button) {
            // Avoid double-tracking
            if (button._aiStudioEnhancerTracked) {
                return;
            }
            button._aiStudioEnhancerTracked = true;

            // Use UserInteractionDetector to track this button
            const unsubscribe = this.userInteraction.trackElement(
                button,
                ['click', 'mousedown', 'touchstart'],
                (interactionData) => {
                    this.handleRunButtonInteraction(button, interactionData);
                }
            );

            // Store unsubscribe function for cleanup
            if (!button._aiStudioEnhancerCleanup) {
                button._aiStudioEnhancerCleanup = [];
            }
            button._aiStudioEnhancerCleanup.push(unsubscribe);

            Logger.debug('Started tracking run button interactions:', button);
        }

        /**
         * Handle run button interaction events
         */
        handleRunButtonInteraction(button, interactionData) {
            const { event, isUserInitiated, globalInteracting, timeSinceLastInteraction } = interactionData;
            
            // Check if this is our programmatic click
            const isProgrammaticFromAutoRun = event._aiStudioEnhancerProgrammatic;
            
            Logger.debug('Run button interaction detected', {
                eventType: event.type,
                isUserInitiated,
                isProgrammaticFromAutoRun,
                globalInteracting,
                timeSinceLastInteraction,
                isAutoRunning: this.isAutoRunning,
                isTrusted: event.isTrusted
            });

            // Publish event for analytics/logging
            PubSub.publish(AIStudioEnhancer.EVENTS.UI_UPDATE_REQUIRED, {
                type: isUserInitiated ? 'user-action' : 'programmatic-action',
                action: 'run-button-click',
                userInitiated: isUserInitiated,
                isProgrammaticFromAutoRun,
                eventType: event.type,
                isAutoRunning: this.isAutoRunning
            });

            // Special handling for user-initiated clicks during auto-run
            if (isUserInitiated && this.isAutoRunning && !isProgrammaticFromAutoRun) {
                Logger.info('User clicked run button while auto-run is active - this may interfere with automation');
                this.showNotification('Manual run detected during auto-run - may cause conflicts', 'warning');
            }
        }



        /**
         * Clean response text by removing UI elements and metadata
         */
        cleanResponseText(text) {
            if (!text) return '';

            // Common UI elements to remove (case-insensitive)
            const uiElements = [
                'edit', 'more_vert', 'thumb_up', 'thumb_down', 'copy', 'share',
                'delete', 'refresh', 'restart', 'stop', 'play', 'pause',
                'expand_more', 'expand_less', 'close', 'menu', 'settings',
                'download', 'upload', 'save', 'favorite', 'star', 'bookmark',
                'like', 'dislike', 'report', 'flag', 'hide', 'show'
            ];

            // Split into lines and clean
            let lines = text.split('\n')
                .map(line => line.trim())
                .filter(line => {
                    // Remove empty lines
                    if (!line) return false;
                    
                    // Remove lines that are just UI elements
                    const lowerLine = line.toLowerCase();
                    if (uiElements.includes(lowerLine)) return false;
                    
                    // Remove lines with only symbols/dashes
                    if (/^[-=_\s]+$/.test(line)) return false;
                    
                    // Remove very short lines that are likely UI elements
                    if (line.length <= 3 && !/\w/.test(line)) return false;
                    
                    return true;
                });

            // Remove common patterns at the beginning and end
            while (lines.length > 0 && this.isUILine(lines[0])) {
                lines.shift();
            }
            while (lines.length > 0 && this.isUILine(lines[lines.length - 1])) {
                lines.pop();
            }

            return lines.join('\n').trim();
        }

        /**
         * Check if a line is likely a UI element
         */
        isUILine(line) {
            const cleaned = line.toLowerCase().trim();
            
            // Common UI patterns
            const uiPatterns = [
                /^(edit|copy|share|delete|save|download)$/,
                /^(thumb_up|thumb_down|more_vert)$/,
                /^(expand_more|expand_less|close|menu)$/,
                /^[👍👎❤️⭐🔗📋✏️🗑️]+$/,  // Emoji-only lines
                /^[\s\-=_]{1,5}$/,          // Short separator lines
            ];

            return uiPatterns.some(pattern => pattern.test(cleaned));
        }

        /**
         * Extract clean text from response element
         */
        extractResponseText(element) {
            // Try to find more specific text content within the response container
            const textSelectors = [
                '.response-text',
                '.message-content',
                '.content',
                '.text-content',
                'p',
                'div.content',
                '[data-testid="message-text"]'
            ];

            // First, try to find specific text content elements
            for (const selector of textSelectors) {
                const textElement = element.querySelector(selector);
                if (textElement) {
                    const text = textElement.innerText?.trim();
                    if (text && text.length > 10) {
                        return this.cleanResponseText(text);
                    }
                }
            }

            // If no specific text element found, use the container but clean it thoroughly
            const fullText = element.innerText?.trim();
            return this.cleanResponseText(fullText);
        }



        /**
         * Copy all responses to clipboard without showing notifications
         */
        async copyAllResponsesSilent() {
            // Get responses from ContentCollector if available, fallback to local array
            const responses = this.contentCollector ? this.contentCollector.getContent() : this.responses;
            
            if (responses.length === 0) {
                return false;
            }

            // Format responses - clean output without headers
            const content = responses.join('\n\n---\n\n');

            try {
                GM_setClipboard(content);
                Logger.success(`Copied ${responses.length} responses to clipboard`);
                return true;
            } catch (error) {
                Logger.error('Failed to copy responses:', error);
                return false;
            }
        }

        /**
         * Update response counter display
         */
        updateResponseCount() {
            if (this.responseCountElement) {
                // Get count from ContentCollector if available, fallback to local array
                const count = this.contentCollector ? this.contentCollector.getContent().length : this.responses.length;
                this.responseCountElement.textContent = `Current chat responses: ${count}`;
            }
        }

        /**
         * Manual copy button handler - always shows notifications
         */
        async copyAllResponsesManual() {
            // Get responses from ContentCollector if available, fallback to local array
            const responses = this.contentCollector ? this.contentCollector.getContent() : this.responses;
            
            if (responses.length === 0) {
                this.showNotification('No responses found to copy', 'warning');
                return false;
            }

            const success = await this.copyAllResponsesSilent();
            if (success) {
                this.showNotification(`Copied ${responses.length} responses to clipboard`, 'success');
            } else {
                this.showNotification('Failed to copy responses', 'error');
            }
            return success;
        }

        /**
         * Copy all responses to clipboard (legacy method for compatibility)
         */
        async copyAllResponses() {
            return await this.copyAllResponsesManual();
        }

        /**
         * Clear all collected responses
         */
        clearResponses() {
            this.responses = [];
            if (this.contentCollector) {
                this.contentCollector.clearContent();
            }
            this.updateResponseCount();
            this.showNotification('Chat responses cleared', 'info');
            Logger.info('Chat responses cleared');
        }

        /**
         * Toggle auto-run process (start/stop)
         */
        async toggleAutoRun() {
            if (this.isAutoRunning) {
                this.stopAutoRun();
            } else {
                await this.startAutoRun();
            }
        }

        /**
         * Start auto-run process using AutoRunner
         */
        async startAutoRun() {
            if (this.isAutoRunning) {
                this.showNotification('Auto runner is already running', 'warning');
                return false;
            }

            // Validate iterations input first
            if (!this.iterationsInput.validate()) {
                this.showNotification('Please fix the iterations input error', 'error');
                return false;
            }

            const iterations = parseInt(this.iterationsInput.getValue(), 10);
            if (isNaN(iterations) || iterations <= 0) {
                this.showNotification('Please enter a valid number of iterations', 'error');
                return false;
            }

            // Create AutoRunner instance
            this.autoRunner = new AutoRunner({
                name: 'AI-Studio-AutoRun',
                maxIterations: iterations,
                delay: 1000, // 1 second between iterations
                taskFunction: async (iteration, results) => {
                    return await this.executeAutoRunIteration(iteration, results);
                },
                enableNotifications: true,
                enableInteractionDetection: true,
                onProgress: (current, total, result, results) => {
                    this.currentIteration = current;
                    this.maxIterations = total;
                    PubSub.publish(AIStudioEnhancer.EVENTS.AUTO_RUN_ITERATION, {
                        current,
                        total,
                        timestamp: Date.now()
                    });
                },
                onError: (error, iteration) => {
                    Logger.error(`Auto-run iteration ${iteration} failed:`, error);
                    this.showNotification(`Auto-run iteration ${iteration} failed: ${error.message}`, 'error');
                }
            });

            // Subscribe to AutoRunner events
            this.subscriptionIds.push(
                PubSub.subscribe(AutoRunner.EVENTS.STARTED, (data) => {
                    if (data.name === 'AI-Studio-AutoRun') {
                        this.isAutoRunning = true;
                        PubSub.publish(AIStudioEnhancer.EVENTS.AUTO_RUN_STARTED, {
                            iterations: data.maxIterations,
                            timestamp: data.timestamp
                        });
                    }
                })
            );

            this.subscriptionIds.push(
                PubSub.subscribe(AutoRunner.EVENTS.STOPPED, (data) => {
                    if (data.name === 'AI-Studio-AutoRun') {
                        this.isAutoRunning = false;
                        this.currentIteration = 0;
                        PubSub.publish(AIStudioEnhancer.EVENTS.AUTO_RUN_STOPPED, {
                            reason: data.reason,
                            timestamp: data.timestamp
                        });
                    }
                })
            );

            this.subscriptionIds.push(
                PubSub.subscribe(AutoRunner.EVENTS.COMPLETED, (data) => {
                    if (data.name === 'AI-Studio-AutoRun') {
                        this.isAutoRunning = false;
                        this.currentIteration = 0;
                        PubSub.publish(AIStudioEnhancer.EVENTS.AUTO_RUN_STOPPED, {
                            reason: 'completed',
                            timestamp: data.timestamp
                        });
                    }
                })
            );

            // Start the AutoRunner
            this.isAutoRunning = true;
            const started = await this.autoRunner.start();
            
            if (!started) {
                this.isAutoRunning = false;
                this.showNotification('Failed to start auto runner', 'error');
                return false;
            }

            return true;
        }

        /**
         * Stop auto-run process
         */
        stopAutoRun() {
            // Add debugging to see what's calling this method
            Logger.warn('stopAutoRun called! Stack trace:', new Error().stack);
            
            if (this.autoRunner) {
                this.autoRunner.stop('user requested');
            } else {
                // Fallback for direct calls
                this.isAutoRunning = false;
                this.currentIteration = 0;
                
                PubSub.publish(AIStudioEnhancer.EVENTS.AUTO_RUN_STOPPED, {
                    reason: 'user requested',
                    timestamp: Date.now()
                });

                Logger.info(`Auto runner stopped and reset`);
            }
        }

        /**
         * Execute a single auto-run iteration (used by AutoRunner)
         */
        async executeAutoRunIteration(iteration, results) {
            Logger.info(`Executing auto-run iteration ${iteration}`);

            // Enter prompt if specified
            const currentPrompt = this.promptTextArea.getValue().trim();
            if (currentPrompt) {
                const promptEntered = await this.enterPrompt(currentPrompt);
                if (!promptEntered) {
                    Logger.warn('Could not enter prompt - prompt input not found, continuing anyway');
                } else {
                    // Small delay after entering prompt to let Google process the input
                    await this.delay(500);
                }
            }

            // Wait for run button to become enabled (with retry mechanism)
            const runButton = await this.waitForRunButton();
            if (!runButton) {
                throw new Error('Run button not found after waiting');
            }

            // Click the run button programmatically during auto-run
            const clickEvent = new MouseEvent('click', {
                bubbles: true,
                cancelable: true
            });
            
            // Mark this as a programmatic click for our own tracking
            clickEvent._aiStudioEnhancerProgrammatic = true;
            
            runButton.dispatchEvent(clickEvent);
            Logger.debug('Run button clicked programmatically during auto-run iteration');

            // Wait for response completion
            await this.waitForResponseCompletion();

            return {
                iteration,
                timestamp: Date.now(),
                promptUsed: currentPrompt,
                success: true
            };
        }



        /**
         * Find the prompt input field on the page
         */
        findPromptInput() {
            // Try specific selectors first
            for (const selector of AIStudioEnhancer.SELECTORS.PROMPT_INPUTS) {
                const input = document.querySelector(selector);
                if (input && !input.disabled && !input.readOnly) {
                    return input;
                }
            }

            // Fallback: search for any visible textarea
            const textareas = document.querySelectorAll('textarea');
            for (const textarea of textareas) {
                if (textarea.offsetParent !== null && !textarea.disabled && !textarea.readOnly) {
                    return textarea;
                }
            }

            // Fallback: search for contenteditable divs
            const editableDivs = document.querySelectorAll('div[contenteditable="true"]');
            for (const div of editableDivs) {
                if (div.offsetParent !== null) {
                    return div;
                }
            }

            return null;
        }

        /**
         * Enter prompt text into the input field
         */
        async enterPrompt(promptText) {
            const promptInput = this.findPromptInput();
            if (!promptInput) {
                Logger.warn('Prompt input field not found');
                return false;
            }

            try {
                // Clear existing content
                if (promptInput.tagName.toLowerCase() === 'textarea' || promptInput.tagName.toLowerCase() === 'input') {
                    // For regular input/textarea elements
                    promptInput.value = '';
                    promptInput.focus();
                    
                    // Simulate typing the prompt
                    promptInput.value = promptText;
                    
                    // Trigger input events
                    promptInput.dispatchEvent(new Event('input', { bubbles: true }));
                    promptInput.dispatchEvent(new Event('change', { bubbles: true }));
                } else {
                    // For contenteditable divs
                    promptInput.focus();
                    promptInput.textContent = promptText;
                    
                    // Trigger input events
                    promptInput.dispatchEvent(new Event('input', { bubbles: true }));
                }

                Logger.debug('Prompt entered successfully:', promptText.substring(0, 50) + '...');
                return true;
            } catch (error) {
                Logger.error('Error entering prompt:', error);
                return false;
            }
        }

        /**
         * Create a delay
         */
        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Wait for the run button to become available and enabled
         */
        async waitForRunButton(maxWaitTime = 10000) {
            try {
                // Try to find enabled run button using HTMLUtils
                const button = await HTMLUtils.waitForElement('button.run-button[aria-label="Run"]:not(.disabled):not([disabled]):not(.stoppable)', maxWaitTime);
                Logger.debug('Run button found and enabled using HTMLUtils');
                return button;
            } catch (error) {
                // Fallback to custom logic if specific selector doesn't work
                Logger.debug('HTMLUtils waitForElement failed, trying fallback method');
                
                try {
                    // Wait for any run button first
                    await HTMLUtils.waitForElement('button.run-button[aria-label="Run"]', maxWaitTime);
                    
                    // Then check if it's enabled
                    const button = this.findRunButton();
                    if (button) {
                        Logger.debug('Run button found via fallback method');
                        return button;
                    }
                } catch (fallbackError) {
                        Logger.warn(`Run button not found after ${maxWaitTime}ms`);
                }
                
                return null;
            }
        }

        /**
         * Find the run button on the page
         */
        findRunButton() {
            // First, try Google AI Studio specific selectors (most accurate)
            const googleRunButton = document.querySelector('button.run-button[aria-label="Run"]');
            if (googleRunButton && !googleRunButton.disabled && !googleRunButton.classList.contains('disabled') && !googleRunButton.classList.contains('stoppable')) {
                return googleRunButton;
            }

            // Try other specific selectors
            for (const selector of AIStudioEnhancer.SELECTORS.RUN_BUTTONS) {
                const button = document.querySelector(selector);
                if (button && !button.disabled && !button.classList.contains('disabled')) {
                    return button;
                }
            }

            // Fallback: search by text content (avoiding busy/stoppable buttons)
            const buttons = document.querySelectorAll('button');
            for (const button of buttons) {
                const text = button.textContent?.toLowerCase().trim();
                if ((text === 'run' || text === 'send' || text.includes('run') || text.includes('send')) && 
                    !button.disabled && 
                    !button.classList.contains('disabled') &&
                    !button.classList.contains('stoppable')) {
                    return button;
                }
            }

            return null;
        }

        /**
         * Wait for response completion using DOM observer (much faster)
         */
        async waitForResponseCompletion() {
            return new Promise((resolve) => {
                let timeoutId;
                let observer;
                
                const cleanup = () => {
                    if (observer) {
                        observer.disconnect();
                    }
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                };

                const checkCompletion = () => {
                    const runButton = document.querySelector('button.run-button[aria-label="Run"]');
                    
                    if (!runButton) {
                        Logger.warn('Run button not found during completion check');
                        cleanup();
                        resolve();
                        return true;
                    }

                    // Check if button is in stoppable/busy state
                    const isStoppable = runButton.classList.contains('stoppable');
                    const isButtonTypeButton = runButton.type === 'button';
                    const isDisabled = runButton.disabled || runButton.classList.contains('disabled');
                    const buttonText = runButton.textContent?.trim();
                    
                    Logger.debug(`Button state check:`, {
                        isStoppable,
                        isButtonTypeButton,
                        isDisabled,
                        type: runButton.type,
                        text: buttonText,
                        classes: Array.from(runButton.classList)
                    });
                    
                    // Response is complete when button changes from "Stop" to "Run" state
                    // Note: Button may be disabled because prompt is empty (that's normal)
                    const isComplete = !isStoppable && !isButtonTypeButton && runButton.type === 'submit';
                    
                    if (isComplete) {
                        Logger.debug('Response completion detected via DOM observer');
                        cleanup();
                        resolve();
                        return true;
                    }
                    
                    return false;
                };

                // Set up DOM observer to watch for button changes
                observer = new MutationObserver((mutations) => {
                    let shouldCheck = false;
                    
                    mutations.forEach((mutation) => {
                        // Check if the run button or its attributes changed
                        if (mutation.type === 'attributes') {
                            const target = mutation.target;
                            if (target.classList.contains('run-button') || target.getAttribute('aria-label') === 'Run') {
                                Logger.debug(`Button attribute changed: ${mutation.attributeName} on`, target);
                                shouldCheck = true;
                            }
                        }
                        
                        // Check if new nodes were added that might be the run button
                        if (mutation.type === 'childList') {
                            mutation.addedNodes.forEach((node) => {
                                if (node.nodeType === Node.ELEMENT_NODE) {
                                    if (node.classList?.contains('run-button') || 
                                        node.querySelector?.('.run-button')) {
                                        Logger.debug('Run button node added/changed');
                                        shouldCheck = true;
                                    }
                                }
                            });
                        }
                        
                        // Also check for text content changes (Stop -> Run)
                        if (mutation.type === 'childList' || mutation.type === 'characterData') {
                            const target = mutation.target;
                            if (target.closest && target.closest('.run-button')) {
                                Logger.debug('Button content changed');
                                shouldCheck = true;
                            }
                        }
                    });
                    
                    if (shouldCheck) {
                        Logger.debug('DOM observer triggered, checking completion...');
                        checkCompletion();
                    }
                });

                // Start observing the document for changes
                observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['class', 'type', 'disabled', 'aria-label'],
                    characterData: true // Watch for text changes too
                });
                
                Logger.debug('DOM observer started, watching for button changes...');

                // Initial check after a short delay to let the button state change
                setTimeout(() => {
                    if (!checkCompletion()) {
                        // Set a maximum timeout as fallback
                        timeoutId = setTimeout(() => {
                            Logger.warn('Response completion timeout (2 minutes)');
                            cleanup();
                            resolve();
                        }, 120000); // 2 minutes
                        
                        // Also set up periodic checking as backup (every 5 seconds)
                        const intervalId = setInterval(() => {
                            Logger.debug('Periodic check (backup)...');
                            if (checkCompletion()) {
                                clearInterval(intervalId);
                            }
                        }, 5000);
                        
                        // Store interval ID for cleanup
                        const originalCleanup = cleanup;
                        cleanup = () => {
                            clearInterval(intervalId);
                            originalCleanup();
                        };
                    }
                }, 500); // Reduced from 2000ms to 500ms
            });
        }

        /**
         * Update button state based on running status
         */
        updateButtonState() {
            if (this.toggleButton) {
                if (this.isAutoRunning) {
                    this.toggleButton.setText('Stop Auto Run');
                    this.toggleButton.setTheme('danger');  // Red color for stop
                } else {
                    this.toggleButton.setText('Start Auto Run');
                    this.toggleButton.setTheme('primary');  // Blue color for start
                }
            }
        }

        /**
         * Update auto-run status display
         */
        updateAutoRunStatus() {
            if (this.statusElement) {
                if (this.isAutoRunning) {
                    this.statusElement.textContent = `Running: ${this.currentIteration}/${this.maxIterations}`;
                    } else {
                        this.statusElement.textContent = 'Ready to start';
                }
            }
        }

        /**
         * Show notification using the Notification component
         */
        showNotification(message, type = 'info') {
            // Always show notifications since we removed the setting
            // Use the Notification component for proper toast notifications
            switch (type) {
                case 'success':
                    Notification.success(message, {
                        duration: 3000,
                        position: 'top-center',
                        showProgress: true
                    });
                    break;
                case 'warning':
                    Notification.warning(message, {
                        duration: 4000,
                        position: 'top-center',
                        showProgress: true
                    });
                    break;
                case 'error':
                    Notification.error(message, {
                        duration: 5000,
                        position: 'top-center',
                        showProgress: true
                    });
                    break;
                case 'info':
                default:
                    Notification.info(message, {
                        duration: 3000,
                        position: 'top-center',
                        showProgress: true
                    });
                    break;
            }
            
            // Also log to console for debugging
            Logger.info(`[NOTIFICATION ${type.toUpperCase()}] ${message}`);
        }
    }

    /**
     * Initialize the enhancer when the page is ready
     */
    function init() {
        Logger.info("Starting Google AI Studio Enhancer initialization");
        
        // Check if we're on the correct page
        if (window.location.hostname !== 'aistudio.google.com') {
            Logger.warn("Not on Google AI Studio, script will not run");
            return;
        }

        new AIStudioEnhancer();
    }

    // Start initialization
    init();

})();
