// ==UserScript==
// @name        Instagram Reels Comments Copier
// @description Copy Instagram Reels comments via network capture with DOM fallback and a control panel.
// @namespace   https://github.com/baturkacamak/userscripts
// @version     0.1.0
// @author      Batur Kacamak
// @license     MIT
// @homepage    https://github.com/baturkacamak/userscripts/tree/master/userscripts/instagram-reels-comments-copier#readme
// @homepageURL https://github.com/baturkacamak/userscripts/tree/master/userscripts/instagram-reels-comments-copier#readme
// @supportURL  https://github.com/baturkacamak/userscripts/issues
// @downloadURL https://github.com/baturkacamak/userscripts/raw/master/userscripts/instagram-reels-comments-copier/instagram-reels-comments-copier.user.js
// @updateURL   https://github.com/baturkacamak/userscripts/raw/master/userscripts/instagram-reels-comments-copier/instagram-reels-comments-copier.user.js
// @match       https://*.instagram.com/*
// @icon        https://www.instagram.com/favicon.ico
// @run-at      document-idle
// @grant       GM_setClipboard
// @grant       GM_getValue
// @grant       GM_setValue
// ==/UserScript==

// !!!!! ATTENTION !!!!!
// DO NOT EDIT THIS FILE DIRECTLY!
// This file is automatically generated from the source script.
// Any direct modifications will be overwritten during the next build.
// Please make your changes in the original source file.
//

(function () {
    'use strict';

    /**
     * Enhanced Logger - A feature-rich logging utility
     * Supports log levels, styling, grouping, caller info, filtering, persistence, exporting, and more
     */
    class Logger {
        static DEBUG = true;
        static PREFIX = "Userscript";
        static _customFormat = null;
        static _logHistory = [];
        static _filters = new Set();
        static _lastTimestamp = null;
        static _persist = false;
        static _mock = false;
        static _theme = {
            debug: "color: #3498db; font-weight: bold;",
            info: "color: #1abc9c; font-weight: bold;",
            warn: "color: #f39c12; font-weight: bold;",
            error: "color: #e74c3c; font-weight: bold;",
            success: "color: #2ecc71; font-weight: bold;",
            trace: "color: #8e44ad; font-weight: bold;",
            htmlTitle: "color: #9b59b6; font-weight: bold;",
            htmlContent: "color: #2c3e50;",
            toggle: "color: #f39c12; font-weight: bold;"
        };
        static _emojis = {
            debug: "\uD83D\uDC1B",
            info: "\u2139\uFE0F",
            warn: "\u26A0\uFE0F",
            error: "\u274C",
            success: "\u2705",
            trace: "\uD83D\uDCCC",
            html: "\uD83E\uDDE9",
            toggle: "\uD83C\uDF9B\uFE0F"
        };

        static setTimeFormat(locale = "en-US", use12Hour = false) {
            this._customFormat = {locale, hour12: use12Hour};
        }

        static _detectTimeFormat() {
            try {
                const testDate = new Date(Date.UTC(2020, 0, 1, 13, 0, 0));
                const locale = navigator.language || "tr-TR";
                const timeString = testDate.toLocaleTimeString(locale);
                const is12Hour = timeString.toLowerCase().includes("pm") || timeString.toLowerCase().includes("am");
                return {locale, hour12: is12Hour};
            } catch (e) {
                return {locale: "tr-TR", hour12: false};
            }
        }

        static _timestamp() {
            const now = new Date();

            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
            const year = now.getFullYear();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const milliseconds = String(now.getMilliseconds()).padStart(3, '0');

            const time = `${day}/${month}/${year}, ${hours}:${minutes}:${seconds}.${milliseconds}`;

            let diff = "";
            if (this._lastTimestamp) {
                const ms = now - this._lastTimestamp;
                diff = ` [+${(ms / 1000).toFixed(3)}s]`; // Keep 3 decimal places for ms in diff
            }
            this._lastTimestamp = now;
            return `${time}${diff}`;
        }

        static _getCaller() {
            const err = new Error();
            const stack = err.stack?.split("\n")[3];
            return stack ? stack.trim() : "(unknown)";
        }

        static _log(level, ...args) {
            if (!this.DEBUG && level === "debug") return;
            if (this._filters.size && !args.some(arg => this._filters.has(arg))) return;
            const emoji = this._emojis[level] || '';
            const style = this._theme[level] || '';
            const timestamp = this._timestamp();
            const caller = this._getCaller();

            const message = [
                `%c${timestamp} %c${emoji} [${this.PREFIX} ${level.toUpperCase()}]%c:`,
                "color: gray; font-style: italic;",
                style,
                "color: inherit;",
                ...args,
                `\nCaller: ${caller}`
            ];

            this._logHistory.push({timestamp, level, args});

            if (this._persist) localStorage.setItem("LoggerHistory", JSON.stringify(this._logHistory));
            if (!this._mock) console.log(...message);
        }

        static debug(...args) {
            this._log("debug", ...args);
        }

        static info(...args) {
            this._log("info", ...args);
        }

        static warn(...args) {
            this._log("warn", ...args);
        }

        static error(...args) {
            this._log("error", ...args);
        }

        static success(...args) {
            this._log("success", ...args);
        }

        static trace(...args) {
            this._log("trace", ...args);
            console.trace();
        }

        static logHtml(title, htmlContent) {
            const shortContent = htmlContent.substring(0, 1500) + "...";
            this._log("html", `[${title}]`, shortContent);
            if (!this._mock) {
                console.groupCollapsed(`%c\uD83E\uDDE9 HTML Details (${title})`, this._theme.htmlTitle);
                console.log("%cComplete HTML:", this._theme.htmlTitle);
                console.log(`%c${htmlContent}`, this._theme.htmlContent);
                console.groupEnd();
            }
        }

        static setPrefix(prefix) {
            this.PREFIX = prefix;
        }

        static setTheme(theme) {
            Object.assign(this._theme, theme);
        }

        static newPrefix(prefix) {
            const prefixedLogger = {};
            const levels = ['debug', 'info', 'warn', 'error', 'success', 'trace', 'logHtml', 'step', 'hello'];

            levels.forEach(level => {
                prefixedLogger[level] = (...args) => {
                    const originalPrefix = this.PREFIX;
                    try {
                        this.setPrefix(prefix);
                        if (typeof Logger[level] === 'function') {
                            Logger[level](...args);
                        }
                    } finally {
                        this.setPrefix(originalPrefix);
                    }
                };
            });
            return prefixedLogger;
        }

        static addFilter(tag) {
            this._filters.add(tag);
        }

        static clearFilters() {
            this._filters.clear();
        }

        static persistLogs(enable = true) {
            this._persist = enable;
        }

        static mock(enable = true) {
            this._mock = enable;
        }

        static group(label) {
            if (!this._mock) console.group(label);
        }

        static groupEnd() {
            if (!this._mock) console.groupEnd();
        }

        static step(msg) {
            this.info(`\u2705 ${msg}`);
        }

        static hello() {
            this.info("Hello, dev! \uD83D\uDC4B Ready to debug?");
        }

        static downloadLogs(filename = "logs.json") {
            const blob = new Blob([JSON.stringify(this._logHistory, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        static autoClear(intervalMs) {
            setInterval(() => {
                this._logHistory = [];
                if (this._persist) localStorage.removeItem("LoggerHistory");
            }, intervalMs);
        }
    }

    /**
     * HTMLUtils - Utilities for HTML manipulation
     * Provides functions for escaping HTML, encoding/decoding entities, etc.
     */
    class HTMLUtils {
        static #policy;

        /**
         * Escape special HTML characters to prevent XSS
         * @param {string} str - The string to escape
         * @return {string} - The escaped string
         */
        static escapeHTML(str) {
            const escapeMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '\'': '&#39;',
                '"': '&quot;',
            };
            return str.replace(/[&<>'"]/g, (tag) => escapeMap[tag] || tag);
        }

        /**
         * Escape XML special characters
         * @param {string} str - The string to escape
         * @return {string} - The escaped string
         */
        static escapeXML(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        /**
         * Convert a plain text string to sanitized HTML
         * @param {string} text - The text to convert
         * @return {string} - HTML with line breaks and links
         */
        static textToHtml(text) {
            if (!text) return '';

            // First escape HTML
            let html = this.escapeHTML(text);

            // Convert line breaks to <br>
            html = html.replace(/\n/g, '<br>');

            // Convert URLs to links
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            html = html.replace(urlRegex, (url) => `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`);

            return html;
        }

        /**
         * * Wait for a specific element to appear in the DOM.
         *  * Continues checking using requestAnimationFrame until it appears,
         *  * a timeout is reached, or the maximum number of attempts is exceeded.
         *  *
         *  * @param {string} selector - CSS selector of the target element.
         *  * @param {number} [timeout=10000] - Maximum time in milliseconds to wait.
         *  * @param {Document|Element} [root=document] - DOM root to query from.
         *  * @param {number} [maxRetries=60] - Maximum number of requestAnimationFrame attempts.
         *  * @returns {Promise<Element>} Resolves with the found element or rejects on timeout.
         */
        static waitForElement(selector, timeout = 10000, root = document, maxRetries = 60) {
            return new Promise((resolve, reject) => {
                const startTime = Date.now();
                let attempts = 0;

                function checkElement() {
                    const element = root.querySelector(selector);
                    if (element) {
                        resolve(element);
                        return;
                    }

                    if ((Date.now() - startTime > timeout) || (attempts >= maxRetries)) {
                        reject(new Error(`Timeout waiting for element: ${selector}`));
                        return;
                    }

                    attempts++;
                    requestAnimationFrame(checkElement);
                }

                checkElement();
            });
        }

        static decodeHtmlEntities(encodedString) {
            if (!encodedString || typeof encodedString !== 'string') return encodedString;
            const textarea = document.createElement('textarea');
            textarea.innerHTML = encodedString;
            return textarea.value;
        }

        static extractMetaTags(html) {
            if (!html) return {};

            const metaTags = {};
            const regex = /<meta\s+(?:property|name)=["']([^"']+)["']\s+content=["']([^"']+)["']/gi;

            let match;
            while (match = regex.exec(html)) {
                if (match[1] && match[2]) {
                    metaTags[match[1]] = this.decodeHtmlEntities(match[2]);
                }
            }

            return metaTags;
        }

        /**
         * Safely set HTML content with CSP fallback
         * @param {HTMLElement} element - The element to set content on
         * @param {String} html - HTML content to set
         * @param {String} fallbackText - Text to use if HTML fails (optional)
         * @return {boolean} True if HTML was set successfully, false if fallback was used
         */
        static setHTMLSafely(element, html, fallbackText = null) {
            if (!element) return false;

            if (window.trustedTypes && window.trustedTypes.createPolicy) {
                if (!HTMLUtils.#policy) {
                    try {
                        HTMLUtils.#policy = window.trustedTypes.createPolicy('baturkacamak-userscripts-policy', {
                            createHTML: (input) => input,
                        });
                    } catch (e) {
                        // Policy likely already exists.
                        // We will fallback to innerHTML which will probably fail and be caught.
                        HTMLUtils.#policy = null;
                    }
                }
            }

            try {
                if (HTMLUtils.#policy) {
                    element.innerHTML = HTMLUtils.#policy.createHTML(html);
                } else {
                    element.innerHTML = html;
                }
                return true;
            } catch (error) {
                // Fallback to textContent if innerHTML fails due to CSP
                const fallback = fallbackText || html;
                element.textContent = fallback;
                return false;
            }
        }

        /**
         * Create an element with HTML content safely
         * @param {String} tagName - HTML tag name
         * @param {String} html - HTML content
         * @param {Object} attributes - Element attributes
         * @return {HTMLElement} The created element
         */
        static createElementWithHTML(tagName, html, attributes = {}) {
            const element = document.createElement(tagName);
            
            // Set attributes
            Object.keys(attributes).forEach(key => {
                element.setAttribute(key, attributes[key]);
            });
            
            // Set content safely
            this.setHTMLSafely(element, html);
            
            return element;
        }

        /**
         * Waits for an element to disappear from the DOM.
         * @param {string} selector - The CSS selector of the element.
         * @param {number} timeout - The maximum time to wait in milliseconds.
         * @param {number} interval - The interval between checks in milliseconds.
         * @returns {Promise<void>} A promise that resolves when the element is no longer found.
         */
        static waitForElementToDisappear(selector, timeout = 10000, interval = 1000) {
            return new Promise((resolve, reject) => {
                const startTime = Date.now();

                const check = () => {
                    if (!document.querySelector(selector)) {
                        clearInterval(intervalId);
                        resolve();
                    } else if (Date.now() - startTime > timeout) {
                        clearInterval(intervalId);
                        reject(new Error(`Element "${selector}" did not disappear within ${timeout}ms`));
                    }
                };

                const intervalId = setInterval(check, interval);
                check(); // Initial check
            });
        }
    }

    /**
     * StyleManager - Utility for CSS style management
     * Handles adding and removing styles, theme variables, etc.
     */
    class StyleManager {
        static styleElements = new Map();

        /**
         * Add CSS styles to the document
         * @param {string} css - CSS string to add
         * @param {string} id - Optional ID for the style element
         * @returns {HTMLStyleElement} - The created style element
         */
        static addStyles(css, id = null) {
            const style = document.createElement('style');
            style.textContent = css;

            if (id) {
                style.id = id;
                // Remove any existing style with the same ID
                if (this.styleElements.has(id)) {
                    this.removeStyles(id);
                }
                this.styleElements.set(id, style);
            }

            document.head.appendChild(style);
            return style;
        }

        /**
         * Remove styles by ID
         * @param {string} id - ID of the style element to remove
         * @returns {boolean} - True if styles were removed, false otherwise
         */
        static removeStyles(id) {
            if (!this.styleElements.has(id)) return false;

            const styleElement = this.styleElements.get(id);
            if (styleElement && styleElement.parentNode) {
                styleElement.parentNode.removeChild(styleElement);
            }

            this.styleElements.delete(id);
            return true;
        }

        /**
         * Check if styles with a given ID have already been added
         * @param {string} id - ID of the style element to check
         * @returns {boolean} - True if styles exist, false otherwise
         */
        static hasStyles(id) {
            return this.styleElements.has(id) || document.getElementById(id) !== null;
        }

        /**
         * Apply CSS variables for theming
         * @param {Object} variables - Object with variable names and values
         * @param {string} selector - CSS selector to apply variables to (default: :root)
         */
        static applyThemeVariables(variables, selector = ':root') {
            let css = `${selector} {\n`;

            Object.entries(variables).forEach(([name, value]) => {
                // Ensure variable names start with --
                const varName = name.startsWith('--') ? name : `--${name}`;
                css += `  ${varName}: ${value};\n`;
            });

            css += `}\n`;

            this.addStyles(css, 'theme-variables');
        }

        /**
         * Add styles to handle animations
         * @param {Object} animations - Key-value pairs of animation name and keyframes
         */
        static addAnimations(animations) {
            let css = '';

            Object.entries(animations).forEach(([name, keyframes]) => {
                css += `@keyframes ${name} {\n${keyframes}\n}\n\n`;
            });

            this.addStyles(css, 'animations');
        }
    }

    /**
     * Debouncer - A utility class for creating debounced and throttled functions
     *
     * Provides sophisticated debouncing and throttling with options for immediate/delayed
     * execution, cancellation, and flushing of pending operations.
     */
    class Debouncer {
      /**
         * Creates a debounced version of a function that delays invocation until after
         * a specified wait time has elapsed since the last time the debounced function was called.
         *
         * @param {Function} func - The function to debounce.
         * @param {number} wait - The number of milliseconds to delay.
         * @param {Object} [options] - The options object.
         * @param {boolean} [options.leading=false] - Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] - Specify invoking on the trailing edge of the timeout.
         * @return {Function} Returns the new debounced function.
         */
      static debounce(func, wait, options = {}) {
        const {leading = false, trailing = true} = options;
        let timeout;
        let lastArgs;
        let lastThis;
        let lastCallTime;
        let result;

        function invokeFunc() {
          const args = lastArgs;
          const thisArg = lastThis;

          lastArgs = lastThis = undefined;
          result = func.apply(thisArg, args);
          return result;
        }

        function startTimer(pendingFunc, wait) {
          return setTimeout(pendingFunc, wait);
        }

        function cancelTimer(id) {
          clearTimeout(id);
        }

        function trailingEdge() {
          timeout = undefined;

          // Only invoke if we have `lastArgs` which means `func` has been debounced at least once
          if (trailing && lastArgs) {
            return invokeFunc();
          }

          lastArgs = lastThis = undefined;
          return result;
        }

        function leadingEdge() {
          // Reset any `maxWait` timer
          timeout = startTimer(trailingEdge, wait);

          // Invoke the leading edge
          return leading ? invokeFunc() : result;
        }

        function cancel() {
          if (timeout !== undefined) {
            cancelTimer(timeout);
          }
          lastArgs = lastThis = lastCallTime = undefined;
          timeout = undefined;
        }

        function flush() {
          return timeout === undefined ? result : trailingEdge();
        }

        function debounced(...args) {
          const time = Date.now();
          const isInvoking = shouldInvoke(time);

          lastArgs = args;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timeout === undefined) {
              return leadingEdge();
            }
            if (isInvoking) {
              // Handle invocations in a tight loop
              timeout = startTimer(trailingEdge, wait);
              return invokeFunc();
            }
          }
          if (timeout === undefined) {
            timeout = startTimer(trailingEdge, wait);
          }
          return result;
        }

        function shouldInvoke(time) {
          const timeSinceLastCall = time - (lastCallTime || 0);

          // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit
          return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
                    (0 > timeSinceLastCall));
        }

        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      /**
         * Creates a throttled function that only invokes func at most once per
         * every wait milliseconds.
         *
         * @param {Function} func - The function to throttle.
         * @param {number} wait - The number of milliseconds to throttle invocations to.
         * @param {Object} [options] - The options object.
         * @param {boolean} [options.leading=true] - Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] - Specify invoking on the trailing edge of the timeout.
         * @return {Function} Returns the new throttled function.
         */
      static throttle(func, wait, options = {}) {
        return this.debounce(func, wait, {
          leading: false !== options.leading,
          trailing: false !== options.trailing,
        });
      }
    }

    /**
     * PubSub - A simple publish/subscribe pattern implementation
     * Enables components to communicate without direct references
     */
    class PubSub {
        static #events = {};

        /**
         * Subscribe to an event
         * @param {string} event - Event name
         * @param {Function} callback - Callback function
         * @return {string} Subscription ID
         */
        static subscribe(event, callback) {
            if (!this.#events[event]) {
                this.#events[event] = [];
            }

            const subscriptionId = `${event}_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
            this.#events[event].push({callback, subscriptionId});
            return subscriptionId;
        }

        /**
         * Unsubscribe from an event
         * @param {string} subscriptionId - Subscription ID
         * @return {boolean} Success state
         */
        static unsubscribe(subscriptionId) {
            for (const event in this.#events) {
                const index = this.#events[event].findIndex(sub => sub.subscriptionId === subscriptionId);
                if (index !== -1) {
                    this.#events[event].splice(index, 1);
                    return true;
                }
            }
            return false;
        }

        /**
         * Publish an event
         * @param {string} event - Event name
         * @param {any} data - Data to pass to subscribers
         */
        static publish(event, data) {
            if (!this.#events[event]) {
                return;
            }

            this.#events[event].forEach(sub => {
                sub.callback(data);
            });
        }

        /**
         * Clear all subscriptions
         * @param {string} [event] - Optional event name to clear only specific event
         */
        static clear(event) {
            if (event) {
                delete this.#events[event];
            } else {
                this.#events = {};
            }
        }
    }

    class UrlChangeWatcher {
      constructor(strategies = [], fireImmediately = true) {
        this.strategies = strategies;
        this.fireImmediately = fireImmediately;
        this.lastUrl = location.href;
        this.active = false;
      }

      start() {
        if (this.active) return;
        this.active = true;
        Logger.debug('UrlChangeWatcher (Strategy) started');

        this.strategies.forEach((strategy) =>
          strategy.start?.(this._handleChange.bind(this)),
        );

        if (this.fireImmediately) {
          this._handleChange(location.href, null, true);
        }
      }

      stop() {
        this.active = false;
        this.strategies.forEach((strategy) => strategy.stop?.());
        Logger.debug('UrlChangeWatcher (Strategy) stopped');
      }

      _handleChange(newUrl, oldUrl = this.lastUrl, force = false) {
        if (!force && newUrl === this.lastUrl) return;
        Logger.debug(`URL changed: ${oldUrl} → ${newUrl}`);

        this.lastUrl = newUrl;

        if (PubSub?.publish) {
          PubSub.publish('urlchange', {newUrl, oldUrl});
        }
      }
    }

    class BaseStrategy {
      constructor(callback) {
        this.callback = callback;
      }

      start() {
      }

      stop() {
      }
    }

    class PollingStrategy extends BaseStrategy {
      constructor(callback, interval = 500) {
        super(callback);
        this.interval = interval;
        this.lastUrl = location.href;
      }

      start() {
        Logger.debug('PollingStrategy started');
        this.timer = setInterval(() => {
          const current = location.href;
          if (current !== this.lastUrl) {
            Logger.debug(`Polling detected change: ${this.lastUrl} → ${current}`);
            this.callback(current, this.lastUrl);
            this.lastUrl = current;
          }
        }, this.interval);
      }

      stop() {
        clearInterval(this.timer);
        Logger.debug('PollingStrategy stopped');
      }
    }

    /**
     * GMFunctions - Provides fallback implementations for Greasemonkey/Tampermonkey functions
     * Ensures compatibility across different userscript managers and direct browser execution
     */

    class GMFunctions {
        /**
         * Check if we're running in development mode (outside a userscript manager)
         * @return {boolean} True if in development environment
         */
        static isDevelopmentMode() {
            // In production, GM_info should be defined by the userscript manager
            return 'undefined' === typeof GM_info;
        }

        /**
         * Initialize fallbacks for missing GM functions
         * @return {Object} Object containing references to all GM functions (either native or polyfilled)
         */
        static initialize() {
            const isDevMode = this.isDevelopmentMode();

            Logger.debug('GMFunctions initializing', isDevMode ? 'in development mode' : 'in production mode');

            if (isDevMode) {
                // Create fallbacks for common GM functions
                this.setupAddStyle();
                this.setupXmlHttpRequest();
                this.setupSetClipboard();
                this.setupDownload();
                this.setupGetValue();
                this.setupSetValue();

                Logger.info('GM function fallbacks have been created for development mode');
            } else {
                Logger.debug('Using native userscript manager GM functions');
            }

            // Return references to all functions (either native or polyfilled)
            return {
                GM_addStyle: window.GM_addStyle,
                GM_xmlhttpRequest: window.GM_xmlhttpRequest,
                GM_setClipboard: window.GM_setClipboard,
                GM_download: window.GM_download,
                GM_getValue: window.GM_getValue,
                GM_setValue: window.GM_setValue,
            };
        }

        /**
         * Set up GM_addStyle fallback
         */
        static setupAddStyle() {
            window.GM_addStyle = function (css) {
                Logger.debug('GM_addStyle fallback executing', css.substring(0, 50) + '...');
                const style = document.createElement('style');
                style.textContent = css;
                document.head.appendChild(style);
                return style;
            };
        }

        /**
         * Set up GM_xmlhttpRequest fallback
         */
        static setupXmlHttpRequest() {
            window.GM_xmlhttpRequest = function (details) {
                Logger.debug('GM_xmlhttpRequest fallback executing', {
                    method: details.method,
                    url: details.url
                });

                const xhr = new XMLHttpRequest();
                xhr.open(details.method, details.url);

                if (details.headers) {
                    Object.keys(details.headers).forEach((key) => {
                        xhr.setRequestHeader(key, details.headers[key]);
                    });
                }

                xhr.onload = function () {
                    if (details.onload) {
                        const response = {
                            responseText: xhr.responseText,
                            response: xhr.response,
                            status: xhr.status,
                            statusText: xhr.statusText,
                            readyState: xhr.readyState,
                        };

                        Logger.debug('GM_xmlhttpRequest completed', {
                            status: xhr.status,
                            url: details.url
                        });

                        details.onload(response);
                    }
                };

                xhr.onerror = function () {
                    Logger.error('GM_xmlhttpRequest error', {
                        url: details.url,
                        status: xhr.status
                    });

                    if (details.onerror) {
                        details.onerror(xhr);
                    }
                };

                xhr.send(details.data);
                return xhr;
            };
        }

        /**
         * Set up GM_setClipboard fallback
         */
        static setupSetClipboard() {
            window.GM_setClipboard = function (text) {
                Logger.debug('GM_setClipboard fallback executing', {
                    textLength: text.length
                });

                // Create a temporary textarea element
                const textarea = document.createElement('textarea');
                textarea.value = text;

                // Make the textarea not visible
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';

                document.body.appendChild(textarea);
                textarea.select();

                // Try to copy the text
                let success = false;
                try {
                    success = document.execCommand('copy');
                    Logger.info('Clipboard copy ' + (success ? 'successful' : 'unsuccessful'));
                } catch (err) {
                    Logger.error(err, 'Error copying to clipboard');
                }

                // Clean up
                document.body.removeChild(textarea);
                return success;
            };
        }

        /**
         * Set up GM_download fallback
         */
        static setupDownload() {
            window.GM_download = function (options) {
                // Wrapping in a Promise to allow for async-like behavior if needed by caller,
                // though current implementation is synchronous.
                return new Promise((resolve, reject) => {
                    try {
                        const {url, name, onload, onerror} = options;

                        Logger.debug('GM_download fallback executing', {
                            url: url.substring(0, 100),
                            filename: name
                        });

                        // Create download link
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = name || 'download';
                        downloadLink.style.display = 'none';

                        // Add to document, click, and remove
                        document.body.appendChild(downloadLink);
                        downloadLink.click();

                        // Clean up
                        setTimeout(() => {
                            document.body.removeChild(downloadLink);
                            if (onload) {
                                Logger.debug('GM_download completed successfully');
                                onload();
                            }
                            resolve(true); // Resolve promise on success
                        }, 100);

                    } catch (err) {
                        Logger.error(err, 'Error downloading file');
                        if (options.onerror) options.onerror(err);
                        reject(err); // Reject promise on error
                    }
                });
            };
        }

        /**
         * Set up GM_getValue fallback using localStorage, returning a Promise.
         */
        static setupGetValue() {
            window.GM_getValue = function (key, defaultValue) {
                return new Promise((resolve) => {
                    try {
                        const storageKey = `GM_${key}`;
                        Logger.debug('GM_getValue fallback: Attempting to get \'' + storageKey + '\'');
                        const value = localStorage.getItem(storageKey);
                        if (value !== null) {
                            try {
                                const parsedValue = JSON.parse(value);
                                Logger.debug('GM_getValue fallback: Found and parsed \'' + storageKey + '\', value:', parsedValue);
                                resolve(parsedValue);
                            } catch (e) {
                                Logger.debug('GM_getValue fallback: Found non-JSON \'' + storageKey + '\', value:', value);
                                resolve(value); // Return as string if not JSON
                            }
                        } else {
                            Logger.debug('GM_getValue fallback: Key \'' + storageKey + '\' not found, returning default:', defaultValue);
                            resolve(defaultValue);
                        }
                    } catch (error) {
                        Logger.error(error, 'Error getting value for key (GM_getValue fallback): ' + key);
                        resolve(defaultValue);
                    }
                });
            };
        }

        /**
         * Set up GM_setValue fallback using localStorage, returning a Promise.
         */
        static setupSetValue() {
            window.GM_setValue = function (key, value) {
                return new Promise((resolve, reject) => {
                    try {
                        const storageKey = `GM_${key}`;
                        Logger.debug('GM_setValue fallback: Attempting to set \'' + storageKey + '\' to:', value);
                        localStorage.setItem(storageKey, JSON.stringify(value));
                        resolve();
                    } catch (error) {
                        Logger.error(error, 'Error setting value for key (GM_setValue fallback): ' + key);
                        reject(error);
                    }
                });
            };
        }
    }

    // Initialize the fallbacks (this will populate window.GM_getValue etc.)
    // The initialize method also returns the map of functions.
    const gmFunctions = GMFunctions.initialize();

    // Export the functions for direct import, matching the names used in CountryFilter.js
    gmFunctions.GM_addStyle;
    gmFunctions.GM_xmlhttpRequest;
    const GM_setClipboard = gmFunctions.GM_setClipboard;
    gmFunctions.GM_download;
    const getValue = gmFunctions.GM_getValue; // Maps to getValue for import { getValue }
    const setValue = gmFunctions.GM_setValue; // Maps to setValue for import { setValue }

    // For potential direct class usage if ever needed, though current pattern is to use the initialized functions.
    // export default GMFunctions; // Not currently used this way

    /**
     * ViewportStabilizer - Handles scrolling elements into viewport and waiting for lazy-rendered content to stabilize
     * 
     * This utility is designed to work with modern web apps that use virtual scrolling or lazy rendering,
     * where content is only fully rendered when it comes into the viewport.
     * 
     * @example
     * const stabilizer = new ViewportStabilizer({
     *   scrollContainer: document.querySelector('.scrollable-container'), // or null for window
     *   stableDurationMs: 1000,
     *   checkIntervalMs: 150,
     *   maxWaitMs: 10000
     * });
     * 
     * const result = await stabilizer.scrollAndWaitForStable(element);
     * if (result.stable) {
     *   const text = element.textContent;
     * }
     */
    class ViewportStabilizer {
        /**
         * @param {Object} options Configuration options
         * @param {HTMLElement|null} options.scrollContainer - Container to scroll within (null = window/document)
         * @param {number} options.stableDurationMs - How long content must be stable before considering it ready (default: 1000ms)
         * @param {number} options.checkIntervalMs - How often to check for changes (default: 150ms)
         * @param {number} options.maxWaitMs - Maximum time to wait for stability (default: 10000ms)
         * @param {Function} options.elementValidator - Optional function to validate element before processing (element) => boolean
         * @param {Function} options.preScrollHook - Optional function called before scrolling (element) => Promise|void
         * @param {Function} options.postScrollHook - Optional function called after scrolling (element) => Promise|void
         * @param {Function} options.stabilityChecker - Optional custom stability checker (element) => boolean
         * @param {Object} options.scrollOptions - Options for scrollIntoView (default: { behavior: 'auto', block: 'center' })
         * @param {number} options.scrollDelayMs - Delay after scrolling before checking stability (default: 200ms)
         * @param {Object} options.logger - Optional logger instance (default: Logger)
         * @param {boolean} options.enableDebugLogging - Enable debug logging (default: false)
         */
        constructor(options = {}) {
            this.scrollContainer = options.scrollContainer || null;
            this.stableDurationMs = options.stableDurationMs || 1000;
            this.checkIntervalMs = options.checkIntervalMs || 150;
            this.maxWaitMs = options.maxWaitMs || 10000;
            this.elementValidator = options.elementValidator || null;
            this.preScrollHook = options.preScrollHook || null;
            this.postScrollHook = options.postScrollHook || null;
            this.stabilityChecker = options.stabilityChecker || null;
            this.scrollOptions = options.scrollOptions || { behavior: 'auto', block: 'center' };
            this.scrollDelayMs = options.scrollDelayMs || 200;
            this.logger = options.logger || Logger;
            this.enableDebugLogging = options.enableDebugLogging || false;
        }

        /**
         * Simple delay utility
         * @private
         */
        delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * Scroll element into view within the configured container
         * @private
         */
        scrollIntoView(element) {
            if (this.scrollContainer) {
                // Scroll within a specific container
                const containerRect = this.scrollContainer.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
                
                // Check if element is already in view
                const isInView = (
                    elementRect.top >= containerRect.top &&
                    elementRect.bottom <= containerRect.bottom &&
                    elementRect.left >= containerRect.left &&
                    elementRect.right <= containerRect.right
                );

                if (!isInView) {
                    // Calculate scroll position to center element in container
                    const scrollTop = this.scrollContainer.scrollTop + 
                        (elementRect.top - containerRect.top) - 
                        (containerRect.height / 2) + 
                        (elementRect.height / 2);
                    
                    this.scrollContainer.scrollTo({
                        top: scrollTop,
                        behavior: this.scrollOptions.behavior || 'auto'
                    });
                }
            } else {
                // Use standard scrollIntoView for window/document
                element.scrollIntoView(this.scrollOptions);
            }
        }

        /**
         * Wait for element height and text to stabilize
         * @private
         */
        async waitForStability(element) {
            if (!element || !element.isConnected) {
                return { stable: false, reason: 'Element not connected' };
            }

            // Use custom stability checker if provided
            if (this.stabilityChecker) {
                const isStable = await this.stabilityChecker(element);
                return { stable: isStable, reason: isStable ? 'Custom checker passed' : 'Custom checker failed' };
            }

            let lastHeight = element.offsetHeight || element.scrollHeight || 0;
            let lastTextLength = (element.textContent || '').length;
            let stableStartTime = Date.now();
            const startTime = Date.now();

            if (this.enableDebugLogging) {
                this.logger.debug(`Waiting for element height to stabilize (current: ${lastHeight}px, text: ${lastTextLength} chars)...`);
            }

            while (Date.now() - startTime < this.maxWaitMs) {
                if (!element.isConnected) {
                    if (this.enableDebugLogging) {
                        this.logger.debug('Element disconnected while waiting for height stability');
                    }
                    return { stable: false, reason: 'Element disconnected' };
                }

                const currentHeight = element.offsetHeight || element.scrollHeight || 0;
                const currentTextLength = (element.textContent || '').length;

                const heightChanged = currentHeight !== lastHeight;
                const textChanged = currentTextLength !== lastTextLength;

                if (heightChanged || textChanged) {
                    // Height or text changed, reset stability timer
                    if (heightChanged) {
                        lastHeight = currentHeight;
                        if (this.enableDebugLogging) {
                            this.logger.debug(`Height changed to ${currentHeight}px, resetting stability timer`);
                        }
                    }
                    if (textChanged) {
                        lastTextLength = currentTextLength;
                        if (this.enableDebugLogging) {
                            this.logger.debug(`Text length changed to ${currentTextLength} chars, resetting stability timer`);
                        }
                    }
                    stableStartTime = Date.now();
                } else {
                    // Both height and text are stable, check if it's been stable long enough
                    const stableDuration = Date.now() - stableStartTime;
                    if (stableDuration >= this.stableDurationMs) {
                        if (this.enableDebugLogging) {
                            this.logger.debug(`Height (${currentHeight}px) and text (${currentTextLength} chars) stable for ${stableDuration}ms`);
                        }
                        return { 
                            stable: true, 
                            reason: 'Height and text stable',
                            finalHeight: currentHeight,
                            finalTextLength: currentTextLength
                        };
                    }
                }

                await this.delay(this.checkIntervalMs);
            }

            if (this.enableDebugLogging) {
                this.logger.debug(`Height stability timeout reached (final height: ${lastHeight}px, text: ${lastTextLength} chars)`);
            }
            // Return true even if timeout, to not block forever
            return { 
                stable: true, 
                reason: 'Timeout reached but continuing',
                finalHeight: lastHeight,
                finalTextLength: lastTextLength
            };
        }

        /**
         * Scroll element into view and wait for it to stabilize
         * 
         * @param {HTMLElement} element - Element to scroll and wait for
         * @param {Object} options - Optional overrides for this specific call
         * @returns {Promise<Object>} Result object with { stable: boolean, reason: string, ... }
         */
        async scrollAndWaitForStable(element, options = {}) {
            // Validate element
            if (!element || !(element instanceof HTMLElement)) {
                return { stable: false, reason: 'Invalid element' };
            }

            // Use custom validator if provided
            if (this.elementValidator) {
                const isValid = await this.elementValidator(element);
                if (!isValid) {
                    return { stable: false, reason: 'Element failed validation' };
                }
            }

            // Pre-scroll hook
            if (this.preScrollHook) {
                await this.preScrollHook(element);
            }

            // Scroll into view
            this.scrollIntoView(element);

            // Wait for scroll to start
            const scrollDelay = options.scrollDelayMs !== undefined ? options.scrollDelayMs : this.scrollDelayMs;
            await this.delay(scrollDelay);

            // Post-scroll hook
            if (this.postScrollHook) {
                await this.postScrollHook(element);
            }

            // Re-validate element after scrolling (DOM may have changed)
            if (this.elementValidator) {
                const isValid = await this.elementValidator(element);
                if (!isValid) {
                    return { stable: false, reason: 'Element failed validation after scroll' };
                }
            }

            // Wait for stability
            const stabilityResult = await this.waitForStability(element);
            return stabilityResult;
        }

        /**
         * Process multiple elements sequentially, scrolling each into view and waiting for stability
         * 
         * @param {Array<HTMLElement>} elements - Array of elements to process
         * @param {Function} processor - Function to process each element after it's stable (element, index, result) => any
         * @param {Object} options - Optional processing options
         * @param {Function} options.onProgress - Callback for progress updates (index, total, element) => void
         * @param {Function} options.onError - Callback for errors (error, element, index) => void
         * @returns {Promise<Array>} Array of results from processor function
         */
        async processElements(elements, processor, options = {}) {
            const results = [];
            const onProgress = options.onProgress || null;
            const onError = options.onError || null;

            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];

                try {
                    if (onProgress) {
                        onProgress(i, elements.length, element);
                    }

                    const stabilityResult = await this.scrollAndWaitForStable(element);

                    if (!stabilityResult.stable) {
                        if (this.enableDebugLogging) {
                            this.logger.warn(`Element ${i + 1}/${elements.length} did not stabilize: ${stabilityResult.reason}`);
                        }
                        // Continue anyway, let processor decide what to do
                    }

                    const result = await processor(element, i, stabilityResult);
                    results.push(result);
                } catch (error) {
                    if (onError) {
                        onError(error, element, i);
                    } else {
                        this.logger.error(`Error processing element ${i + 1}/${elements.length}:`, error);
                    }
                    results.push(null);
                }
            }

            return results;
        }
    }

    class ClipboardService {
        constructor() {
            this.logger = Logger.newPrefix('ClipboardService');
        }

        /**
         * Copy to clipboard with fallbacks
         * @param {string} content - The content to copy
         * @returns {Promise<boolean>} - True if successful, false otherwise
         */
        async copyToClipboard(content) {
            if (!content) {
                this.logger.warn('No content to copy');
                return false;
            }

            this.logger.debug(`Attempting to copy ${content.length} characters to clipboard`);

            try {
                if (typeof GM_setClipboard !== 'undefined') {
                    GM_setClipboard(content);
                    this.logger.debug('✅ GM_setClipboard succeeded');
                    return true;
                }
            } catch (error) {
                this.logger.warn('⚠ GM_setClipboard failed:', error);
            }

            try {
                await navigator.clipboard.writeText(content);
                this.logger.debug('✅ Clipboard API succeeded');
                return true;
            } catch (error) {
                this.logger.warn('⚠ Clipboard API failed:', error);
            }

            const textarea = document.createElement('textarea');
            textarea.value = content;
            Object.assign(textarea.style, {
                position: 'fixed',
                top: '-9999px',
                left: '-9999px',
                opacity: '0',
                pointerEvents: 'none'
            });

            document.body.appendChild(textarea);

            try {
                textarea.select();
                textarea.setSelectionRange(0, content.length);
                const success = document.execCommand('copy');

                if (success) {
                    document.body.removeChild(textarea);
                    this.logger.debug('✅ execCommand succeeded');
                    return true;
                }
            } catch (error) {
                this.logger.warn('⚠ execCommand failed:', error);
            }

            try {
                this.logger.debug('Trying designMode hack...');
                document.designMode = 'on';

                const selection = window.getSelection();
                selection.removeAllRanges();

                const range = document.createRange();
                range.selectNodeContents(textarea);
                selection.addRange(range);

                const success = document.execCommand('copy');

                document.designMode = 'off';
                selection.removeAllRanges();

                if (success) {
                    document.body.removeChild(textarea);
                    this.logger.debug('✅ designMode hack succeeded');
                    return true;
                }
            } catch (error) {
                this.logger.warn('⚠ designMode hack failed:', error);
                document.designMode = 'off';
            }

            try {
                this.logger.warn('All automatic copy methods failed. Showing manual copy prompt...');
                window.prompt('All automatic copy methods failed. Please copy manually:', content);
                this.logger.debug('Manual copy prompt shown');
                return false;
            } catch (error) {
                this.logger.error('Even manual copy prompt failed:', error);
            } finally {
                if (textarea.parentNode) {
                    document.body.removeChild(textarea);
                }
            }

            return false;
        }
    }

    var ClipboardService$1 = new ClipboardService();

    /**
     * Button - A reusable UI component for buttons.
     * Creates customizable, accessible buttons with various states and callbacks.
     */

    /**
     * A reusable UI component for creating accessible, customizable buttons.
     */
    class Button {
      /**
         * Returns the unique base CSS class for the Button component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for buttons.
         */
      static get BASE_BUTTON_CLASS() {
        return 'userscripts-button';
      }
      /**
         * Returns the CSS variable prefix used for theming and styling the Button component.
         * This prefix scopes all custom CSS variables (e.g., colors, borders) related to the button.
         *
         * @return {string} The CSS variable prefix.
         */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-button-';
      }
      /**
         * Initialize styles for all buttons.
         * These styles reference the CSS variables with our defined prefix.
         */
      static initStyles() {
        if (Button.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts Button Component */
      .${Button.BASE_BUTTON_CLASS} {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-family: inherit;
        font-weight: 500;
        border-radius: 0.375rem;
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.15s ease-in-out;
        text-align: center;
        background-color: var(${Button.CSS_VAR_PREFIX}bg);
        color: var(${Button.CSS_VAR_PREFIX}color);
        border-color: var(${Button.CSS_VAR_PREFIX}border);
      }
      
      /* Button sizes */
      .${Button.BASE_BUTTON_CLASS}--small {
        font-size: 0.75rem;
        padding: 0.25rem 0.5rem;
        min-height: 1.75rem;
      }
      .${Button.BASE_BUTTON_CLASS}--medium {
        font-size: 0.875rem;
        padding: 0.5rem 1rem;
        min-height: 2.25rem;
      }
      .${Button.BASE_BUTTON_CLASS}--large {
        font-size: 1rem;
        padding: 0.75rem 1.5rem;
        min-height: 2.75rem;
      }
      
      /* Button themes using CSS variables */
      .${Button.BASE_BUTTON_CLASS}--default {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-default);
        color: var(${Button.CSS_VAR_PREFIX}color-default);
        border-color: var(${Button.CSS_VAR_PREFIX}border-default);
      }
      .${Button.BASE_BUTTON_CLASS}--default:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-default-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--primary {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-primary);
        color: var(${Button.CSS_VAR_PREFIX}color-primary);
        border-color: var(${Button.CSS_VAR_PREFIX}border-primary);
      }
      .${Button.BASE_BUTTON_CLASS}--primary:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-primary-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-primary-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--secondary {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-secondary);
        color: var(${Button.CSS_VAR_PREFIX}color-secondary);
        border-color: var(${Button.CSS_VAR_PREFIX}border-secondary);
      }
      .${Button.BASE_BUTTON_CLASS}--secondary:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-secondary-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-secondary-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--success {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-success);
        color: var(${Button.CSS_VAR_PREFIX}color-success);
        border-color: var(${Button.CSS_VAR_PREFIX}border-success);
      }
      .${Button.BASE_BUTTON_CLASS}--success:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-success-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-success-hover);
      }
      
      .${Button.BASE_BUTTON_CLASS}--danger {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-danger);
        color: var(${Button.CSS_VAR_PREFIX}color-danger);
        border-color: var(${Button.CSS_VAR_PREFIX}border-danger);
      }
      .${Button.BASE_BUTTON_CLASS}--danger:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-danger-hover);
        border-color: var(${Button.CSS_VAR_PREFIX}border-danger-hover);
      }
      
      /* Generic state styles */
      .${Button.BASE_BUTTON_CLASS}:disabled {
        opacity: 0.65;
        cursor: not-allowed;
        pointer-events: none;
      }
      .${Button.BASE_BUTTON_CLASS}:focus {
        outline: none;
        box-shadow: 0 0 0 3px var(${Button.CSS_VAR_PREFIX}focus-shadow);
      }
      
      /* Generic pseudo-class rules */
      .${Button.BASE_BUTTON_CLASS}:hover:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-hover);
      }
      .${Button.BASE_BUTTON_CLASS}:active:not(:disabled) {
        background-color: var(${Button.CSS_VAR_PREFIX}bg-active);
      }
      
      /* Button content */
      .${Button.BASE_BUTTON_CLASS}__icon {
        display: inline-flex;
        margin-right: 0.5rem;
      }
      .${Button.BASE_BUTTON_CLASS}__text {
        display: inline-block;
      }
    `, 'userscripts-button-styles');

        Button.stylesInitialized = true;
      }
      /**
         * Inject default color variables for the button component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
      static useDefaultColors() {
        const styleId = 'userscripts-button-default-colors';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          HTMLUtils.setHTMLSafely(style, `
        :root {
          ${Button.CSS_VAR_PREFIX}bg-default: #f3f4f6;
          ${Button.CSS_VAR_PREFIX}color-default: #374151;
          ${Button.CSS_VAR_PREFIX}border-default: #d1d5db;
          ${Button.CSS_VAR_PREFIX}bg-default-hover: #e5e7eb;
          
          ${Button.CSS_VAR_PREFIX}bg-primary: #3b82f6;
          ${Button.CSS_VAR_PREFIX}color-primary: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-primary: #3b82f6;
          ${Button.CSS_VAR_PREFIX}bg-primary-hover: #2563eb;
          ${Button.CSS_VAR_PREFIX}border-primary-hover: #2563eb;
          
          ${Button.CSS_VAR_PREFIX}bg-secondary: #6b7280;
          ${Button.CSS_VAR_PREFIX}color-secondary: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-secondary: #6b7280;
          ${Button.CSS_VAR_PREFIX}bg-secondary-hover: #4b5563;
          ${Button.CSS_VAR_PREFIX}border-secondary-hover: #4b5563;
          
          ${Button.CSS_VAR_PREFIX}bg-success: #10b981;
          ${Button.CSS_VAR_PREFIX}color-success: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-success: #10b981;
          ${Button.CSS_VAR_PREFIX}bg-success-hover: #059669;
          ${Button.CSS_VAR_PREFIX}border-success-hover: #059669;
          
          ${Button.CSS_VAR_PREFIX}bg-danger: #ef4444;
          ${Button.CSS_VAR_PREFIX}color-danger: #ffffff;
          ${Button.CSS_VAR_PREFIX}border-danger: #ef4444;
          ${Button.CSS_VAR_PREFIX}bg-danger-hover: #dc2626;
          ${Button.CSS_VAR_PREFIX}border-danger-hover: #dc2626;
          
          ${Button.CSS_VAR_PREFIX}bg-hover: #e0e0e0;
          ${Button.CSS_VAR_PREFIX}bg-active: #d0d0d0;
          
          ${Button.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.3);
        }

        @media (prefers-color-scheme: dark) {
          :root {
            ${Button.CSS_VAR_PREFIX}bg-default: #4a4a4a;
            ${Button.CSS_VAR_PREFIX}color-default: #e0e0e0;
            ${Button.CSS_VAR_PREFIX}border-default: #6b7280;
            ${Button.CSS_VAR_PREFIX}bg-default-hover: #5a5a5a;

            ${Button.CSS_VAR_PREFIX}bg-primary: #3b82f6;
            ${Button.CSS_VAR_PREFIX}color-primary: #ffffff;
            ${Button.CSS_VAR_PREFIX}border-primary: #3b82f6;
            ${Button.CSS_VAR_PREFIX}bg-primary-hover: #2563eb;
            ${Button.CSS_VAR_PREFIX}border-primary-hover: #2563eb;

            ${Button.CSS_VAR_PREFIX}bg-secondary: #6b7280;
            ${Button.CSS_VAR_PREFIX}color-secondary: #ffffff;
            ${Button.CSS_VAR_PREFIX}border-secondary: #6b7280;
            ${Button.CSS_VAR_PREFIX}bg-secondary-hover: #5a6268;
            ${Button.CSS_VAR_PREFIX}border-secondary-hover: #5a6268;

            ${Button.CSS_VAR_PREFIX}bg-success: #10b981;
            ${Button.CSS_VAR_PREFIX}color-success: #ffffff;
            ${Button.CSS_VAR_PREFIX}border-success: #10b981;
            ${Button.CSS_VAR_PREFIX}bg-success-hover: #059669;
            ${Button.CSS_VAR_PREFIX}border-success-hover: #059669;

            ${Button.CSS_VAR_PREFIX}bg-danger: #ef4444;
            ${Button.CSS_VAR_PREFIX}color-danger: #ffffff;
            ${Button.CSS_VAR_PREFIX}border-danger: #ef4444;
            ${Button.CSS_VAR_PREFIX}bg-danger-hover: #dc2626;
            ${Button.CSS_VAR_PREFIX}border-danger-hover: #dc2626;
            
            ${Button.CSS_VAR_PREFIX}bg-hover: #555;
            ${Button.CSS_VAR_PREFIX}bg-active: #666;

            ${Button.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.4);
          }
        }
      `);
          document.head.appendChild(style);
        }
      }
      /**
         * Create a new Button.
         * @param {Object} options - Configuration options.
         * @param {String} options.text - Button text.
         * @param {String} [options.type="button"] - Button type.
         * @param {String} [options.className] - Additional custom CSS class.
         * @param {Function} options.onClick - Click event handler.
         * @param {String} [options.id] - Button ID.
         * @param {HTMLElement} [options.container] - Container to append the button to.
         * @param {Object} [options.attributes={}] - Additional HTML attributes.
         * @param {String} [options.theme="default"] - Button theme.
         * @param {String} [options.size="medium"] - Button size.
         * @param {Boolean} [options.disabled=false] - Disabled state.
         * @param {String} [options.icon] - Optional icon HTML.
         * @param {String} [options.successText] - Success state text.
         * @param {Number} [options.successDuration=1500] - Success state duration (ms).
         */
      constructor(options) {
        this.text = options.text || '';
        this.type = options.type || 'button';
        this.customClassName = options.className || '';
        this.onClick = options.onClick;
        this.id = options.id;
        this.container = options.container;
        this.attributes = options.attributes || {};
        this.theme = options.theme;
        this.size = options.size || 'medium';
        this.disabled = options.disabled || false;
        this.icon = options.icon || null;
        this.successText = options.successText || null;
        this.successDuration = options.successDuration || 1500;
        this.originalText = this.text;

        // These properties will refer to the DOM elements.
        this.button = null;
        this.textElement = null;

        Button.initStyles();
        this.create();
      }


      /**
         * Create the button element and, if a container is provided, append it.
         * @return {HTMLButtonElement} The created button element.
         */
      create() {
        this.button = document.createElement('button');
        this.button.type = this.type;
        this.button.disabled = this.disabled;
        if (this.id) this.button.id = this.id;
        this.button._buttonInstance = this;
        this.updateButtonClasses();
        this.updateContent();
        if (this.onClick) this.button.addEventListener('click', (e) => this.handleClick(e));
        Object.entries(this.attributes).forEach(([key, value]) => {
          this.button.setAttribute(key, value);
        });
        if (this.container) this.container.appendChild(this.button);
        return this.button;
      }

      /**
         * Update the classes on the button element based on theme, size, and custom classes.
         */
      updateButtonClasses() {
        const classNames = [Button.BASE_BUTTON_CLASS];
        classNames.push(`${Button.BASE_BUTTON_CLASS}--${this.theme}`);
        classNames.push(`${Button.BASE_BUTTON_CLASS}--${this.size}`);
        if (this.customClassName) classNames.push(this.customClassName);
        this.button.className = classNames.join(' ');
      }

      /**
         * Update the button content (icon and text).
         */
      updateContent() {
        // Clear existing content using DOM methods instead of innerHTML
        while (this.button.firstChild) {
          this.button.removeChild(this.button.firstChild);
        }
        
        if (this.icon) {
          const iconSpan = document.createElement('span');
          iconSpan.className = `${Button.BASE_BUTTON_CLASS}__icon`;
          HTMLUtils.setHTMLSafely(iconSpan, this.icon);
          this.button.appendChild(iconSpan);
        }
        this.textElement = document.createElement('span');
        this.textElement.className = `${Button.BASE_BUTTON_CLASS}__text`;
        this.textElement.textContent = this.text;
        this.button.appendChild(this.textElement);
      }

      /**
         * Handle click events on the button.
         * @param {Event} e - The click event.
         */
      handleClick(e) {
        if (this.disabled) return;
        const result = this.onClick(e);
        if (this.successText && false !== result) {
          this.showSuccessState();
        }
      }

      /**
         * Show a success state by temporarily changing the button's text and theme.
         */
      showSuccessState() {
        const originalText = this.text;
        const originalTheme = this.theme;
        this.setText(this.successText);
        this.setTheme('success');
        setTimeout(() => {
          this.setText(originalText);
          this.setTheme(originalTheme);
        }, this.successDuration);
      }

      /**
         * Set the button's text.
         * @param {String} text - The new text to display.
         */
      setText(text) {
        this.text = text;
        if (this.textElement) {
          this.textElement.textContent = text;
        } else {
          this.updateContent();
        }
      }

      /**
         * Reset the button's text to its original value.
         */
      resetText() {
        this.setText(this.originalText);
      }

      /**
         * Set an icon for the button.
         * @param {String} iconHtml - The HTML string for the icon.
         */
      setIcon(iconHtml) {
        this.icon = iconHtml;
        this.updateContent();
      }

      /**
         * Enable or disable the button.
         * @param {Boolean} disabled - Whether the button should be disabled.
         */
      setDisabled(disabled) {
        this.disabled = disabled;
        this.button.disabled = disabled;
      }

      /**
         * Toggle the disabled state of the button.
         * @return {Boolean} The new disabled state.
         */
      toggleDisabled() {
        this.setDisabled(!this.disabled);
        return this.disabled;
      }

      /**
         * Change the button's theme.
         * @param {String} theme - The new theme (e.g., "default", "primary", etc.).
         */
      setTheme(theme) {
        this.button.classList.remove(`${Button.BASE_BUTTON_CLASS}--${this.theme}`);
        this.theme = theme;
        this.button.classList.add(`${Button.BASE_BUTTON_CLASS}--${this.theme}`);
      }

      /**
         * Change the button's size.
         * @param {String} size - The new size (e.g., "small", "medium", "large").
         */
      setSize(size) {
        this.button.classList.remove(`${Button.BASE_BUTTON_CLASS}--${this.size}`);
        this.size = size;
        this.button.classList.add(`${Button.BASE_BUTTON_CLASS}--${this.size}`);
      }

      /**
         * Apply a custom CSS class to the button.
         * @param {String} className - The custom class name.
         */
      setCustomClass(className) {
        if (this.customClassName) {
          this.button.classList.remove(this.customClassName);
        }
        this.customClassName = className;
        if (className) {
          this.button.classList.add(className);
        }
      }
    }

    // Static property to track if styles have been initialized.
    Button.stylesInitialized = false;
    Button.initStyles();

    /**
     * Enhanced version of the ProgressBar core component with Eksi-style UI
     * This replaces the existing ProgressBar.js file in the core/ui directory
     */

    class ProgressBar {
      /**
         * Returns the unique base CSS class for the ProgressBar component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for progress bars.
         */
      static get BASE_PROGRESS_CLASS() {
        return 'userscripts-progress';
      }
      /**
         * Returns the CSS variable prefix used for theming the ProgressBar component.
         * This prefix scopes all custom CSS variables (e.g., colors) related to the progress bar.
         *
         * @return {string} The CSS variable prefix.
         */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-progress-';
      }
      /**
         * Initialize styles for all progress bars.
         * These styles reference the CSS variables with our defined prefix.
         */
      static initStyles() {
        if (ProgressBar.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts ProgressBar Component */
      .${ProgressBar.BASE_PROGRESS_CLASS} {
        width: 100%;
        margin: 10px 0;
        position: relative;
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-label {
        font-size: 0.875rem;
        margin-bottom: 4px;
        display: block;
        color: var(${ProgressBar.CSS_VAR_PREFIX}label-color, #555);
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-bar {
        height: 20px;
        background-color: var(${ProgressBar.CSS_VAR_PREFIX}bar-bg, #f3f3f3);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        height: 100%;
        width: 0%;
        border-radius: 10px;
        transition: width 0.5s ease;
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}fill-bg)), 
          var(${ProgressBar.CSS_VAR_PREFIX}fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}fill-bg))
        );
        position: relative;
        overflow: hidden;
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-fill::after {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.1) 25%,
          transparent 25%,
          transparent 50%,
          rgba(255, 255, 255, 0.1) 50%,
          rgba(255, 255, 255, 0.1) 75%,
          transparent 75%,
          transparent 100%
        );
        background-size: 30px 30px;
        animation: ${ProgressBar.BASE_PROGRESS_CLASS}-stripes 1s linear infinite;
      }
      
      @keyframes ${ProgressBar.BASE_PROGRESS_CLASS}-stripes {
        0% {
          background-position: 0 0;
        }
        100% {
          background-position: 30px 0;
        }
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}-text {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 10px;
        font-size: 0.75rem;
        color: var(${ProgressBar.CSS_VAR_PREFIX}text-color, #333);
        font-weight: bold;
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
        z-index: 1;
      }
      
      /* Themes */
      .${ProgressBar.BASE_PROGRESS_CLASS}--default .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}default-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}default-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--primary .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}primary-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--success .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}success-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}success-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--danger .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}danger-fill-bg))
        );
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--warning .${ProgressBar.BASE_PROGRESS_CLASS}-fill {
        background: linear-gradient(90deg, 
          var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-start, var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-bg)),
          var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-end, var(${ProgressBar.CSS_VAR_PREFIX}warning-fill-bg))
        );
      }
      
      /* Sizes */
      .${ProgressBar.BASE_PROGRESS_CLASS}--small .${ProgressBar.BASE_PROGRESS_CLASS}-bar {
        height: 8px;
      }
      
      .${ProgressBar.BASE_PROGRESS_CLASS}--large .${ProgressBar.BASE_PROGRESS_CLASS}-bar {
        height: 24px;
      }
    `, 'userscripts-progress-styles');
        ProgressBar.stylesInitialized = true;
      }
      /**
         * Injects default color variables for the ProgressBar component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
      static useDefaultColors() {
        const styleId = 'userscripts-progress-default-colors';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          style.innerHTML = `
        :root {
          /* Base colors */
          ${ProgressBar.CSS_VAR_PREFIX}label-color: #555;
          ${ProgressBar.CSS_VAR_PREFIX}bar-bg: #f3f3f3;
          ${ProgressBar.CSS_VAR_PREFIX}fill-bg: #6b7280;
          ${ProgressBar.CSS_VAR_PREFIX}text-color: #333;
          
          /* Theme colors with gradients */
          ${ProgressBar.CSS_VAR_PREFIX}default-fill-bg: #6b7280;
          ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-start: #6b7280;
          ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-end: #4b5563;
          
          ${ProgressBar.CSS_VAR_PREFIX}primary-fill-bg: #3b82f6;
          ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-start: #3b82f6;
          ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-end: #2563eb;
          
          ${ProgressBar.CSS_VAR_PREFIX}success-fill-bg: #10b981;
          ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-start: #10b981;
          ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-end: #059669;
          
          ${ProgressBar.CSS_VAR_PREFIX}danger-fill-bg: #ef4444;
          ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-start: #ef4444;
          ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-end: #dc2626;
          
          ${ProgressBar.CSS_VAR_PREFIX}warning-fill-bg: #f59e0b;
          ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-start: #f59e0b;
          ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-end: #d97706;
        }

        @media (prefers-color-scheme: dark) {
          :root {
            /* Base colors */
            ${ProgressBar.CSS_VAR_PREFIX}label-color: #e0e0e0;
            ${ProgressBar.CSS_VAR_PREFIX}bar-bg: #2d2d2d;
            ${ProgressBar.CSS_VAR_PREFIX}text-color: #ffffff;
            
            /* Theme colors with gradients */
            ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-start: #6b7280;
            ${ProgressBar.CSS_VAR_PREFIX}default-fill-gradient-end: #4b5563;
            
            ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-start: #3b82f6;
            ${ProgressBar.CSS_VAR_PREFIX}primary-fill-gradient-end: #2563eb;
            
            ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-start: #10b981;
            ${ProgressBar.CSS_VAR_PREFIX}success-fill-gradient-end: #059669;
            
            ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-start: #ef4444;
            ${ProgressBar.CSS_VAR_PREFIX}danger-fill-gradient-end: #dc2626;
            
            ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-start: #f59e0b;
            ${ProgressBar.CSS_VAR_PREFIX}warning-fill-gradient-end: #d97706;
          }
        }
      `;
          document.head.appendChild(style);
        }
      }
      /**
         * Create a new progress bar.
         * @param {Object} options - Configuration options.
         * @param {number} options.initialValue - Initial progress value (0-100).
         * @param {string} [options.className='userscripts-progress'] - CSS class for styling.
         * @param {HTMLElement} options.container - Container element to which the progress bar will be appended.
         * @param {boolean} [options.showText=true] - Whether to display the progress text.
         * @param {boolean} [options.showLabel=false] - Whether to display a label above the progress bar.
         * @param {string} [options.label=''] - Label text to display if showLabel is true.
         * @param {string} [options.theme='default'] - Theme for the progress bar (e.g., "default", "primary", "success").
         * @param {string} [options.size='normal'] - Size of the progress bar ('small', 'normal', 'large').
         */
      constructor(options) {
        this.value = options.initialValue || 0;
        this.className = options.className || ProgressBar.BASE_PROGRESS_CLASS;
        this.container = options.container;
        this.showText = options.showText !== undefined ? options.showText : true;
        this.showLabel = options.showLabel || false;
        this.label = options.label || '';
        this.theme = options.theme || 'default';
        this.size = options.size || 'normal';

        this.progressElement = null;
        this.progressBarElement = null;
        this.progressFillElement = null;
        this.progressTextElement = null;
        this.labelElement = null;

        ProgressBar.initStyles();
        this.create();
      }


      /**
         * Creates the progress bar elements and appends them to the container if provided.
         * @return {HTMLElement} The created progress bar container element.
         */
      create() {
        // Create the progress bar container
        this.progressElement = document.createElement('div');
        this.progressElement.className = `${this.className} ${this.className}--${this.theme}`;

        if ('normal' !== this.size) {
          this.progressElement.classList.add(`${this.className}--${this.size}`);
        }

        // Add a label if requested
        if (this.showLabel) {
          this.labelElement = document.createElement('span');
          this.labelElement.className = `${this.className}-label`;
          this.labelElement.textContent = this.label;
          this.progressElement.appendChild(this.labelElement);
        }

        // Create the progress bar and its fill
        this.progressBarElement = document.createElement('div');
        this.progressBarElement.className = `${this.className}-bar`;

        this.progressFillElement = document.createElement('div');
        this.progressFillElement.className = `${this.className}-fill`;
        this.progressFillElement.style.width = `${this.value}%`;

        this.progressBarElement.appendChild(this.progressFillElement);
        this.progressElement.appendChild(this.progressBarElement);

        // Add progress text as absolute positioned element
        if (this.showText) {
          this.progressTextElement = document.createElement('div');
          this.progressTextElement.className = `${this.className}-text`;
          this.progressTextElement.textContent = `${this.value}%`;
          this.progressBarElement.appendChild(this.progressTextElement);
        }

        // Append the entire progress element to the container, if one was provided
        if (this.container) {
          this.container.appendChild(this.progressElement);
        }
        return this.progressElement;
      }

      /**
         * Updates the progress value and (optionally) the display text.
         * @param {number} value - The new progress value (between 0 and 100).
         * @param {string} [text] - Optional custom text to display.
         * @return {number} The updated progress value.
         */
      setValue(value, text) {
        this.value = Math.min(100, Math.max(0, value));
        if (this.progressFillElement) {
          this.progressFillElement.style.width = `${this.value}%`;
        }
        if (this.showText && this.progressTextElement) {
          this.progressTextElement.textContent = text || `${this.value}%`;
        }
        return this.value;
      }

      /**
         * Changes the progress bar theme by updating the theme class.
         * @param {string} theme - The new theme (e.g., "default", "primary", "success", etc.).
         */
      setTheme(theme) {
        this.theme = theme;
        if (this.progressElement) {
          // Remove any existing theme class (assumed to be in the format `${this.className}--<theme>`)
          const classes = this.progressElement.className.split(' ');
          const nonThemeClasses = classes.filter((cls) =>
            !cls.startsWith(`${this.className}--`) ||
                    cls === `${this.className}--${this.size}`, // Keep size class
          );
          this.progressElement.className = `${nonThemeClasses.join(' ')} ${this.className}--${this.theme}`;
        }
      }

      /**
         * Changes the progress bar size.
         * @param {string} size - The new size ('small', 'normal', 'large').
         */
      setSize(size) {
        this.size = size;
        if (this.progressElement) {
          // Remove size classes
          this.progressElement.classList.remove(`${this.className}--small`);
          this.progressElement.classList.remove(`${this.className}--large`);

          // Add new size class if not normal
          if ('normal' !== size) {
            this.progressElement.classList.add(`${this.className}--${size}`);
          }
        }
      }

      /**
         * Sets the label text for the progress bar.
         * @param {string} label - The new label text.
         */
      setLabel(label) {
        this.label = label;
        if (this.labelElement) {
          this.labelElement.textContent = label;
        }
      }

      /**
         * Shows or hides the entire progress bar.
         * @param {boolean} visible - True to show, false to hide.
         */
      setVisible(visible) {
        if (this.progressElement) {
          this.progressElement.style.display = visible ? '' : 'none';
        }
      }

      /**
         * Destroys the progress bar and removes it from the DOM.
         */
      destroy() {
        if (this.progressElement && this.progressElement.parentNode) {
          this.progressElement.parentNode.removeChild(this.progressElement);
        }
        this.progressElement = null;
        this.progressBarElement = null;
        this.progressFillElement = null;
        this.progressTextElement = null;
        this.labelElement = null;
      }
    }

    // Static property to track if styles have been initialized.
    ProgressBar.stylesInitialized = false;

    // Initialize styles when imported.
    ProgressBar.initStyles();

    /**
     * Checkbox - A reusable UI component for checkboxes.
     * Creates customizable, accessible checkboxes with various states and callbacks.
     */

    /**
     * A reusable UI component for creating accessible, customizable checkboxes.
     */
    class Checkbox {
      /**
         * Returns the unique base CSS class for the Checkbox component.
         * This class is used as the root for all styling and helps prevent CSS collisions.
         *
         * @return {string} The base CSS class name for checkboxes.
         */
      static get BASE_CHECKBOX_CLASS() {
        return 'userscripts-checkbox';
      }
      /**
         * Returns the CSS variable prefix used for theming and styling the Checkbox component.
         * This prefix scopes all custom CSS variables (e.g., colors, borders) related to the checkbox.
         *
         * @return {string} The CSS variable prefix.
         */
      static get CSS_VAR_PREFIX() {
        return '--userscripts-checkbox-';
      }
      /**
         * Initialize styles for all checkboxes.
         * These styles reference the CSS variables with our defined prefix.
         */
      static initStyles() {
        if (Checkbox.stylesInitialized) return;
        StyleManager.addStyles(`
      /* Scoped styles for Userscripts Checkbox Component */
      .${Checkbox.BASE_CHECKBOX_CLASS}-container {
        display: inline-flex;
        align-items: center;
        position: relative;
        cursor: pointer;
        user-select: none;
        font-family: inherit;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled {
        opacity: 0.65;
        cursor: not-allowed;
      }
      
      /* Hide native checkbox */
      .${Checkbox.BASE_CHECKBOX_CLASS}-native {
        position: absolute;
        opacity: 0;
        height: 0;
        width: 0;
      }
      
      /* Custom checkbox appearance */
      .${Checkbox.BASE_CHECKBOX_CLASS} {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 1.25rem;
        height: 1.25rem;
        border-radius: 0.25rem;
        border: 2px solid var(${Checkbox.CSS_VAR_PREFIX}border-color);
        background-color: var(${Checkbox.CSS_VAR_PREFIX}bg);
        transition: all 0.2s ease;
        position: relative;
      }
      
      /* Check mark (initially hidden) */
      .${Checkbox.BASE_CHECKBOX_CLASS}::after {
        content: '';
        position: absolute;
        opacity: 0;
        transform: rotate(45deg) scale(0);
        width: 0.3125rem;
        height: 0.625rem;
        border-right: 2px solid var(${Checkbox.CSS_VAR_PREFIX}checkmark-color);
        border-bottom: 2px solid var(${Checkbox.CSS_VAR_PREFIX}checkmark-color);
        transition: all 0.2s ease;
      }
      
      /* When checkbox is checked */
      .${Checkbox.BASE_CHECKBOX_CLASS}--checked {
        background-color: var(${Checkbox.CSS_VAR_PREFIX}checked-bg);
        border-color: var(${Checkbox.CSS_VAR_PREFIX}checked-border);
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--checked::after {
        opacity: 1;
        transform: rotate(45deg) scale(1);
      }
      
      /* Indeterminate state */
      .${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate::after {
        opacity: 1;
        transform: rotate(0) scale(1);
        width: 0.625rem;
        height: 0.125rem;
        border-right: none;
        border-bottom: 2px solid var(${Checkbox.CSS_VAR_PREFIX}checkmark-color);
      }
      
      /* On hover */
      .${Checkbox.BASE_CHECKBOX_CLASS}-container:hover .${Checkbox.BASE_CHECKBOX_CLASS}:not(.${Checkbox.BASE_CHECKBOX_CLASS}--checked):not(.${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate) {
        border-color: var(${Checkbox.CSS_VAR_PREFIX}hover-border);
        background-color: var(${Checkbox.CSS_VAR_PREFIX}hover-bg);
      }
      
      /* On focus */
      .${Checkbox.BASE_CHECKBOX_CLASS}-container:focus-within .${Checkbox.BASE_CHECKBOX_CLASS} {
        box-shadow: 0 0 0 3px var(${Checkbox.CSS_VAR_PREFIX}focus-shadow);
      }
      
      /* Label styles */
      .${Checkbox.BASE_CHECKBOX_CLASS}-label {
        margin-left: 0.5rem;
        font-size: 0.875rem;
      }
      
      /* Checkbox sizes */
      .${Checkbox.BASE_CHECKBOX_CLASS}--small {
        width: 1rem;
        height: 1rem;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--small::after {
        width: 0.25rem;
        height: 0.5rem;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--large {
        width: 1.5rem;
        height: 1.5rem;
      }
      
      .${Checkbox.BASE_CHECKBOX_CLASS}--large::after {
        width: 0.375rem;
        height: 0.75rem;
      }
    `, 'userscripts-checkbox-styles');

        Checkbox.stylesInitialized = true;
      }
      /**
         * Inject default color variables for the checkbox component into the :root.
         * Users can call this method to automatically set a default color palette.
         */
      static useDefaultColors() {
        const styleId = 'userscripts-checkbox-default-colors';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          HTMLUtils.setHTMLSafely(style, `
        :root {
          /* Default state */
          ${Checkbox.CSS_VAR_PREFIX}bg: #ffffff;
          ${Checkbox.CSS_VAR_PREFIX}border-color: #d1d5db;
          ${Checkbox.CSS_VAR_PREFIX}hover-bg: #f3f4f6;
          ${Checkbox.CSS_VAR_PREFIX}hover-border: #9ca3af;
          
          /* Checked state */
          ${Checkbox.CSS_VAR_PREFIX}checked-bg: #3b82f6;
          ${Checkbox.CSS_VAR_PREFIX}checked-border: #3b82f6;
          ${Checkbox.CSS_VAR_PREFIX}checkmark-color: #ffffff;
          
          /* Focus state */
          ${Checkbox.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.3);
        }

        @media (prefers-color-scheme: dark) {
          :root {
            /* Default state */
            ${Checkbox.CSS_VAR_PREFIX}bg: #2d2d2d;
            ${Checkbox.CSS_VAR_PREFIX}border-color: #555;
            ${Checkbox.CSS_VAR_PREFIX}hover-bg: #4a4a4a;
            ${Checkbox.CSS_VAR_PREFIX}hover-border: #777;

            /* Checked state */
            ${Checkbox.CSS_VAR_PREFIX}checked-bg: #3b82f6;
            ${Checkbox.CSS_VAR_PREFIX}checked-border: #3b82f6;
            ${Checkbox.CSS_VAR_PREFIX}checkmark-color: #ffffff;

            /* Focus state */
            ${Checkbox.CSS_VAR_PREFIX}focus-shadow: rgba(59, 130, 246, 0.4);
          }
        }
      `);
          document.head.appendChild(style);
        }
      }
      /**
         * Create a new Checkbox.
         * @param {Object} options - Configuration options.
         * @param {String} [options.label] - Checkbox label text.
         * @param {Boolean} [options.checked=false] - Initial checked state.
         * @param {Boolean} [options.indeterminate=false] - Initial indeterminate state.
         * @param {String} [options.id] - Checkbox ID.
         * @param {String} [options.name] - Input name attribute.
         * @param {Function} [options.onChange] - Change event handler.
         * @param {HTMLElement} [options.container] - Container to append the checkbox to.
         * @param {String} [options.className] - Additional custom CSS class.
         * @param {Boolean} [options.disabled=false] - Disabled state.
         * @param {String} [options.size="medium"] - Checkbox size.
         * @param {Object} [options.attributes={}] - Additional HTML attributes.
         */
      constructor(options = {}) {
        this.label = options.label || '';
        this.checked = options.checked || false;
        this.indeterminate = options.indeterminate || false;
        this.id = options.id;
        this.name = options.name;
        this.onChange = options.onChange;
        this.container = options.container;
        this.customClassName = options.className || '';
        this.disabled = options.disabled || false;
        this.size = options.size || 'medium';
        this.attributes = options.attributes || {};

        // DOM elements references
        this.checkboxContainer = null;
        this.customCheckbox = null;
        this.nativeCheckbox = null;
        this.labelElement = null;

        Checkbox.initStyles();
        this.create();
      }


      /**
         * Create the checkbox UI and, if a container is provided, append it.
         * @return {HTMLElement} The created checkbox container element.
         */
      create() {
        // Create container
        this.checkboxContainer = document.createElement('label');
        this.checkboxContainer.className = `${Checkbox.BASE_CHECKBOX_CLASS}-container`;
        if (this.customClassName) {
          this.checkboxContainer.classList.add(this.customClassName);
        }
        if (this.disabled) {
          this.checkboxContainer.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled`);
        }

        // Create hidden native checkbox for accessibility
        this.nativeCheckbox = document.createElement('input');
        this.nativeCheckbox.type = 'checkbox';
        this.nativeCheckbox.className = `${Checkbox.BASE_CHECKBOX_CLASS}-native`;
        this.nativeCheckbox.checked = this.checked;
        this.nativeCheckbox.indeterminate = this.indeterminate;
        this.nativeCheckbox.disabled = this.disabled;

        if (this.id) this.nativeCheckbox.id = this.id;
        if (this.name) this.nativeCheckbox.name = this.name;

        Object.entries(this.attributes).forEach(([key, value]) => {
          this.nativeCheckbox.setAttribute(key, value);
        });

        // Create custom checkbox visual
        this.customCheckbox = document.createElement('span');
        this.customCheckbox.className = `${Checkbox.BASE_CHECKBOX_CLASS} ${Checkbox.BASE_CHECKBOX_CLASS}--${this.size}`;
        if (this.checked) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        } else if (this.indeterminate) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        }

        // Create label if provided
        if (this.label) {
          this.labelElement = document.createElement('span');
          this.labelElement.className = `${Checkbox.BASE_CHECKBOX_CLASS}-label`;
          this.labelElement.textContent = this.label;
        }

        // Set up event listeners
        this.nativeCheckbox.addEventListener('change', (e) => this.handleChange(e));
        this.nativeCheckbox.addEventListener('focus', () => this.handleFocus());
        this.nativeCheckbox.addEventListener('blur', () => this.handleBlur());

        // Assemble the component
        this.checkboxContainer.appendChild(this.nativeCheckbox);
        this.checkboxContainer.appendChild(this.customCheckbox);
        if (this.labelElement) {
          this.checkboxContainer.appendChild(this.labelElement);
        }

        // Add to container if provided
        if (this.container) {
          this.container.appendChild(this.checkboxContainer);
        }

        // Store reference to instance on DOM element for potential external access
        this.checkboxContainer._checkboxInstance = this;

        return this.checkboxContainer;
      }

      /**
         * Handle change events.
         * @param {Event} e - The change event.
         */
      handleChange(e) {
        this.checked = this.nativeCheckbox.checked;
        this.indeterminate = this.nativeCheckbox.indeterminate;

        if (this.checked) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        } else if (this.indeterminate) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        } else {
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        }

        if (this.onChange) {
          this.onChange(e);
        }
      }

      /**
         * Handle focus events.
         */
      handleFocus() {
        // Additional focus behaviors can be added here if needed
      }

      /**
         * Handle blur events.
         */
      handleBlur() {
        // Additional blur behaviors can be added here if needed
      }

      /**
         * Set the checked state.
         * @param {Boolean} checked - The new checked state.
         */
      setChecked(checked) {
        this.checked = checked;
        this.nativeCheckbox.checked = checked;

        if (checked) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
          this.indeterminate = false;
          this.nativeCheckbox.indeterminate = false;
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        } else {
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        }
      }

      /**
         * Set the indeterminate state.
         * @param {Boolean} indeterminate - The new indeterminate state.
         */
      setIndeterminate(indeterminate) {
        this.indeterminate = indeterminate;
        this.nativeCheckbox.indeterminate = indeterminate;

        if (indeterminate) {
          this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--checked`);
        } else {
          this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--indeterminate`);
        }
      }

      /**
         * Toggle the checked state.
         * @return {Boolean} The new checked state.
         */
      toggle() {
        this.setChecked(!this.checked);
        return this.checked;
      }

      /**
         * Set the disabled state.
         * @param {Boolean} disabled - The new disabled state.
         */
      setDisabled(disabled) {
        this.disabled = disabled;
        this.nativeCheckbox.disabled = disabled;

        if (disabled) {
          this.checkboxContainer.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled`);
        } else {
          this.checkboxContainer.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}-container--disabled`);
        }
      }

      /**
         * Set the label text.
         * @param {String} text - The new label text.
         */
      setLabel(text) {
        this.label = text;

        if (!this.labelElement) {
          this.labelElement = document.createElement('span');
          this.labelElement.className = `${Checkbox.BASE_CHECKBOX_CLASS}-label`;
          this.checkboxContainer.appendChild(this.labelElement);
        }

        this.labelElement.textContent = text;
      }

      /**
         * Change the checkbox size.
         * @param {String} size - The new size (e.g., "small", "medium", "large").
         */
      setSize(size) {
        this.customCheckbox.classList.remove(`${Checkbox.BASE_CHECKBOX_CLASS}--${this.size}`);
        this.size = size;
        this.customCheckbox.classList.add(`${Checkbox.BASE_CHECKBOX_CLASS}--${this.size}`);
      }

      /**
         * Apply a custom CSS class to the checkbox container.
         * @param {String} className - The custom class name.
         */
      setCustomClass(className) {
        if (this.customClassName) {
          this.checkboxContainer.classList.remove(this.customClassName);
        }
        this.customClassName = className;
        if (className) {
          this.checkboxContainer.classList.add(className);
        }
      }

      /**
         * Get the current checked state.
         * @return {Boolean} The current checked state.
         */
      isChecked() {
        return this.checked;
      }

      /**
         * Get the current indeterminate state.
         * @return {Boolean} The current indeterminate state.
         */
      isIndeterminate() {
        return this.indeterminate;
      }

      /**
         * Get the current disabled state.
         * @return {Boolean} The current disabled state.
         */
      isDisabled() {
        return this.disabled;
      }

      /**
         * Shows or hides the entire checkbox.
         * @param {Boolean} visible - True to show, false to hide.
         */
      setVisible(visible) {
        if (this.checkboxContainer) {
          this.checkboxContainer.style.display = visible ? '' : 'none';
        }
      }

      /**
         * Destroys the checkbox and removes it from the DOM.
         */
      destroy() {
        if (this.checkboxContainer && this.checkboxContainer.parentNode) {
          this.checkboxContainer.parentNode.removeChild(this.checkboxContainer);
        }
        this.checkboxContainer = null;
        this.customCheckbox = null;
        this.nativeCheckbox = null;
        this.labelElement = null;
      }
    }

    // Static property to track if styles have been initialized.
    Checkbox.stylesInitialized = false;
    Checkbox.initStyles();

    /**
     * SidebarPanel - A reusable UI component for creating a sidebar panel with a trigger button
     * Similar to Wallapop's help button that shifts the site content
     */

    /**
     * A reusable component that creates a toggle button and sidebar panel
     */
    class SidebarPanel {
        // Panel states
        static PANEL_STATES = {
            OPENED: 'opened',
            CLOSED: 'closed'
        };

        // Panel positions
        static PANEL_POSITIONS = {
            RIGHT: 'right',
            LEFT: 'left'
        };

        // Panel transitions
        static PANEL_TRANSITIONS = {
            SLIDE: 'slide',
            PUSH: 'push'
        };

        // GM storage keys
        static STORAGE_KEYS = {
            PANEL_STATE: 'sidebar-panel-state',
            PANEL_SETTINGS: 'sidebar-panel-settings'
        };

        // PubSub events
        static EVENTS = {
            PANEL_OPEN: 'sidebar-panel-open',
            PANEL_CLOSE: 'sidebar-panel-close',
            PANEL_TOGGLE: 'sidebar-panel-toggle',
            PANEL_INITIALIZED: 'sidebar-panel-initialized'
        };

        /**
         * Create a new SidebarPanel.
         * @param {Object} options - Configuration options.
         * @param {String} options.title - Panel title.
         * @param {String} [options.id="sidebar-panel"] - Unique ID for the panel.
         * @param {String} [options.position="right"] - Position of the panel ("right" or "left").
         * @param {String} [options.transition="slide"] - Transition effect ("slide" or "push").
         * @param {String} [options.buttonIcon="?"] - HTML content for the toggle button.
         * @param {Boolean} [options.showButton=true] - Whether to show the toggle button.
         * @param {String} [options.namespace="userscripts"] - Namespace for CSS classes.
         * @param {Function} [options.onOpen=null] - Callback when panel opens.
         * @param {Function} [options.onClose=null] - Callback when panel closes.
         * @param {Boolean} [options.overlay=true] - Whether to show an overlay behind the panel.
         * @param {Object} [options.content={}] - Content configuration.
         * @param {String|HTMLElement} [options.content.html=null] - HTML content for the panel.
         * @param {Function} [options.content.generator=null] - Function that returns content.
         * @param {Boolean} [options.rememberState=true] - Whether to remember the panel state.
         * @param {Object} [options.style={}] - Custom style options.
         * @param {String} [options.style.width="320px"] - Panel width.
         * @param {String} [options.style.buttonSize="48px"] - Button size.
         * @param {String} [options.style.buttonColor="#fff"] - Button text color.
         * @param {String} [options.style.buttonBg="#625df5"] - Button background color.
         * @param {String} [options.style.panelBg="#fff"] - Panel background color.
         */
        constructor(options = {}) {
            // Process and store options with defaults
            this.options = {
                title: options.title || 'Panel',
                id: options.id || 'sidebar-panel',
                position: options.position || SidebarPanel.PANEL_POSITIONS.RIGHT,
                transition: options.transition || SidebarPanel.PANEL_TRANSITIONS.SLIDE,
                buttonIcon: options.buttonIcon || '?',
                showButton: options.showButton !== false,
                namespace: options.namespace || 'userscripts',
                onOpen: options.onOpen || null,
                onClose: options.onClose || null,
                overlay: options.overlay !== false,
                content: options.content || {},
                rememberState: options.rememberState !== false,
                style: options.style || {}
            };

            // Default styles
            this.options.style = {
                buttonColor: '#fff',
                buttonBg: '#625df5',
                panelBg: '#fff',
                ...options.style
            };

            // Setup base class names based on namespace
            this.baseClass = `${this.options.namespace}-sidebar-panel`;
            this.cssVarPrefix = `--${this.options.namespace}-sidebar-panel-`;

            // Elements references
            this.container = null;
            this.panel = null;
            this.button = null;
            this.closeButton = null;
            this.content = null;
            this.header = null;
            this.footer = null;
            this.overlay = null;

            // Panel state
            this.state = this.getSavedState() || SidebarPanel.PANEL_STATES.CLOSED;

            // Storage key for this specific panel instance
            this.storageKey = `${SidebarPanel.STORAGE_KEYS.PANEL_STATE}-${this.options.id}`;
        }

        /**
         * Initialize the styles for the SidebarPanel
         * @param {String} namespace - Optional namespace to prevent CSS collisions
         */
        static initStyles(namespace = 'userscripts') {
            const baseClass = `${namespace}-sidebar-panel`;
            const cssVarPrefix = `--${namespace}-sidebar-panel-`;

            StyleManager.addStyles(`
            /* Base styles for the sidebar panel */
            .${baseClass}-container {
                position: fixed;
                top: 0;
                height: 100%;
                z-index: 9998;
                transition: transform 0.3s ease-in-out;
            }
            
            .${baseClass}-container--right {
                right: 0;
                transform: translateX(100%);
            }
            
            .${baseClass}-container--left {
                left: 0;
                transform: translateX(-100%);
            }
            
            .${baseClass}-container--opened {
                transform: translateX(0);
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            }
            
            .${baseClass} {
                width: var(${cssVarPrefix}width, 320px);
                height: 100%;
                background-color: var(${cssVarPrefix}bg, #fff);
                display: flex;
                flex-direction: column;
                overflow: hidden;
                position: relative;
            }
            
            .${baseClass}-header {
                padding: 16px;
                background-color: var(${cssVarPrefix}header-bg, #f5f5f5);
                border-bottom: 1px solid var(${cssVarPrefix}border-color, #eee);
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .${baseClass}-title {
                font-weight: bold;
                font-size: 18px;
                color: var(${cssVarPrefix}title-color, #333);
                margin: 0;
            }
            
            .${baseClass}-close {
                background: none;
                border: none;
                cursor: pointer;
                font-size: 24px;
                line-height: 24px;
                padding: 0;
                width: 24px;
                height: 24px;
                color: var(${cssVarPrefix}close-color, #777);
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .${baseClass}-close:hover {
                color: var(${cssVarPrefix}close-color-hover, #333);
            }
            
            .${baseClass}-content {
                flex: 1;
                overflow-y: auto;
                padding: 16px;
            }
            
            .${baseClass}-footer {
                padding: 16px;
                background-color: var(${cssVarPrefix}footer-bg, #f5f5f5);
                border-top: 1px solid var(${cssVarPrefix}border-color, #eee);
            }
            
            /* Toggle button styles */
            .${baseClass}-toggle {
                position: fixed;
                width: var(${cssVarPrefix}button-size, 48px);
                height: var(${cssVarPrefix}button-size, 48px);
                border-radius: 50%;
                background-color: var(${cssVarPrefix}button-bg, #625df5);
                color: var(${cssVarPrefix}button-color, #fff);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                z-index: 9999;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
                border: none;
                outline: none;
                transition: background-color 0.2s ease, transform 0.2s ease;
            }
            
            .${baseClass}-toggle:hover {
                background-color: var(${cssVarPrefix}button-bg-hover, #514dc6);
                transform: scale(1.05);
            }
            
            .${baseClass}-toggle--right {
                right: 20px;
                bottom: 20px;
            }
            
            .${baseClass}-toggle--left {
                left: 20px;
                bottom: 20px;
            }
            
            /* For push transition effect */
            body.${baseClass}-push-active--right {
                transition: margin-left 0.3s ease-in-out;
            }
            
            body.${baseClass}-push-active--right.${baseClass}-push--opened {
                margin-left: calc(-1 * var(${cssVarPrefix}width, 320px));
            }
            
            body.${baseClass}-push-active--left {
                transition: margin-right 0.3s ease-in-out;
            }
            
            body.${baseClass}-push-active--left.${baseClass}-push--opened {
                margin-right: calc(-1 * var(${cssVarPrefix}width, 320px));
            }
            
            /* Overlay for slide transition */
            .${baseClass}-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 9997;
                opacity: 0;
                visibility: hidden;
                transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
            }
            
            .${baseClass}-overlay--visible {
                opacity: 1;
                visibility: visible;
            }
            
            /* Responsive styles */
            @media (max-width: 768px) {
                .${baseClass} {
                    width: 85vw;
                }
            }

            .${baseClass}-footer-content {
                /* Add any specific footer content styling here */
            }

            @media (prefers-color-scheme: dark) {
                .${baseClass} {
                    background-color: var(${cssVarPrefix}bg, #2d2d2d);
                }

                .${baseClass}-header {
                    background-color: #3a3a3a;
                    border-bottom-color: #444;
                }

                .${baseClass}-title {
                    color: #e0e0e0;
                }

                .${baseClass}-close {
                    color: #aaa;
                }

                .${baseClass}-close:hover {
                    color: #fff;
                }

                .${baseClass}-footer {
                    background-color: #3a3a3a;
                    border-top-color: #444;
                }

                .${baseClass}-overlay {
                    background-color: rgba(0, 0, 0, 0.7);
                }

                .${baseClass}-toggle {
                    background-color: var(${cssVarPrefix}button-bg, #3b82f6);
                }

                .${baseClass}-toggle:hover {
                    background-color: var(${cssVarPrefix}button-bg-hover, #2563eb);
                }
            }
        `, `sidebar-panel-styles-${namespace}`);
        }

        /**
         * Initialize the panel
         */
        async init() {
            // Ensure styles are initialized only once
            if (!document.head.dataset.sidebarPanelStylesInitialized) {
            SidebarPanel.initStyles(this.options.namespace);
                document.head.dataset.sidebarPanelStylesInitialized = 'true';
            }

            // Apply any custom styles from options
            this.applyCustomStyles();

            // Create UI elements
            await this.createPanel();
            if (this.options.showButton) {
                this.createToggleButton();
            }
            if (this.options.overlay && this.options.transition === 'slide') {
                this.createOverlay();
            }

            // Setup event listeners
            this.setupEvents();

            // Set initial state without animation
                if (this.state === SidebarPanel.PANEL_STATES.OPENED) {
                this.open(false);
            }

            // Publish initialized event
            PubSub.publish(SidebarPanel.EVENTS.PANEL_INITIALIZED, this);
            Logger.debug(`SidebarPanel initialized: ${this.options.id}`);
        }

        /**
         * Apply custom styles from options
         */
        applyCustomStyles() {
            const customStyles = {};

            // Process style options
            if (this.options.style.width) {
                customStyles[`${this.cssVarPrefix}width`] = this.options.style.width;
            }
            if (this.options.style.buttonSize) {
                customStyles[`${this.cssVarPrefix}button-size`] = this.options.style.buttonSize;
            }
            if (this.options.style.buttonColor) {
                customStyles[`${this.cssVarPrefix}button-color`] = this.options.style.buttonColor;
            }
            if (this.options.style.buttonBg) {
                customStyles[`${this.cssVarPrefix}button-bg`] = this.options.style.buttonBg;
            }
            if (this.options.style.buttonBgHover) {
                customStyles[`${this.cssVarPrefix}button-bg-hover`] = this.options.style.buttonBgHover;
            }
            if (this.options.style.panelBg) {
                customStyles[`${this.cssVarPrefix}bg`] = this.options.style.panelBg;
            }

            // Apply the CSS variables using StyleManager
            if (Object.keys(customStyles).length > 0) {
                const styleId = `${this.baseClass}-custom-${this.options.id}`;
                let cssText = `:root {\n`;

                for (const [key, value] of Object.entries(customStyles)) {
                    cssText += `  ${key}: ${value};\n`;
                }

                cssText += `}\n`;
                StyleManager.addStyles(cssText, styleId);
            }
        }

        /**
         * Creates and configures the main panel element
         */
        async createPanel() {
            this.container = document.createElement('div');
            this.container.id = this.options.id;
            this.container.className = `${this.baseClass}-container ${this.baseClass}-container--${this.options.position}`;

            this.panel = document.createElement('div');
            this.panel.className = this.baseClass;

            // Create header with title and close button
            this.header = document.createElement('div');
            this.header.className = `${this.baseClass}-header`;

            const titleElement = document.createElement('h2');
            titleElement.className = `${this.baseClass}-title`;
            titleElement.textContent = this.options.title;

            this.closeButton = document.createElement('button');
            this.closeButton.className = `${this.baseClass}-close`;
            HTMLUtils.setHTMLSafely(this.closeButton, '&times;');
            this.closeButton.setAttribute('aria-label', 'Close Panel');

            this.header.appendChild(titleElement);
            this.header.appendChild(this.closeButton);

            // Create content area
            this.content = document.createElement('div');
            this.content.className = `${this.baseClass}-content`;

            // Populate content
            await this.setContent(this.options.content);

            // Create footer if provided
            if (this.options.content.footer) {
                this.footer = document.createElement('div');
                this.footer.className = `${this.baseClass}-footer`;
                HTMLUtils.setHTMLSafely(this.footer, this.options.content.footer);
            }

            // Assemble panel
            this.panel.appendChild(this.header);
            this.panel.appendChild(this.content);
            if (this.footer) {
                this.panel.appendChild(this.footer);
            }

            this.container.appendChild(this.panel);

            // Add panel to the DOM
            document.body.appendChild(this.container);
            Logger.debug('Panel created and added to DOM');
        }

        /**
         * Create toggle button
         */
        createToggleButton() {
            if (!this.options.showButton) return;
            this.button = document.createElement('button');
            this.button.className = `${this.baseClass}-toggle ${this.baseClass}-toggle--${this.options.position}`;
            HTMLUtils.setHTMLSafely(this.button, this.options.buttonIcon);
            this.button.setAttribute('aria-label', 'Toggle Panel');
            document.body.appendChild(this.button);
        }

        /**
         * Create overlay element
         */
        createOverlay() {
            this.overlay = document.createElement('div');
            this.overlay.className = `${this.baseClass}-overlay`;
            document.body.appendChild(this.overlay);
        }

        /**
         * Set up event listeners
         */
        setupEvents() {
            // Toggle button click
            if (this.button) {
                this.button.addEventListener('click', () => this.toggle());
            }

            // Close button click
            if (this.closeButton) {
                this.closeButton.addEventListener('click', () => this.close());
            }

            // Overlay click
            if (this.overlay) {
                this.overlay.addEventListener('click', () => this.close());
            }

            // Listen for PubSub events
            this.subscriptions = [
                PubSub.subscribe(`${SidebarPanel.EVENTS.PANEL_OPEN}-${this.options.id}`, () => this.open()),
                PubSub.subscribe(`${SidebarPanel.EVENTS.PANEL_CLOSE}-${this.options.id}`, () => this.close()),
                PubSub.subscribe(`${SidebarPanel.EVENTS.PANEL_TOGGLE}-${this.options.id}`, () => this.toggle())
            ];

            // ESC key to close
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && this.state === SidebarPanel.PANEL_STATES.OPENED) {
                    this.close();
                }
            });
        }

        /**
         * Toggle panel state
         */
        toggle() {
            if (this.state === SidebarPanel.PANEL_STATES.CLOSED) {
                this.open();
            } else {
                this.close();
            }
        }

        /**
         * Open the panel
         * @param {Boolean} animate - Whether to animate the opening
         */
        open(animate = true) {
            if (this.state === SidebarPanel.PANEL_STATES.OPENED) return;

            this.state = SidebarPanel.PANEL_STATES.OPENED;

            // Update panel class
            if (!animate) {
                this.container.style.transition = 'none';
                requestAnimationFrame(() => {
                    this.container.style.transition = '';
                });
            }

            this.container.classList.add(`${this.baseClass}-container--opened`);

            // Handle push transition
            if (this.options.transition === SidebarPanel.PANEL_TRANSITIONS.PUSH) {
                document.body.classList.add(`${this.baseClass}-push-active--${this.options.position}`);
                document.body.classList.add(`${this.baseClass}-push--opened`);
            }

            // Show overlay
            if (this.overlay) {
                this.overlay.classList.add(`${this.baseClass}-overlay--visible`);
            }

            // Save state
            if (this.options.rememberState) {
                this.saveState();
            }

            // Call onOpen callback if provided
            if (typeof this.options.onOpen === 'function') {
                this.options.onOpen();
            }

            // Publish event
            PubSub.publish(SidebarPanel.EVENTS.PANEL_OPEN, {
                id: this.options.id,
                panel: this
            });

            Logger.debug(`SidebarPanel opened: ${this.options.id}`);
        }

        /**
         * Close the panel
         */
        close() {
            if (this.state === SidebarPanel.PANEL_STATES.CLOSED) return;

            this.state = SidebarPanel.PANEL_STATES.CLOSED;

            // Update panel class
            this.container.classList.remove(`${this.baseClass}-container--opened`);

            // Handle push transition
            if (this.options.transition === SidebarPanel.PANEL_TRANSITIONS.PUSH) {
                document.body.classList.remove(`${this.baseClass}-push--opened`);
                // We keep the active class for transition
                setTimeout(() => {
                    if (this.state === SidebarPanel.PANEL_STATES.CLOSED) {
                        document.body.classList.remove(`${this.baseClass}-push-active--${this.options.position}`);
                    }
                }, 300); // Match transition duration
            }

            // Hide overlay
            if (this.overlay) {
                this.overlay.classList.remove(`${this.baseClass}-overlay--visible`);
            }

            // Save state
            if (this.options.rememberState) {
                this.saveState();
            }

            // Call onClose callback if provided
            if (typeof this.options.onClose === 'function') {
                this.options.onClose();
            }

            // Publish event
            PubSub.publish(SidebarPanel.EVENTS.PANEL_CLOSE, {
                id: this.options.id,
                panel: this
            });

            Logger.debug(`SidebarPanel closed: ${this.options.id}`);
        }

        /**
         * Get saved panel state from GM storage
         * @return {String|null} Panel state or null if not found
         */
        async getSavedState() {
            if (!this.options.rememberState) return null;

            try {
                // Use directly imported getValue
                const savedState = await getValue(this.storageKey, SidebarPanel.PANEL_STATES.CLOSED);
                // Validate state
                if (Object.values(SidebarPanel.PANEL_STATES).includes(savedState)) {
                    Logger.debug('Retrieved saved panel state:', savedState, 'for key:', this.storageKey);
                    return savedState;
                }
                Logger.warn('Invalid saved panel state retrieved:', savedState, 'for key:', this.storageKey);
            } catch (error) {
                Logger.error('Error retrieving saved panel state:', error, 'for key:', this.storageKey);
            }
            return SidebarPanel.PANEL_STATES.CLOSED; // Default to closed on error or invalid
        }

        /**
         * Save the current panel state (opened/closed) if rememberState is enabled.
         */
        async saveState() {
            if (!this.options.rememberState) return;

            try {
                // Use directly imported setValue
                await setValue(this.storageKey, this.state);
                Logger.debug('Saved panel state:', this.state, 'for key:', this.storageKey);
            } catch (error) {
                Logger.error('Error saving panel state:', error, 'for key:', this.storageKey);
            }
        }

        /**
         * @param {Object} contentConfig - Content configuration object
         */
        async setContent(contentConfig) {
            if (!this.content) return;
            this.content.textContent = ''; // Clearing content safely

            if (contentConfig.html) {
                if (typeof contentConfig.html === 'string') {
                    HTMLUtils.setHTMLSafely(this.content, contentConfig.html);
                } else if (contentConfig.html instanceof HTMLElement) {
                    this.content.appendChild(contentConfig.html);
                }
            } else if (typeof contentConfig.generator === 'function') {
                const generatedContent = await contentConfig.generator();
                if (typeof generatedContent === 'string') {
                    HTMLUtils.setHTMLSafely(this.content, generatedContent);
                } else if (generatedContent instanceof HTMLElement) {
                    this.content.appendChild(generatedContent);
                }
            }
            Logger.debug('Panel content updated');
        }

        /**
         * Set panel title
         * @param {String} title - New title text
         */
        setTitle(title) {
            const titleElement = this.header ? this.header.querySelector(`.${this.baseClass}-title`) : null;
            if (titleElement) {
                titleElement.textContent = title;
                this.options.title = title;
            }
        }

        /**
         * Set button icon
         * @param {String} iconHtml - Text content for icon (no HTML allowed for CSP compliance)
         */
        setButtonIcon(iconHtml) {
            if (this.button) {
                HTMLUtils.setHTMLSafely(this.button, iconHtml);
                this.options.buttonIcon = iconHtml;
            }
        }

        /**
         * Destroy the panel and clean up
         */
        destroy() {
            // Remove DOM elements
            if (this.container && this.container.parentNode) {
                this.container.parentNode.removeChild(this.container);
            }

            if (this.button && this.button.parentNode) {
                this.button.parentNode.removeChild(this.button);
            }

            if (this.overlay && this.overlay.parentNode) {
                this.overlay.parentNode.removeChild(this.overlay);
            }

            // Remove body classes
            document.body.classList.remove(`${this.baseClass}-push-active--${this.options.position}`);
            document.body.classList.remove(`${this.baseClass}-push--opened`);

            // Unsubscribe from PubSub events
            if (this.subscriptions) {
                this.subscriptions.forEach(subscriptionId => {
                    PubSub.unsubscribe(subscriptionId);
                });
            }

            Logger.debug(`SidebarPanel destroyed: ${this.options.id}`);
        }
    }

    // Basic logger setup
    Logger.setPrefix("IG Reels Comments");
    Logger.DEBUG = true;

    const PANEL_NAMESPACE = "ig-reels-comments";
    const SETTINGS_KEY = "ig-reels-comments-settings";

    const DEFAULT_SETTINGS = {
        preferNetwork: true,
        autoScroll: true,
        includeReplies: true,
        dedupe: true,
        autoCopyOnFinish: true,
        attachObserver: true,
        maxScrollRounds: 40,
        scrollDelay: 650,
        scrollStep: 800
    };

    class InstagramReelsCommentsCopier {
        constructor() {
            this.comments = new Map();
            this.commentContainer = null;
            this.domObserver = null;
            this.debouncedDomScan = Debouncer.debounce(() => this.scanDomAndUpdate(), 500);
            this.urlWatcher = new UrlChangeWatcher([new PollingStrategy(this.handleUrlChange.bind(this), 900)], true);
            this.vpStabilizer = new ViewportStabilizer({
                scrollContainer: null,
                stableDurationMs: 800,
                checkIntervalMs: 200,
                maxWaitMs: 12000,
                enableDebugLogging: Logger.DEBUG,
                logger: Logger
            });
            this.state = {
                scrolling: false,
                lastSource: "none",
                lastUpdate: null,
                noNewRounds: 0,
                currentUrl: location.href
            };
            this.settings = { ...DEFAULT_SETTINGS };
            this.ui = {};
            this.networkPatched = false;
            this.containerLocatorInterval = null;
            this.globalObserver = null;

            this.init();
        }

        async init() {
            await this.loadSettings();
            this.injectStyles();
            await this.setupPanel();
            this.installNetworkSniffer();
            this.startUrlWatcher();
            this.tryAttachContainerWatcher();
            this.scanDomAndUpdate();
        }

        async loadSettings() {
            try {
                const saved = await getValue(SETTINGS_KEY, DEFAULT_SETTINGS);
                this.settings = { ...DEFAULT_SETTINGS, ...saved };
            } catch (err) {
                Logger.warn("Unable to load settings", err);
                this.settings = { ...DEFAULT_SETTINGS };
            }
        }

        async persistSettings() {
            try {
                await setValue(SETTINGS_KEY, this.settings);
            } catch (err) {
                Logger.warn("Unable to save settings", err);
            }
        }

        injectStyles() {
            const base = PANEL_NAMESPACE;
            StyleManager.addStyles(`
            .${base}-section { margin-bottom: 12px; }
            .${base}-row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 6px; }
            .${base}-row button { flex: 1; min-width: 120px; padding: 10px 12px; border: 1px solid #cfd3dc; border-radius: 8px; cursor: pointer; background: #f6f7fb; color: #111; font-weight: 600; }
            .${base}-row button:hover { background: #e9ebf3; }
            .${base}-row button:disabled { opacity: 0.55; cursor: not-allowed; color: #666; }
            .${base}-row button:disabled:hover { background: #f6f7fb; }
            .${base}-options label { display: flex; align-items: center; gap: 6px; margin: 4px 0; }
            .${base}-options input[type="number"] { width: 90px; padding: 4px; }
            .${base}-preview { width: 100%; }
            .${base}-preview textarea { width: 100%; min-height: 220px; padding: 10px; border-radius: 8px; border: 1px solid #ccc; background: #fff; color: #111; resize: vertical; font-family: monospace; line-height: 1.5; box-sizing: border-box; }
            .${base}-preview textarea::selection { background: #ffe69b; }
            .${base}-stat { font-size: 13px; color: #222; margin: 4px 0; font-weight: 500; }
            .${base}-badge { display: inline-flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 8px; background: #eef0f5; color: #111; margin-right: 6px; border: 1px solid #d8dce5; }
            .${base}-tag { font-size: 12px; color: #222; background: #e6edff; padding: 2px 6px; border-radius: 6px; }
            .${base}-hint { font-size: 12px; color: #333; margin-top: 8px; line-height: 1.5; }
            .${base}-content { color: #111; }
            .${base}-content input, .${base}-content label { color: #111; }
        `, `${base}-styles`);
        }

        async setupPanel() {
            SidebarPanel.initStyles(PANEL_NAMESPACE);
            this.sidebarPanel = new SidebarPanel({
                id: `${PANEL_NAMESPACE}-panel`,
                namespace: PANEL_NAMESPACE,
                title: "Reels Comments Copier",
                position: SidebarPanel.PANEL_POSITIONS.RIGHT,
                transition: SidebarPanel.PANEL_TRANSITIONS.SLIDE,
                buttonIcon: "💬",
                style: {
                    width: "360px",
                    buttonBg: "#ff3e8f",
                    buttonBgHover: "#e03170"
                },
                content: { generator: () => this.buildPanelContent() }
            });
            await this.sidebarPanel.init();
        }

        buildPanelContent() {
            const wrapper = document.createElement("div");
            wrapper.className = `${PANEL_NAMESPACE}-content`;
            wrapper.innerHTML = `
            <div class="${PANEL_NAMESPACE}-section">
                <div class="${PANEL_NAMESPACE}-stat"><span class="${PANEL_NAMESPACE}-badge">Found <strong data-field="count">0</strong></span><span class="${PANEL_NAMESPACE}-badge">Source <strong data-field="source">none</strong></span></div>
                <div class="${PANEL_NAMESPACE}-stat">Last update: <strong data-field="updated">–</strong></div>
                <div class="${PANEL_NAMESPACE}-stat">Current URL: <span data-field="url">${HTMLUtils.escapeHTML(location.href)}</span></div>
            </div>
            <div class="${PANEL_NAMESPACE}-section ${PANEL_NAMESPACE}-row">
                <button data-action="rescan">Rescan DOM</button>
                <button data-action="scroll">Start auto-scroll</button>
                <button data-action="stop" disabled>Stop</button>
                <button data-action="copy">Copy</button>
                <button data-action="clear">Clear</button>
            </div>
            <div class="${PANEL_NAMESPACE}-section ${PANEL_NAMESPACE}-options">
                <label><input type="checkbox" data-setting="preferNetwork"> Prefer network JSON</label>
                <label><input type="checkbox" data-setting="autoScroll"> Auto-scroll while attached</label>
                <label><input type="checkbox" data-setting="attachObserver"> Watch DOM for new comments</label>
                <label><input type="checkbox" data-setting="includeReplies"> Include replies</label>
                <label><input type="checkbox" data-setting="dedupe"> Deduplicate</label>
                <label><input type="checkbox" data-setting="autoCopyOnFinish"> Auto-copy when scroll stops</label>
                <div class="${PANEL_NAMESPACE}-row">
                    <label>Max scroll rounds <input type="number" min="1" max="300" step="1" data-setting="maxScrollRounds"></label>
                    <label>Scroll delay (ms) <input type="number" min="200" max="5000" step="50" data-setting="scrollDelay"></label>
                    <label>Scroll step (px) <input type="number" min="200" max="2000" step="50" data-setting="scrollStep"></label>
                </div>
            </div>
            <div class="${PANEL_NAMESPACE}-section ${PANEL_NAMESPACE}-preview">
                <textarea data-field="preview" readonly placeholder="Collected comments will appear here..."></textarea>
                <div class="${PANEL_NAMESPACE}-hint">
                    Network-first: intercepts Instagram GraphQL comment payloads. DOM fallback: finds span[dir=auto] with "For you" then grabs second div under its ancestor &lt;ul&gt; to parse comment text. Use auto-scroll to load more batches.
                </div>
            </div>
        `;

            this.ui = {
                wrapper,
                count: wrapper.querySelector('[data-field="count"]'),
                source: wrapper.querySelector('[data-field="source"]'),
                updated: wrapper.querySelector('[data-field="updated"]'),
                url: wrapper.querySelector('[data-field="url"]'),
                preview: wrapper.querySelector('[data-field="preview"]'),
                buttons: {
                    rescan: wrapper.querySelector('button[data-action="rescan"]'),
                    scroll: wrapper.querySelector('button[data-action="scroll"]'),
                    stop: wrapper.querySelector('button[data-action="stop"]'),
                    copy: wrapper.querySelector('button[data-action="copy"]'),
                    clear: wrapper.querySelector('button[data-action="clear"]')
                },
                inputs: {
                    preferNetwork: wrapper.querySelector('input[data-setting="preferNetwork"]'),
                    autoScroll: wrapper.querySelector('input[data-setting="autoScroll"]'),
                    includeReplies: wrapper.querySelector('input[data-setting="includeReplies"]'),
                    dedupe: wrapper.querySelector('input[data-setting="dedupe"]'),
                    autoCopyOnFinish: wrapper.querySelector('input[data-setting="autoCopyOnFinish"]'),
                    attachObserver: wrapper.querySelector('input[data-setting="attachObserver"]'),
                    maxScrollRounds: wrapper.querySelector('input[data-setting="maxScrollRounds"]'),
                    scrollDelay: wrapper.querySelector('input[data-setting="scrollDelay"]'),
                    scrollStep: wrapper.querySelector('input[data-setting="scrollStep"]')
                }
            };

            this.bindUiEvents();
            this.applySettingsToUi();
            return wrapper;
        }

        bindUiEvents() {
            const { buttons, inputs } = this.ui;

            buttons.rescan?.addEventListener("click", () => this.scanDomAndUpdate());
            buttons.copy?.addEventListener("click", () => this.copyComments());
            buttons.clear?.addEventListener("click", () => this.clearComments());
            buttons.scroll?.addEventListener("click", () => this.startAutoScroll());
            buttons.stop?.addEventListener("click", () => this.stopAutoScroll());

            Object.entries(inputs).forEach(([key, input]) => {
                if (!input) return;
                if (input.type === "checkbox") {
                    input.addEventListener("change", () => {
                        this.settings[key] = input.checked;
                        this.persistSettings();
                        if (key === "attachObserver") {
                            this.tryAttachContainerWatcher(true);
                        }
                    });
                } else {
                    input.addEventListener("change", () => {
                        const val = Number(input.value);
                        if (!Number.isNaN(val)) {
                            this.settings[key] = val;
                            this.persistSettings();
                        }
                    });
                }
            });
        }

        applySettingsToUi() {
            const { inputs } = this.ui;
            if (!inputs) return;
            inputs.preferNetwork.checked = this.settings.preferNetwork;
            inputs.autoScroll.checked = this.settings.autoScroll;
            inputs.includeReplies.checked = this.settings.includeReplies;
            inputs.dedupe.checked = this.settings.dedupe;
            inputs.autoCopyOnFinish.checked = this.settings.autoCopyOnFinish;
            inputs.attachObserver.checked = this.settings.attachObserver;
            inputs.maxScrollRounds.value = this.settings.maxScrollRounds;
            inputs.scrollDelay.value = this.settings.scrollDelay;
            inputs.scrollStep.value = this.settings.scrollStep;
        }

        updateUi() {
            const count = this.comments.size;
            if (this.ui.count) this.ui.count.textContent = String(count);
            if (this.ui.source) this.ui.source.textContent = this.state.lastSource;
            if (this.ui.updated) this.ui.updated.textContent = this.state.lastUpdate ? new Date(this.state.lastUpdate).toLocaleTimeString() : "–";
            if (this.ui.url) this.ui.url.textContent = location.href;
            if (this.ui.preview) this.ui.preview.value = this.formatCommentsForClipboard();

            if (this.ui.buttons?.scroll) {
                this.ui.buttons.scroll.disabled = this.state.scrolling;
            }
            if (this.ui.buttons?.stop) {
                this.ui.buttons.stop.disabled = !this.state.scrolling;
            }
        }

        startUrlWatcher() {
            this.urlWatcher.start();
            this.globalObserver = new MutationObserver(() => this.debouncedDomScan());
            this.globalObserver.observe(document.body, { childList: true, subtree: true });
            Logger.info("Instagram Reels Comments Copier initialized");
        }

        handleUrlChange(newUrl, oldUrl) {
            if (newUrl === oldUrl) return;
            this.state.currentUrl = newUrl;
            this.clearComments(false);
            this.tryAttachContainerWatcher(true);
            this.scanDomAndUpdate();
            if (this.ui.url) this.ui.url.textContent = newUrl;
        }

        installNetworkSniffer() {
            if (this.networkPatched) return;
            this.networkPatched = true;
            const originalFetch = window.fetch;
            window.fetch = async (...args) => {
                const res = await originalFetch(...args);
                this.handleNetworkResponse(res.clone(), args[0]);
                return res;
            };

            const originalOpen = XMLHttpRequest.prototype.open;
            const originalSend = XMLHttpRequest.prototype.send;
            XMLHttpRequest.prototype.open = function(method, url, ...rest) {
                this._igrcUrl = url;
                return originalOpen.call(this, method, url, ...rest);
            };
            XMLHttpRequest.prototype.send = function(body) {
                this.addEventListener("load", () => {
                    try {
                        const contentType = this.getResponseHeader("content-type") || "";
                        if (!contentType.includes("application/json")) return;
                        const data = JSON.parse(this.responseText);
                        window.__igrc?.handleNetworkJSON(data, this._igrcUrl || "");
                    } catch (err) {
                        // ignore parse errors
                    }
                });
                return originalSend.call(this, body);
            };

            window.__igrc = this;
        }

        async handleNetworkResponse(response, url) {
            try {
                const contentType = response.headers.get("content-type") || "";
                if (!contentType.includes("application/json")) return;
                const data = await response.json();
                this.handleNetworkJSON(data, url);
            } catch (err) {
                Logger.debug("Network response ignored", err);
            }
        }

        handleNetworkJSON(data, url = "") {
            if (!this.settings.preferNetwork) return;
            if (!/graphql|api/i.test(url) && !this.looksLikeCommentPayload(data)) return;
            const comments = this.extractCommentsFromObject(data, "network");
            if (comments.length) {
                this.addComments(comments, "network");
            }
        }

        looksLikeCommentPayload(data) {
            if (!data || typeof data !== "object") return false;
            return JSON.stringify(Object.keys(data)).includes("comment");
        }

        extractCommentsFromObject(node, source) {
            const results = [];
            const visited = new WeakSet();
            const walk = (value) => {
                if (!value || typeof value !== "object") return;
                if (visited.has(value)) return;
                visited.add(value);

                const normalized = this.normalizeComment(value, source);
                if (normalized) {
                    results.push(normalized);
                }

                if (Array.isArray(value)) {
                    value.forEach(walk);
                } else {
                    Object.values(value).forEach(walk);
                    if (value.edges && Array.isArray(value.edges)) {
                        value.edges.forEach(edge => walk(edge.node || edge));
                    }
                    if (value.items && Array.isArray(value.items)) {
                        value.items.forEach(walk);
                    }
                }
            };
            walk(node);
            return results;
        }

        normalizeComment(node, source) {
            const text = node.text || node.caption?.text;
            const username = node.username || node.user?.username || node.owner?.username;
            if (!text || !username) return null;
            const id = node.id || node.pk || node.comment_id || `${username}:${text.slice(0, 30)}`;
            const timestamp = node.created_at || node.created_at_utc || node.created_time || null;
            const isReply = Boolean(node.parent_comment_id || node.parent_comment || node.parent_id);
            if (!this.settings.includeReplies && isReply) return null;
            return { id, username, text: String(text).trim(), timestamp, source: source || "network", isReply };
        }

        tryAttachContainerWatcher(force = false) {
            if (this.containerLocatorInterval && !force) return;
            if (this.containerLocatorInterval) clearInterval(this.containerLocatorInterval);
            this.containerLocatorInterval = setInterval(() => {
                const container = this.findCommentContainer();
                if (container) {
                    if (this.commentContainer !== container) {
                        this.commentContainer = container;
                        this.attachDomObserver(container);
                    }
                    if (!this.state.scrolling && this.settings.autoScroll) {
                        this.startAutoScroll();
                    }
                    if (!this.settings.attachObserver) {
                        clearInterval(this.containerLocatorInterval);
                        this.containerLocatorInterval = null;
                    }
                }
            }, 1500);
        }

        findCommentContainer() {
            if (!this.isReelsExperience()) return null;
            const spans = Array.from(document.querySelectorAll('span[dir="auto"]'));
            const target = spans.find(el => (el.textContent || "").trim().toLowerCase() === "for you");
            const ul = target ? target.closest("ul") : null;
            if (!ul) return null;
            const divs = ul.querySelectorAll(":scope > div");
            if (divs.length >= 2) {
                return divs[1];
            }
            return ul;
        }

        attachDomObserver(container) {
            if (this.domObserver) this.domObserver.disconnect();
            if (!container || !this.settings.attachObserver) return;
            this.domObserver = new MutationObserver(() => this.debouncedDomScan());
            this.domObserver.observe(container, { childList: true, subtree: true });
            this.scanDomAndUpdate();
        }

        scanDomAndUpdate() {
            if (!this.isReelsExperience()) return;
            const container = this.commentContainer || this.findCommentContainer();
            if (!container) return;
            const comments = this.extractCommentsFromDom(container);
            if (comments.length) {
                this.addComments(comments, "dom");
            }
        }

        extractCommentsFromDom(container) {
            const results = [];
            const candidates = container.querySelectorAll("li, div[role='listitem'], div[role='group'], section div");
            candidates.forEach(node => {
                const username = this.extractUsername(node);
                const text = this.extractTextFromNode(node, username);
                if (!text) return;
                const timestamp = this.extractTimestamp(node);
                const id = node.getAttribute("data-comment-id") || `${username}:${text.slice(0, 30)}`;
                const isReply = Boolean(node.closest("ul ul, li li"));
                if (!this.settings.includeReplies && isReply) return;
                if (username || text) {
                    results.push({ id, username: username || "anon", text, timestamp, source: "dom", isReply });
                }
            });
            return results;
        }

        extractUsername(node) {
            const anchor = node.querySelector("a[role='link'], a[href^='/']");
            const spanUser = anchor ? anchor.querySelector("span[dir='auto']") : null;
            const raw = (spanUser || anchor || node.querySelector("h3 span[dir='auto']"))?.textContent || "";
            const username = raw.trim();
            if (!username || /\s/.test(username) && username.length > 18) return null;
            return username;
        }

        extractTextFromNode(node, username) {
            const spans = Array.from(node.querySelectorAll("span[dir='auto']"));
            const texts = spans
                .map(el => el.textContent?.trim() || "")
                .filter(Boolean)
                .filter(text => text.toLowerCase() !== "for you")
                .filter(text => text !== username);
            return texts.join(" ").trim();
        }

        extractTimestamp(node) {
            const time = node.querySelector("time");
            if (!time) return null;
            const dt = time.getAttribute("datetime");
            if (dt) return Date.parse(dt);
            return null;
        }

        addComments(list, source) {
            if (!list.length) return;
            let added = 0;
            list.forEach(item => {
                const key = this.settings.dedupe ? (item.id || `${item.username}:${item.text}`) : `${item.username}:${Math.random()}`;
                if (!this.comments.has(key)) {
                    this.comments.set(key, item);
                    added++;
                }
            });
            if (added) {
                this.state.lastSource = source;
                this.state.lastUpdate = Date.now();
                this.state.noNewRounds = 0;
                this.updateUi();
            } else {
                this.state.noNewRounds += 1;
            }
            if (this.settings.autoCopyOnFinish && !this.state.scrolling) {
                this.copyComments(false);
            }
        }

        formatCommentsForClipboard() {
            const rows = [];
            let idx = 1;
            for (const comment of this.comments.values()) {
                const ts = comment.timestamp ? ` | ${new Date(comment.timestamp * (comment.timestamp > 2e12 ? 1 : 1000)).toLocaleString()}` : "";
                rows.push(`${idx}. ${comment.username || "anon"}: ${comment.text}${ts}`);
                idx++;
            }
            return rows.join("\n");
        }

        async copyComments(showToast = true) {
            const text = this.formatCommentsForClipboard();
            if (!text) return;
            const ok = await ClipboardService$1.copyToClipboard(text);
            if (ok && showToast) {
                Logger.info(`Copied ${this.comments.size} comments`);
            }
        }

        clearComments(updateUi = true) {
            this.comments.clear();
            this.state.lastSource = "none";
            this.state.lastUpdate = null;
            if (updateUi) this.updateUi();
        }

        async startAutoScroll() {
            if (this.state.scrolling) return;
            this.state.scrolling = true;
            this.updateUi();
            const container = this.commentContainer || this.findCommentContainer();
            if (!container) {
                this.state.scrolling = false;
                this.updateUi();
                return;
            }
            const maxRounds = this.settings.maxScrollRounds;
            const delay = this.settings.scrollDelay;
            for (let i = 0; i < maxRounds && this.state.scrolling; i++) {
                container.scrollBy({ top: this.settings.scrollStep, behavior: "smooth" });
                await this.vpStabilizer.waitForStability(container);
                this.scanDomAndUpdate();
                await this.sleep(delay);
                if (this.state.noNewRounds > 2) break;
            }
            this.state.scrolling = false;
            this.updateUi();
            if (this.settings.autoCopyOnFinish) {
                this.copyComments(false);
            }
        }

        stopAutoScroll() {
            this.state.scrolling = false;
            this.updateUi();
        }

        sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        isReelsExperience() {
            return /\/reel\//.test(location.pathname) || document.querySelector("video[src*='reel']") || document.querySelector("div[role='dialog'] video");
        }
    }

    (function bootstrap() {
        if (window.__igReelsCommentsCopier) return;
        window.__igReelsCommentsCopier = new InstagramReelsCommentsCopier();
    })();

})();
